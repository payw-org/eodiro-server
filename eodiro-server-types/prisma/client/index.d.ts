
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';


/**
 * Model Admin
 */

export type Admin = {
  userId: number
}

/**
 * Model CafeteriaMenu
 */

export type CafeteriaMenu = {
  campus: string
  servedAt: Date
  data: Prisma.JsonValue | null
}

/**
 * Model ChangePassword
 */

export type ChangePassword = {
  userId: number
  token: string
  requestedAt: Date
}

/**
 * Model CommunityBoard
 */

export type CommunityBoard = {
  id: number
  name: string
  description: string | null
  priority: number
  isDeleted: boolean
  createdBy: number
  createdAt: Date
  activeAt: Date | null
}

/**
 * Model CommunityBoardCandidate
 */

export type CommunityBoardCandidate = {
  id: number
  name: string
  description: string | null
  createdBy: number
  createdAt: Date
}

/**
 * Model CommunityBoardCandidateVote
 */

export type CommunityBoardCandidateVote = {
  boardCandidateId: number
  userId: number
}

/**
 * Model CommunityBoardPin
 */

export type CommunityBoardPin = {
  userId: number
  boardId: number
}

/**
 * Model CommunityComment
 */

export type CommunityComment = {
  id: number
  postId: number
  userId: number
  randomNickname: string
  body: string
  commentedAt: Date
  isDeleted: boolean
}

/**
 * Model CommunityPost
 */

export type CommunityPost = {
  id: number
  boardId: number
  userId: number
  title: string
  body: string
  randomNickname: string
  likesCount: number
  commentsCount: number
  bookmarksCount: number
  postedAt: Date
  editedAt: Date | null
  isDeleted: boolean
}

/**
 * Model CommunityPostBookmark
 */

export type CommunityPostBookmark = {
  userId: number
  postId: number
}

/**
 * Model CommunityPostLike
 */

export type CommunityPostLike = {
  userId: number
  postId: number
}

/**
 * Model CommunitySubcomment
 */

export type CommunitySubcomment = {
  id: number
  userId: number
  postId: number
  commentId: number
  randomNickname: string
  body: string
  subcommentedAt: Date
  isDeleted: boolean
}

/**
 * Model CoverageMajor
 */

export type CoverageMajor = {
  coverageCollege: string | null
  name: string
  code: string
}

/**
 * Model CoverageMajorLecture
 */

export type CoverageMajorLecture = {
  lectureId: string
  majorCode: string
}

/**
 * Model Lecture
 */

export type Lecture = {
  id: string
  year: number | null
  semester: string | null
  campus: string | null
  college: string | null
  major: string | null
  grade: number | null
  credit: number | null
  course: string | null
  section: string | null
  code: string | null
  name: string | null
  professor: string | null
  schedule: string | null
  building: number | null
  room: string | null
  note: string | null
}

/**
 * Model LiveChat
 */

export type LiveChat = {
  id: number
  message: string
  createdAt: Date
  userId: number
  randomNickname: string
}

/**
 * Model NoticeNotificationsSubscription
 */

export type NoticeNotificationsSubscription = {
  id: number
  userId: number
  noticeKey: string
  subscribedAt: Date
}

/**
 * Model PendingUser
 */

export type PendingUser = {
  id: number
  portalId: string
  password: string
  nickname: string
  randomNickname: string
  joinedAt: Date
  token: string
}

/**
 * Model Period
 */

export type Period = {
  lectureId: string
  day: string
  startH: number
  startM: number
  endH: number
  endM: number
}

/**
 * Model Push
 */

export type Push = {
  userId: number
  expoPushToken: string
  registeredAt: Date
  activeAt: Date | null
}

/**
 * Model User
 */

export type User = {
  id: number
  portalId: string
  password: string
  nickname: string
  randomNickname: string
  joinedAt: Date
  refreshToken: string | null
}

/**
 * Model ReportComment
 */

export type ReportComment = {
  id: number
  commentId: number
  userId: number
  title: string
  body: string | null
  reportedAt: Date
}

/**
 * Model ReportPost
 */

export type ReportPost = {
  id: number
  postId: number
  userId: number
  title: string
  body: string | null
  reportedAt: Date
}

/**
 * Model ReportSubcomment
 */

export type ReportSubcomment = {
  id: number
  subcommentId: number
  userId: number
  title: string
  body: string | null
  reportedAt: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<T>;

  /**
   * Execute queries in a transaction
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   */
  $transaction: PromiseConstructor['all']

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<GlobalReject>;

  /**
   * `prisma.cafeteriaMenu`: Exposes CRUD operations for the **CafeteriaMenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeteriaMenus
    * const cafeteriaMenus = await prisma.cafeteriaMenu.findMany()
    * ```
    */
  get cafeteriaMenu(): Prisma.CafeteriaMenuDelegate<GlobalReject>;

  /**
   * `prisma.changePassword`: Exposes CRUD operations for the **ChangePassword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangePasswords
    * const changePasswords = await prisma.changePassword.findMany()
    * ```
    */
  get changePassword(): Prisma.ChangePasswordDelegate<GlobalReject>;

  /**
   * `prisma.communityBoard`: Exposes CRUD operations for the **CommunityBoard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityBoards
    * const communityBoards = await prisma.communityBoard.findMany()
    * ```
    */
  get communityBoard(): Prisma.CommunityBoardDelegate<GlobalReject>;

  /**
   * `prisma.communityBoardCandidate`: Exposes CRUD operations for the **CommunityBoardCandidate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityBoardCandidates
    * const communityBoardCandidates = await prisma.communityBoardCandidate.findMany()
    * ```
    */
  get communityBoardCandidate(): Prisma.CommunityBoardCandidateDelegate<GlobalReject>;

  /**
   * `prisma.communityBoardCandidateVote`: Exposes CRUD operations for the **CommunityBoardCandidateVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityBoardCandidateVotes
    * const communityBoardCandidateVotes = await prisma.communityBoardCandidateVote.findMany()
    * ```
    */
  get communityBoardCandidateVote(): Prisma.CommunityBoardCandidateVoteDelegate<GlobalReject>;

  /**
   * `prisma.communityBoardPin`: Exposes CRUD operations for the **CommunityBoardPin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityBoardPins
    * const communityBoardPins = await prisma.communityBoardPin.findMany()
    * ```
    */
  get communityBoardPin(): Prisma.CommunityBoardPinDelegate<GlobalReject>;

  /**
   * `prisma.communityComment`: Exposes CRUD operations for the **CommunityComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityComments
    * const communityComments = await prisma.communityComment.findMany()
    * ```
    */
  get communityComment(): Prisma.CommunityCommentDelegate<GlobalReject>;

  /**
   * `prisma.communityPost`: Exposes CRUD operations for the **CommunityPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityPosts
    * const communityPosts = await prisma.communityPost.findMany()
    * ```
    */
  get communityPost(): Prisma.CommunityPostDelegate<GlobalReject>;

  /**
   * `prisma.communityPostBookmark`: Exposes CRUD operations for the **CommunityPostBookmark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityPostBookmarks
    * const communityPostBookmarks = await prisma.communityPostBookmark.findMany()
    * ```
    */
  get communityPostBookmark(): Prisma.CommunityPostBookmarkDelegate<GlobalReject>;

  /**
   * `prisma.communityPostLike`: Exposes CRUD operations for the **CommunityPostLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityPostLikes
    * const communityPostLikes = await prisma.communityPostLike.findMany()
    * ```
    */
  get communityPostLike(): Prisma.CommunityPostLikeDelegate<GlobalReject>;

  /**
   * `prisma.communitySubcomment`: Exposes CRUD operations for the **CommunitySubcomment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunitySubcomments
    * const communitySubcomments = await prisma.communitySubcomment.findMany()
    * ```
    */
  get communitySubcomment(): Prisma.CommunitySubcommentDelegate<GlobalReject>;

  /**
   * `prisma.coverageMajor`: Exposes CRUD operations for the **CoverageMajor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoverageMajors
    * const coverageMajors = await prisma.coverageMajor.findMany()
    * ```
    */
  get coverageMajor(): Prisma.CoverageMajorDelegate<GlobalReject>;

  /**
   * `prisma.coverageMajorLecture`: Exposes CRUD operations for the **CoverageMajorLecture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoverageMajorLectures
    * const coverageMajorLectures = await prisma.coverageMajorLecture.findMany()
    * ```
    */
  get coverageMajorLecture(): Prisma.CoverageMajorLectureDelegate<GlobalReject>;

  /**
   * `prisma.lecture`: Exposes CRUD operations for the **Lecture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lectures
    * const lectures = await prisma.lecture.findMany()
    * ```
    */
  get lecture(): Prisma.LectureDelegate<GlobalReject>;

  /**
   * `prisma.liveChat`: Exposes CRUD operations for the **LiveChat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiveChats
    * const liveChats = await prisma.liveChat.findMany()
    * ```
    */
  get liveChat(): Prisma.LiveChatDelegate<GlobalReject>;

  /**
   * `prisma.noticeNotificationsSubscription`: Exposes CRUD operations for the **NoticeNotificationsSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoticeNotificationsSubscriptions
    * const noticeNotificationsSubscriptions = await prisma.noticeNotificationsSubscription.findMany()
    * ```
    */
  get noticeNotificationsSubscription(): Prisma.NoticeNotificationsSubscriptionDelegate<GlobalReject>;

  /**
   * `prisma.pendingUser`: Exposes CRUD operations for the **PendingUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingUsers
    * const pendingUsers = await prisma.pendingUser.findMany()
    * ```
    */
  get pendingUser(): Prisma.PendingUserDelegate<GlobalReject>;

  /**
   * `prisma.period`: Exposes CRUD operations for the **Period** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Periods
    * const periods = await prisma.period.findMany()
    * ```
    */
  get period(): Prisma.PeriodDelegate<GlobalReject>;

  /**
   * `prisma.push`: Exposes CRUD operations for the **Push** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pushes
    * const pushes = await prisma.push.findMany()
    * ```
    */
  get push(): Prisma.PushDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.reportComment`: Exposes CRUD operations for the **ReportComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportComments
    * const reportComments = await prisma.reportComment.findMany()
    * ```
    */
  get reportComment(): Prisma.ReportCommentDelegate<GlobalReject>;

  /**
   * `prisma.reportPost`: Exposes CRUD operations for the **ReportPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportPosts
    * const reportPosts = await prisma.reportPost.findMany()
    * ```
    */
  get reportPost(): Prisma.ReportPostDelegate<GlobalReject>;

  /**
   * `prisma.reportSubcomment`: Exposes CRUD operations for the **ReportSubcomment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportSubcomments
    * const reportSubcomments = await prisma.reportSubcomment.findMany()
    * ```
    */
  get reportSubcomment(): Prisma.ReportSubcommentDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.16.1
   * Query Engine version: 8b74ad57aaf2cc6c155f382a18a8e3ba95aceb03
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  /**
   * Allows creating `select` or `include` outside of the main statement
   * From https://github.com/prisma/prisma/issues/3372#issuecomment-762296484
   */

  type Cast<A1, A2> = A1 extends A2 ? A1 : A2;

  /**
   * `Exact` forces a type to comply by another type. It will need to be a subset
   * and must have exactly the same properties, no more, no less.
   */
  type Exact<A, W> = A & Cast<{
    [K in keyof A]: K extends keyof W ? A[K] : never
  }, W>;

  type Narrow<A, W = unknown> =
      A & {[K in keyof A]: NarrowAt<A, W, K>};

  type NarrowAt<A, W, K extends keyof A, AK = A[K], WK = Att<W, K>> =
      WK extends Widen<infer T> ? T :
      AK extends Narrowable ? AK & WK :
      Narrow<AK, WK>;

  type Att<O, K> = K extends keyof O ? O[K] : unknown;

  type Widen<A> = {[type]: A};

  type Narrowable =
  | string
  | number
  | bigint
  | boolean
  | [];

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<Narrow<S, V>, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Admin: 'Admin',
    CafeteriaMenu: 'CafeteriaMenu',
    ChangePassword: 'ChangePassword',
    CommunityBoard: 'CommunityBoard',
    CommunityBoardCandidate: 'CommunityBoardCandidate',
    CommunityBoardCandidateVote: 'CommunityBoardCandidateVote',
    CommunityBoardPin: 'CommunityBoardPin',
    CommunityComment: 'CommunityComment',
    CommunityPost: 'CommunityPost',
    CommunityPostBookmark: 'CommunityPostBookmark',
    CommunityPostLike: 'CommunityPostLike',
    CommunitySubcomment: 'CommunitySubcomment',
    CoverageMajor: 'CoverageMajor',
    CoverageMajorLecture: 'CoverageMajorLecture',
    Lecture: 'Lecture',
    LiveChat: 'LiveChat',
    NoticeNotificationsSubscription: 'NoticeNotificationsSubscription',
    PendingUser: 'PendingUser',
    Period: 'Period',
    Push: 'Push',
    User: 'User',
    ReportComment: 'ReportComment',
    ReportPost: 'ReportPost',
    ReportSubcomment: 'ReportSubcomment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model Admin
   */


  export type AggregateAdmin = {
    count: AdminCountAggregateOutputType | null
    avg: AdminAvgAggregateOutputType | null
    sum: AdminSumAggregateOutputType | null
    min: AdminMinAggregateOutputType | null
    max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    userId: number
  }

  export type AdminSumAggregateOutputType = {
    userId: number
  }

  export type AdminMinAggregateOutputType = {
    userId: number
  }

  export type AdminMaxAggregateOutputType = {
    userId: number
  }

  export type AdminCountAggregateOutputType = {
    userId: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    userId?: true
  }

  export type AdminSumAggregateInputType = {
    userId?: true
  }

  export type AdminMinAggregateInputType = {
    userId?: true
  }

  export type AdminMaxAggregateInputType = {
    userId?: true
  }

  export type AdminCountAggregateInputType = {
    userId?: true
    _all?: true
  }

  export type AdminAggregateArgs = {
    /**
     * Filter which Admin to aggregate.
    **/
    where?: AdminWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Admins to fetch.
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
    [P in keyof T & keyof AggregateAdmin]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }



  export type AdminSelect = {
    userId?: boolean
    user?: boolean | UserArgs
  }

  export type AdminInclude = {
    user?: boolean | UserArgs
  }

  export type AdminGetPayload<
    S extends boolean | null | undefined | AdminArgs,
    U = keyof S
      > = S extends true
        ? Admin
    : S extends undefined
    ? never
    : S extends AdminArgs | AdminFindManyArgs
    ?'include' extends U
    ? Admin  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Admin ?Admin [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Admin
  : Admin


  type AdminCountArgs = Merge<
    Omit<AdminFindManyArgs, 'select' | 'include'> & {
      select?: AdminCountAggregateInputType | true
    }
  >

  export interface AdminDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdminFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Admin'> extends True ? CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>> : CheckSelect<T, Prisma__AdminClient<Admin | null >, Prisma__AdminClient<AdminGetPayload<T> | null >>

    /**
     * Find the first Admin that matches the filter.
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdminFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Admin'> extends True ? CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>> : CheckSelect<T, Prisma__AdminClient<Admin | null >, Prisma__AdminClient<AdminGetPayload<T> | null >>

    /**
     * Find zero or more Admins that matches the filter.
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const adminWithUserIdOnly = await prisma.admin.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs>(
      args?: SelectSubset<T, AdminFindManyArgs>
    ): CheckSelect<T, Promise<Array<Admin>>, Promise<Array<AdminGetPayload<T>>>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs>(
      args: SelectSubset<T, AdminCreateArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs>(
      args: SelectSubset<T, AdminDeleteArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs>(
      args: SelectSubset<T, AdminUpdateArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs>(
      args?: SelectSubset<T, AdminDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Admins.
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs>(
      args: SelectSubset<T, AdminUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs>(
      args: SelectSubset<T, AdminUpsertArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Count the number of Admins.
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Promise<GetAdminAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Throw an Error if a Admin can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Admin to fetch.
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Throw an Error if a Admin can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Admin to fetch.
    **/
    where?: AdminWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Admins to fetch.
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Admins.
    **/
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Filter, which Admins to fetch.
    **/
    where?: AdminWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Admins to fetch.
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
    **/
    skip?: number
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * The data needed to create a Admin.
    **/
    data: XOR<AdminUncheckedCreateInput, AdminCreateInput>
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * The data needed to update a Admin.
    **/
    data: XOR<AdminUncheckedUpdateInput, AdminUpdateInput>
    /**
     * Choose, which Admin to update.
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs = {
    data: XOR<AdminUncheckedUpdateManyInput, AdminUpdateManyMutationInput>
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * The filter to search for the Admin to update in case it exists.
    **/
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
    **/
    create: XOR<AdminUncheckedCreateInput, AdminCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AdminUncheckedUpdateInput, AdminUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Filter which Admin to delete.
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs = {
    where?: AdminWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
  }



  /**
   * Model CafeteriaMenu
   */


  export type AggregateCafeteriaMenu = {
    count: CafeteriaMenuCountAggregateOutputType | null
    min: CafeteriaMenuMinAggregateOutputType | null
    max: CafeteriaMenuMaxAggregateOutputType | null
  }

  export type CafeteriaMenuMinAggregateOutputType = {
    campus: string | null
    servedAt: Date | null
  }

  export type CafeteriaMenuMaxAggregateOutputType = {
    campus: string | null
    servedAt: Date | null
  }

  export type CafeteriaMenuCountAggregateOutputType = {
    campus: number | null
    servedAt: number | null
    data: number | null
    _all: number
  }


  export type CafeteriaMenuMinAggregateInputType = {
    campus?: true
    servedAt?: true
  }

  export type CafeteriaMenuMaxAggregateInputType = {
    campus?: true
    servedAt?: true
  }

  export type CafeteriaMenuCountAggregateInputType = {
    campus?: true
    servedAt?: true
    data?: true
    _all?: true
  }

  export type CafeteriaMenuAggregateArgs = {
    /**
     * Filter which CafeteriaMenu to aggregate.
    **/
    where?: CafeteriaMenuWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CafeteriaMenus to fetch.
    **/
    orderBy?: Enumerable<CafeteriaMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CafeteriaMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeteriaMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeteriaMenus.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeteriaMenus
    **/
    count?: true | CafeteriaMenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CafeteriaMenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CafeteriaMenuMaxAggregateInputType
  }

  export type GetCafeteriaMenuAggregateType<T extends CafeteriaMenuAggregateArgs> = {
    [P in keyof T & keyof AggregateCafeteriaMenu]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeteriaMenu[P]>
      : GetScalarType<T[P], AggregateCafeteriaMenu[P]>
  }



  export type CafeteriaMenuSelect = {
    campus?: boolean
    servedAt?: boolean
    data?: boolean
  }

  export type CafeteriaMenuGetPayload<
    S extends boolean | null | undefined | CafeteriaMenuArgs,
    U = keyof S
      > = S extends true
        ? CafeteriaMenu
    : S extends undefined
    ? never
    : S extends CafeteriaMenuArgs | CafeteriaMenuFindManyArgs
    ?'include' extends U
    ? CafeteriaMenu 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CafeteriaMenu ?CafeteriaMenu [P]
  : 
     never
  } 
    : CafeteriaMenu
  : CafeteriaMenu


  type CafeteriaMenuCountArgs = Merge<
    Omit<CafeteriaMenuFindManyArgs, 'select' | 'include'> & {
      select?: CafeteriaMenuCountAggregateInputType | true
    }
  >

  export interface CafeteriaMenuDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CafeteriaMenu that matches the filter.
     * @param {CafeteriaMenuFindUniqueArgs} args - Arguments to find a CafeteriaMenu
     * @example
     * // Get one CafeteriaMenu
     * const cafeteriaMenu = await prisma.cafeteriaMenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeteriaMenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeteriaMenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeteriaMenu'> extends True ? CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>> : CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu | null >, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T> | null >>

    /**
     * Find the first CafeteriaMenu that matches the filter.
     * @param {CafeteriaMenuFindFirstArgs} args - Arguments to find a CafeteriaMenu
     * @example
     * // Get one CafeteriaMenu
     * const cafeteriaMenu = await prisma.cafeteriaMenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeteriaMenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeteriaMenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeteriaMenu'> extends True ? CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>> : CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu | null >, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T> | null >>

    /**
     * Find zero or more CafeteriaMenus that matches the filter.
     * @param {CafeteriaMenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeteriaMenus
     * const cafeteriaMenus = await prisma.cafeteriaMenu.findMany()
     * 
     * // Get first 10 CafeteriaMenus
     * const cafeteriaMenus = await prisma.cafeteriaMenu.findMany({ take: 10 })
     * 
     * // Only select the `campus`
     * const cafeteriaMenuWithCampusOnly = await prisma.cafeteriaMenu.findMany({ select: { campus: true } })
     * 
    **/
    findMany<T extends CafeteriaMenuFindManyArgs>(
      args?: SelectSubset<T, CafeteriaMenuFindManyArgs>
    ): CheckSelect<T, Promise<Array<CafeteriaMenu>>, Promise<Array<CafeteriaMenuGetPayload<T>>>>

    /**
     * Create a CafeteriaMenu.
     * @param {CafeteriaMenuCreateArgs} args - Arguments to create a CafeteriaMenu.
     * @example
     * // Create one CafeteriaMenu
     * const CafeteriaMenu = await prisma.cafeteriaMenu.create({
     *   data: {
     *     // ... data to create a CafeteriaMenu
     *   }
     * })
     * 
    **/
    create<T extends CafeteriaMenuCreateArgs>(
      args: SelectSubset<T, CafeteriaMenuCreateArgs>
    ): CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>>

    /**
     * Delete a CafeteriaMenu.
     * @param {CafeteriaMenuDeleteArgs} args - Arguments to delete one CafeteriaMenu.
     * @example
     * // Delete one CafeteriaMenu
     * const CafeteriaMenu = await prisma.cafeteriaMenu.delete({
     *   where: {
     *     // ... filter to delete one CafeteriaMenu
     *   }
     * })
     * 
    **/
    delete<T extends CafeteriaMenuDeleteArgs>(
      args: SelectSubset<T, CafeteriaMenuDeleteArgs>
    ): CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>>

    /**
     * Update one CafeteriaMenu.
     * @param {CafeteriaMenuUpdateArgs} args - Arguments to update one CafeteriaMenu.
     * @example
     * // Update one CafeteriaMenu
     * const cafeteriaMenu = await prisma.cafeteriaMenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeteriaMenuUpdateArgs>(
      args: SelectSubset<T, CafeteriaMenuUpdateArgs>
    ): CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>>

    /**
     * Delete zero or more CafeteriaMenus.
     * @param {CafeteriaMenuDeleteManyArgs} args - Arguments to filter CafeteriaMenus to delete.
     * @example
     * // Delete a few CafeteriaMenus
     * const { count } = await prisma.cafeteriaMenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeteriaMenuDeleteManyArgs>(
      args?: SelectSubset<T, CafeteriaMenuDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CafeteriaMenus.
     * @param {CafeteriaMenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeteriaMenus
     * const cafeteriaMenu = await prisma.cafeteriaMenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeteriaMenuUpdateManyArgs>(
      args: SelectSubset<T, CafeteriaMenuUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CafeteriaMenu.
     * @param {CafeteriaMenuUpsertArgs} args - Arguments to update or create a CafeteriaMenu.
     * @example
     * // Update or create a CafeteriaMenu
     * const cafeteriaMenu = await prisma.cafeteriaMenu.upsert({
     *   create: {
     *     // ... data to create a CafeteriaMenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeteriaMenu we want to update
     *   }
     * })
    **/
    upsert<T extends CafeteriaMenuUpsertArgs>(
      args: SelectSubset<T, CafeteriaMenuUpsertArgs>
    ): CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>>

    /**
     * Count the number of CafeteriaMenus.
     * @param {CafeteriaMenuCountArgs} args - Arguments to filter CafeteriaMenus to count.
     * @example
     * // Count the number of CafeteriaMenus
     * const count = await prisma.cafeteriaMenu.count({
     *   where: {
     *     // ... the filter for the CafeteriaMenus we want to count
     *   }
     * })
    **/
    count<T extends CafeteriaMenuCountArgs>(
      args?: Subset<T, CafeteriaMenuCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeteriaMenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeteriaMenu.
     * @param {CafeteriaMenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeteriaMenuAggregateArgs>(args: Subset<T, CafeteriaMenuAggregateArgs>): Promise<GetCafeteriaMenuAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeteriaMenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeteriaMenuClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CafeteriaMenu findUnique
   */
  export type CafeteriaMenuFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * Throw an Error if a CafeteriaMenu can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CafeteriaMenu to fetch.
    **/
    where: CafeteriaMenuWhereUniqueInput
  }


  /**
   * CafeteriaMenu findFirst
   */
  export type CafeteriaMenuFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * Throw an Error if a CafeteriaMenu can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CafeteriaMenu to fetch.
    **/
    where?: CafeteriaMenuWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CafeteriaMenus to fetch.
    **/
    orderBy?: Enumerable<CafeteriaMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeteriaMenus.
    **/
    cursor?: CafeteriaMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeteriaMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeteriaMenus.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CafeteriaMenus.
    **/
    distinct?: Enumerable<CafeteriaMenuScalarFieldEnum>
  }


  /**
   * CafeteriaMenu findMany
   */
  export type CafeteriaMenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * Filter, which CafeteriaMenus to fetch.
    **/
    where?: CafeteriaMenuWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CafeteriaMenus to fetch.
    **/
    orderBy?: Enumerable<CafeteriaMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeteriaMenus.
    **/
    cursor?: CafeteriaMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeteriaMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeteriaMenus.
    **/
    skip?: number
    distinct?: Enumerable<CafeteriaMenuScalarFieldEnum>
  }


  /**
   * CafeteriaMenu create
   */
  export type CafeteriaMenuCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * The data needed to create a CafeteriaMenu.
    **/
    data: XOR<CafeteriaMenuUncheckedCreateInput, CafeteriaMenuCreateInput>
  }


  /**
   * CafeteriaMenu update
   */
  export type CafeteriaMenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * The data needed to update a CafeteriaMenu.
    **/
    data: XOR<CafeteriaMenuUncheckedUpdateInput, CafeteriaMenuUpdateInput>
    /**
     * Choose, which CafeteriaMenu to update.
    **/
    where: CafeteriaMenuWhereUniqueInput
  }


  /**
   * CafeteriaMenu updateMany
   */
  export type CafeteriaMenuUpdateManyArgs = {
    data: XOR<CafeteriaMenuUncheckedUpdateManyInput, CafeteriaMenuUpdateManyMutationInput>
    where?: CafeteriaMenuWhereInput
  }


  /**
   * CafeteriaMenu upsert
   */
  export type CafeteriaMenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * The filter to search for the CafeteriaMenu to update in case it exists.
    **/
    where: CafeteriaMenuWhereUniqueInput
    /**
     * In case the CafeteriaMenu found by the `where` argument doesn't exist, create a new CafeteriaMenu with this data.
    **/
    create: XOR<CafeteriaMenuUncheckedCreateInput, CafeteriaMenuCreateInput>
    /**
     * In case the CafeteriaMenu was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CafeteriaMenuUncheckedUpdateInput, CafeteriaMenuUpdateInput>
  }


  /**
   * CafeteriaMenu delete
   */
  export type CafeteriaMenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * Filter which CafeteriaMenu to delete.
    **/
    where: CafeteriaMenuWhereUniqueInput
  }


  /**
   * CafeteriaMenu deleteMany
   */
  export type CafeteriaMenuDeleteManyArgs = {
    where?: CafeteriaMenuWhereInput
  }


  /**
   * CafeteriaMenu without action
   */
  export type CafeteriaMenuArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
  }



  /**
   * Model ChangePassword
   */


  export type AggregateChangePassword = {
    count: ChangePasswordCountAggregateOutputType | null
    avg: ChangePasswordAvgAggregateOutputType | null
    sum: ChangePasswordSumAggregateOutputType | null
    min: ChangePasswordMinAggregateOutputType | null
    max: ChangePasswordMaxAggregateOutputType | null
  }

  export type ChangePasswordAvgAggregateOutputType = {
    userId: number
  }

  export type ChangePasswordSumAggregateOutputType = {
    userId: number
  }

  export type ChangePasswordMinAggregateOutputType = {
    userId: number
    token: string | null
    requestedAt: Date | null
  }

  export type ChangePasswordMaxAggregateOutputType = {
    userId: number
    token: string | null
    requestedAt: Date | null
  }

  export type ChangePasswordCountAggregateOutputType = {
    userId: number
    token: number | null
    requestedAt: number | null
    _all: number
  }


  export type ChangePasswordAvgAggregateInputType = {
    userId?: true
  }

  export type ChangePasswordSumAggregateInputType = {
    userId?: true
  }

  export type ChangePasswordMinAggregateInputType = {
    userId?: true
    token?: true
    requestedAt?: true
  }

  export type ChangePasswordMaxAggregateInputType = {
    userId?: true
    token?: true
    requestedAt?: true
  }

  export type ChangePasswordCountAggregateInputType = {
    userId?: true
    token?: true
    requestedAt?: true
    _all?: true
  }

  export type ChangePasswordAggregateArgs = {
    /**
     * Filter which ChangePassword to aggregate.
    **/
    where?: ChangePasswordWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ChangePasswords to fetch.
    **/
    orderBy?: Enumerable<ChangePasswordOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ChangePasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangePasswords from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangePasswords.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangePasswords
    **/
    count?: true | ChangePasswordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ChangePasswordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ChangePasswordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ChangePasswordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ChangePasswordMaxAggregateInputType
  }

  export type GetChangePasswordAggregateType<T extends ChangePasswordAggregateArgs> = {
    [P in keyof T & keyof AggregateChangePassword]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangePassword[P]>
      : GetScalarType<T[P], AggregateChangePassword[P]>
  }



  export type ChangePasswordSelect = {
    userId?: boolean
    token?: boolean
    requestedAt?: boolean
    user?: boolean | UserArgs
  }

  export type ChangePasswordInclude = {
    user?: boolean | UserArgs
  }

  export type ChangePasswordGetPayload<
    S extends boolean | null | undefined | ChangePasswordArgs,
    U = keyof S
      > = S extends true
        ? ChangePassword
    : S extends undefined
    ? never
    : S extends ChangePasswordArgs | ChangePasswordFindManyArgs
    ?'include' extends U
    ? ChangePassword  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ChangePassword ?ChangePassword [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ChangePassword
  : ChangePassword


  type ChangePasswordCountArgs = Merge<
    Omit<ChangePasswordFindManyArgs, 'select' | 'include'> & {
      select?: ChangePasswordCountAggregateInputType | true
    }
  >

  export interface ChangePasswordDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ChangePassword that matches the filter.
     * @param {ChangePasswordFindUniqueArgs} args - Arguments to find a ChangePassword
     * @example
     * // Get one ChangePassword
     * const changePassword = await prisma.changePassword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChangePasswordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChangePasswordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChangePassword'> extends True ? CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>> : CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword | null >, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T> | null >>

    /**
     * Find the first ChangePassword that matches the filter.
     * @param {ChangePasswordFindFirstArgs} args - Arguments to find a ChangePassword
     * @example
     * // Get one ChangePassword
     * const changePassword = await prisma.changePassword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChangePasswordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChangePasswordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChangePassword'> extends True ? CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>> : CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword | null >, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T> | null >>

    /**
     * Find zero or more ChangePasswords that matches the filter.
     * @param {ChangePasswordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangePasswords
     * const changePasswords = await prisma.changePassword.findMany()
     * 
     * // Get first 10 ChangePasswords
     * const changePasswords = await prisma.changePassword.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const changePasswordWithUserIdOnly = await prisma.changePassword.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends ChangePasswordFindManyArgs>(
      args?: SelectSubset<T, ChangePasswordFindManyArgs>
    ): CheckSelect<T, Promise<Array<ChangePassword>>, Promise<Array<ChangePasswordGetPayload<T>>>>

    /**
     * Create a ChangePassword.
     * @param {ChangePasswordCreateArgs} args - Arguments to create a ChangePassword.
     * @example
     * // Create one ChangePassword
     * const ChangePassword = await prisma.changePassword.create({
     *   data: {
     *     // ... data to create a ChangePassword
     *   }
     * })
     * 
    **/
    create<T extends ChangePasswordCreateArgs>(
      args: SelectSubset<T, ChangePasswordCreateArgs>
    ): CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>>

    /**
     * Delete a ChangePassword.
     * @param {ChangePasswordDeleteArgs} args - Arguments to delete one ChangePassword.
     * @example
     * // Delete one ChangePassword
     * const ChangePassword = await prisma.changePassword.delete({
     *   where: {
     *     // ... filter to delete one ChangePassword
     *   }
     * })
     * 
    **/
    delete<T extends ChangePasswordDeleteArgs>(
      args: SelectSubset<T, ChangePasswordDeleteArgs>
    ): CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>>

    /**
     * Update one ChangePassword.
     * @param {ChangePasswordUpdateArgs} args - Arguments to update one ChangePassword.
     * @example
     * // Update one ChangePassword
     * const changePassword = await prisma.changePassword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChangePasswordUpdateArgs>(
      args: SelectSubset<T, ChangePasswordUpdateArgs>
    ): CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>>

    /**
     * Delete zero or more ChangePasswords.
     * @param {ChangePasswordDeleteManyArgs} args - Arguments to filter ChangePasswords to delete.
     * @example
     * // Delete a few ChangePasswords
     * const { count } = await prisma.changePassword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChangePasswordDeleteManyArgs>(
      args?: SelectSubset<T, ChangePasswordDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more ChangePasswords.
     * @param {ChangePasswordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangePasswords
     * const changePassword = await prisma.changePassword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChangePasswordUpdateManyArgs>(
      args: SelectSubset<T, ChangePasswordUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one ChangePassword.
     * @param {ChangePasswordUpsertArgs} args - Arguments to update or create a ChangePassword.
     * @example
     * // Update or create a ChangePassword
     * const changePassword = await prisma.changePassword.upsert({
     *   create: {
     *     // ... data to create a ChangePassword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangePassword we want to update
     *   }
     * })
    **/
    upsert<T extends ChangePasswordUpsertArgs>(
      args: SelectSubset<T, ChangePasswordUpsertArgs>
    ): CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>>

    /**
     * Count the number of ChangePasswords.
     * @param {ChangePasswordCountArgs} args - Arguments to filter ChangePasswords to count.
     * @example
     * // Count the number of ChangePasswords
     * const count = await prisma.changePassword.count({
     *   where: {
     *     // ... the filter for the ChangePasswords we want to count
     *   }
     * })
    **/
    count<T extends ChangePasswordCountArgs>(
      args?: Subset<T, ChangePasswordCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangePasswordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangePassword.
     * @param {ChangePasswordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangePasswordAggregateArgs>(args: Subset<T, ChangePasswordAggregateArgs>): Promise<GetChangePasswordAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangePassword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChangePasswordClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ChangePassword findUnique
   */
  export type ChangePasswordFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * Throw an Error if a ChangePassword can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ChangePassword to fetch.
    **/
    where: ChangePasswordWhereUniqueInput
  }


  /**
   * ChangePassword findFirst
   */
  export type ChangePasswordFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * Throw an Error if a ChangePassword can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ChangePassword to fetch.
    **/
    where?: ChangePasswordWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ChangePasswords to fetch.
    **/
    orderBy?: Enumerable<ChangePasswordOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangePasswords.
    **/
    cursor?: ChangePasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangePasswords from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangePasswords.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of ChangePasswords.
    **/
    distinct?: Enumerable<ChangePasswordScalarFieldEnum>
  }


  /**
   * ChangePassword findMany
   */
  export type ChangePasswordFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * Filter, which ChangePasswords to fetch.
    **/
    where?: ChangePasswordWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ChangePasswords to fetch.
    **/
    orderBy?: Enumerable<ChangePasswordOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangePasswords.
    **/
    cursor?: ChangePasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangePasswords from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangePasswords.
    **/
    skip?: number
    distinct?: Enumerable<ChangePasswordScalarFieldEnum>
  }


  /**
   * ChangePassword create
   */
  export type ChangePasswordCreateArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * The data needed to create a ChangePassword.
    **/
    data: XOR<ChangePasswordUncheckedCreateInput, ChangePasswordCreateInput>
  }


  /**
   * ChangePassword update
   */
  export type ChangePasswordUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * The data needed to update a ChangePassword.
    **/
    data: XOR<ChangePasswordUncheckedUpdateInput, ChangePasswordUpdateInput>
    /**
     * Choose, which ChangePassword to update.
    **/
    where: ChangePasswordWhereUniqueInput
  }


  /**
   * ChangePassword updateMany
   */
  export type ChangePasswordUpdateManyArgs = {
    data: XOR<ChangePasswordUncheckedUpdateManyInput, ChangePasswordUpdateManyMutationInput>
    where?: ChangePasswordWhereInput
  }


  /**
   * ChangePassword upsert
   */
  export type ChangePasswordUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * The filter to search for the ChangePassword to update in case it exists.
    **/
    where: ChangePasswordWhereUniqueInput
    /**
     * In case the ChangePassword found by the `where` argument doesn't exist, create a new ChangePassword with this data.
    **/
    create: XOR<ChangePasswordUncheckedCreateInput, ChangePasswordCreateInput>
    /**
     * In case the ChangePassword was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ChangePasswordUncheckedUpdateInput, ChangePasswordUpdateInput>
  }


  /**
   * ChangePassword delete
   */
  export type ChangePasswordDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * Filter which ChangePassword to delete.
    **/
    where: ChangePasswordWhereUniqueInput
  }


  /**
   * ChangePassword deleteMany
   */
  export type ChangePasswordDeleteManyArgs = {
    where?: ChangePasswordWhereInput
  }


  /**
   * ChangePassword without action
   */
  export type ChangePasswordArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
  }



  /**
   * Model CommunityBoard
   */


  export type AggregateCommunityBoard = {
    count: CommunityBoardCountAggregateOutputType | null
    avg: CommunityBoardAvgAggregateOutputType | null
    sum: CommunityBoardSumAggregateOutputType | null
    min: CommunityBoardMinAggregateOutputType | null
    max: CommunityBoardMaxAggregateOutputType | null
  }

  export type CommunityBoardAvgAggregateOutputType = {
    id: number
    priority: number
    createdBy: number
  }

  export type CommunityBoardSumAggregateOutputType = {
    id: number
    priority: number
    createdBy: number
  }

  export type CommunityBoardMinAggregateOutputType = {
    id: number
    name: string | null
    description: string | null
    priority: number
    isDeleted: boolean | null
    createdBy: number
    createdAt: Date | null
    activeAt: Date | null
  }

  export type CommunityBoardMaxAggregateOutputType = {
    id: number
    name: string | null
    description: string | null
    priority: number
    isDeleted: boolean | null
    createdBy: number
    createdAt: Date | null
    activeAt: Date | null
  }

  export type CommunityBoardCountAggregateOutputType = {
    id: number
    name: number | null
    description: number | null
    priority: number
    isDeleted: number | null
    createdBy: number
    createdAt: number | null
    activeAt: number | null
    _all: number
  }


  export type CommunityBoardAvgAggregateInputType = {
    id?: true
    priority?: true
    createdBy?: true
  }

  export type CommunityBoardSumAggregateInputType = {
    id?: true
    priority?: true
    createdBy?: true
  }

  export type CommunityBoardMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priority?: true
    isDeleted?: true
    createdBy?: true
    createdAt?: true
    activeAt?: true
  }

  export type CommunityBoardMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priority?: true
    isDeleted?: true
    createdBy?: true
    createdAt?: true
    activeAt?: true
  }

  export type CommunityBoardCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priority?: true
    isDeleted?: true
    createdBy?: true
    createdAt?: true
    activeAt?: true
    _all?: true
  }

  export type CommunityBoardAggregateArgs = {
    /**
     * Filter which CommunityBoard to aggregate.
    **/
    where?: CommunityBoardWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoards to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoards.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityBoards
    **/
    count?: true | CommunityBoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityBoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityBoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityBoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityBoardMaxAggregateInputType
  }

  export type GetCommunityBoardAggregateType<T extends CommunityBoardAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityBoard]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityBoard[P]>
      : GetScalarType<T[P], AggregateCommunityBoard[P]>
  }



  export type CommunityBoardSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    priority?: boolean
    isDeleted?: boolean
    createdBy?: boolean
    createdAt?: boolean
    activeAt?: boolean
    user?: boolean | UserArgs
    communityBoardPins?: boolean | CommunityBoardPinFindManyArgs
    communityPosts?: boolean | CommunityPostFindManyArgs
  }

  export type CommunityBoardInclude = {
    user?: boolean | UserArgs
    communityBoardPins?: boolean | CommunityBoardPinFindManyArgs
    communityPosts?: boolean | CommunityPostFindManyArgs
  }

  export type CommunityBoardGetPayload<
    S extends boolean | null | undefined | CommunityBoardArgs,
    U = keyof S
      > = S extends true
        ? CommunityBoard
    : S extends undefined
    ? never
    : S extends CommunityBoardArgs | CommunityBoardFindManyArgs
    ?'include' extends U
    ? CommunityBoard  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'communityBoardPins'
        ? Array < CommunityBoardPinGetPayload<S['include'][P]>>  :
        P extends 'communityPosts'
        ? Array < CommunityPostGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityBoard ?CommunityBoard [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'communityBoardPins'
        ? Array < CommunityBoardPinGetPayload<S['select'][P]>>  :
        P extends 'communityPosts'
        ? Array < CommunityPostGetPayload<S['select'][P]>>  : never
  } 
    : CommunityBoard
  : CommunityBoard


  type CommunityBoardCountArgs = Merge<
    Omit<CommunityBoardFindManyArgs, 'select' | 'include'> & {
      select?: CommunityBoardCountAggregateInputType | true
    }
  >

  export interface CommunityBoardDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityBoard that matches the filter.
     * @param {CommunityBoardFindUniqueArgs} args - Arguments to find a CommunityBoard
     * @example
     * // Get one CommunityBoard
     * const communityBoard = await prisma.communityBoard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityBoardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityBoardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityBoard'> extends True ? CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard | null >, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T> | null >>

    /**
     * Find the first CommunityBoard that matches the filter.
     * @param {CommunityBoardFindFirstArgs} args - Arguments to find a CommunityBoard
     * @example
     * // Get one CommunityBoard
     * const communityBoard = await prisma.communityBoard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityBoardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityBoardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityBoard'> extends True ? CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard | null >, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T> | null >>

    /**
     * Find zero or more CommunityBoards that matches the filter.
     * @param {CommunityBoardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityBoards
     * const communityBoards = await prisma.communityBoard.findMany()
     * 
     * // Get first 10 CommunityBoards
     * const communityBoards = await prisma.communityBoard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityBoardWithIdOnly = await prisma.communityBoard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityBoardFindManyArgs>(
      args?: SelectSubset<T, CommunityBoardFindManyArgs>
    ): CheckSelect<T, Promise<Array<CommunityBoard>>, Promise<Array<CommunityBoardGetPayload<T>>>>

    /**
     * Create a CommunityBoard.
     * @param {CommunityBoardCreateArgs} args - Arguments to create a CommunityBoard.
     * @example
     * // Create one CommunityBoard
     * const CommunityBoard = await prisma.communityBoard.create({
     *   data: {
     *     // ... data to create a CommunityBoard
     *   }
     * })
     * 
    **/
    create<T extends CommunityBoardCreateArgs>(
      args: SelectSubset<T, CommunityBoardCreateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>>

    /**
     * Delete a CommunityBoard.
     * @param {CommunityBoardDeleteArgs} args - Arguments to delete one CommunityBoard.
     * @example
     * // Delete one CommunityBoard
     * const CommunityBoard = await prisma.communityBoard.delete({
     *   where: {
     *     // ... filter to delete one CommunityBoard
     *   }
     * })
     * 
    **/
    delete<T extends CommunityBoardDeleteArgs>(
      args: SelectSubset<T, CommunityBoardDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>>

    /**
     * Update one CommunityBoard.
     * @param {CommunityBoardUpdateArgs} args - Arguments to update one CommunityBoard.
     * @example
     * // Update one CommunityBoard
     * const communityBoard = await prisma.communityBoard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityBoardUpdateArgs>(
      args: SelectSubset<T, CommunityBoardUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>>

    /**
     * Delete zero or more CommunityBoards.
     * @param {CommunityBoardDeleteManyArgs} args - Arguments to filter CommunityBoards to delete.
     * @example
     * // Delete a few CommunityBoards
     * const { count } = await prisma.communityBoard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityBoardDeleteManyArgs>(
      args?: SelectSubset<T, CommunityBoardDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CommunityBoards.
     * @param {CommunityBoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityBoards
     * const communityBoard = await prisma.communityBoard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityBoardUpdateManyArgs>(
      args: SelectSubset<T, CommunityBoardUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CommunityBoard.
     * @param {CommunityBoardUpsertArgs} args - Arguments to update or create a CommunityBoard.
     * @example
     * // Update or create a CommunityBoard
     * const communityBoard = await prisma.communityBoard.upsert({
     *   create: {
     *     // ... data to create a CommunityBoard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityBoard we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityBoardUpsertArgs>(
      args: SelectSubset<T, CommunityBoardUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>>

    /**
     * Count the number of CommunityBoards.
     * @param {CommunityBoardCountArgs} args - Arguments to filter CommunityBoards to count.
     * @example
     * // Count the number of CommunityBoards
     * const count = await prisma.communityBoard.count({
     *   where: {
     *     // ... the filter for the CommunityBoards we want to count
     *   }
     * })
    **/
    count<T extends CommunityBoardCountArgs>(
      args?: Subset<T, CommunityBoardCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityBoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityBoard.
     * @param {CommunityBoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityBoardAggregateArgs>(args: Subset<T, CommunityBoardAggregateArgs>): Promise<GetCommunityBoardAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityBoard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityBoardClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    communityBoardPins<T extends CommunityBoardPinFindManyArgs = {}>(args?: Subset<T, CommunityBoardPinFindManyArgs>): CheckSelect<T, Promise<Array<CommunityBoardPin>>, Promise<Array<CommunityBoardPinGetPayload<T>>>>;

    communityPosts<T extends CommunityPostFindManyArgs = {}>(args?: Subset<T, CommunityPostFindManyArgs>): CheckSelect<T, Promise<Array<CommunityPost>>, Promise<Array<CommunityPostGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityBoard findUnique
   */
  export type CommunityBoardFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * Throw an Error if a CommunityBoard can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoard to fetch.
    **/
    where: CommunityBoardWhereUniqueInput
  }


  /**
   * CommunityBoard findFirst
   */
  export type CommunityBoardFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * Throw an Error if a CommunityBoard can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoard to fetch.
    **/
    where?: CommunityBoardWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoards to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBoards.
    **/
    cursor?: CommunityBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoards.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CommunityBoards.
    **/
    distinct?: Enumerable<CommunityBoardScalarFieldEnum>
  }


  /**
   * CommunityBoard findMany
   */
  export type CommunityBoardFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * Filter, which CommunityBoards to fetch.
    **/
    where?: CommunityBoardWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoards to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityBoards.
    **/
    cursor?: CommunityBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoards.
    **/
    skip?: number
    distinct?: Enumerable<CommunityBoardScalarFieldEnum>
  }


  /**
   * CommunityBoard create
   */
  export type CommunityBoardCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * The data needed to create a CommunityBoard.
    **/
    data: XOR<CommunityBoardUncheckedCreateInput, CommunityBoardCreateInput>
  }


  /**
   * CommunityBoard update
   */
  export type CommunityBoardUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * The data needed to update a CommunityBoard.
    **/
    data: XOR<CommunityBoardUncheckedUpdateInput, CommunityBoardUpdateInput>
    /**
     * Choose, which CommunityBoard to update.
    **/
    where: CommunityBoardWhereUniqueInput
  }


  /**
   * CommunityBoard updateMany
   */
  export type CommunityBoardUpdateManyArgs = {
    data: XOR<CommunityBoardUncheckedUpdateManyInput, CommunityBoardUpdateManyMutationInput>
    where?: CommunityBoardWhereInput
  }


  /**
   * CommunityBoard upsert
   */
  export type CommunityBoardUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * The filter to search for the CommunityBoard to update in case it exists.
    **/
    where: CommunityBoardWhereUniqueInput
    /**
     * In case the CommunityBoard found by the `where` argument doesn't exist, create a new CommunityBoard with this data.
    **/
    create: XOR<CommunityBoardUncheckedCreateInput, CommunityBoardCreateInput>
    /**
     * In case the CommunityBoard was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityBoardUncheckedUpdateInput, CommunityBoardUpdateInput>
  }


  /**
   * CommunityBoard delete
   */
  export type CommunityBoardDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * Filter which CommunityBoard to delete.
    **/
    where: CommunityBoardWhereUniqueInput
  }


  /**
   * CommunityBoard deleteMany
   */
  export type CommunityBoardDeleteManyArgs = {
    where?: CommunityBoardWhereInput
  }


  /**
   * CommunityBoard without action
   */
  export type CommunityBoardArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
  }



  /**
   * Model CommunityBoardCandidate
   */


  export type AggregateCommunityBoardCandidate = {
    count: CommunityBoardCandidateCountAggregateOutputType | null
    avg: CommunityBoardCandidateAvgAggregateOutputType | null
    sum: CommunityBoardCandidateSumAggregateOutputType | null
    min: CommunityBoardCandidateMinAggregateOutputType | null
    max: CommunityBoardCandidateMaxAggregateOutputType | null
  }

  export type CommunityBoardCandidateAvgAggregateOutputType = {
    id: number
    createdBy: number
  }

  export type CommunityBoardCandidateSumAggregateOutputType = {
    id: number
    createdBy: number
  }

  export type CommunityBoardCandidateMinAggregateOutputType = {
    id: number
    name: string | null
    description: string | null
    createdBy: number
    createdAt: Date | null
  }

  export type CommunityBoardCandidateMaxAggregateOutputType = {
    id: number
    name: string | null
    description: string | null
    createdBy: number
    createdAt: Date | null
  }

  export type CommunityBoardCandidateCountAggregateOutputType = {
    id: number
    name: number | null
    description: number | null
    createdBy: number
    createdAt: number | null
    _all: number
  }


  export type CommunityBoardCandidateAvgAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type CommunityBoardCandidateSumAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type CommunityBoardCandidateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
  }

  export type CommunityBoardCandidateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
  }

  export type CommunityBoardCandidateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type CommunityBoardCandidateAggregateArgs = {
    /**
     * Filter which CommunityBoardCandidate to aggregate.
    **/
    where?: CommunityBoardCandidateWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoardCandidates to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityBoardCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidates from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidates.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityBoardCandidates
    **/
    count?: true | CommunityBoardCandidateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityBoardCandidateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityBoardCandidateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityBoardCandidateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityBoardCandidateMaxAggregateInputType
  }

  export type GetCommunityBoardCandidateAggregateType<T extends CommunityBoardCandidateAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityBoardCandidate]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityBoardCandidate[P]>
      : GetScalarType<T[P], AggregateCommunityBoardCandidate[P]>
  }



  export type CommunityBoardCandidateSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs
    communityBoardCandidateVotes?: boolean | CommunityBoardCandidateVoteFindManyArgs
  }

  export type CommunityBoardCandidateInclude = {
    user?: boolean | UserArgs
    communityBoardCandidateVotes?: boolean | CommunityBoardCandidateVoteFindManyArgs
  }

  export type CommunityBoardCandidateGetPayload<
    S extends boolean | null | undefined | CommunityBoardCandidateArgs,
    U = keyof S
      > = S extends true
        ? CommunityBoardCandidate
    : S extends undefined
    ? never
    : S extends CommunityBoardCandidateArgs | CommunityBoardCandidateFindManyArgs
    ?'include' extends U
    ? CommunityBoardCandidate  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'communityBoardCandidateVotes'
        ? Array < CommunityBoardCandidateVoteGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityBoardCandidate ?CommunityBoardCandidate [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'communityBoardCandidateVotes'
        ? Array < CommunityBoardCandidateVoteGetPayload<S['select'][P]>>  : never
  } 
    : CommunityBoardCandidate
  : CommunityBoardCandidate


  type CommunityBoardCandidateCountArgs = Merge<
    Omit<CommunityBoardCandidateFindManyArgs, 'select' | 'include'> & {
      select?: CommunityBoardCandidateCountAggregateInputType | true
    }
  >

  export interface CommunityBoardCandidateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityBoardCandidate that matches the filter.
     * @param {CommunityBoardCandidateFindUniqueArgs} args - Arguments to find a CommunityBoardCandidate
     * @example
     * // Get one CommunityBoardCandidate
     * const communityBoardCandidate = await prisma.communityBoardCandidate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityBoardCandidateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityBoardCandidateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityBoardCandidate'> extends True ? CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate | null >, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T> | null >>

    /**
     * Find the first CommunityBoardCandidate that matches the filter.
     * @param {CommunityBoardCandidateFindFirstArgs} args - Arguments to find a CommunityBoardCandidate
     * @example
     * // Get one CommunityBoardCandidate
     * const communityBoardCandidate = await prisma.communityBoardCandidate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityBoardCandidateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityBoardCandidateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityBoardCandidate'> extends True ? CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate | null >, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T> | null >>

    /**
     * Find zero or more CommunityBoardCandidates that matches the filter.
     * @param {CommunityBoardCandidateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityBoardCandidates
     * const communityBoardCandidates = await prisma.communityBoardCandidate.findMany()
     * 
     * // Get first 10 CommunityBoardCandidates
     * const communityBoardCandidates = await prisma.communityBoardCandidate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityBoardCandidateWithIdOnly = await prisma.communityBoardCandidate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityBoardCandidateFindManyArgs>(
      args?: SelectSubset<T, CommunityBoardCandidateFindManyArgs>
    ): CheckSelect<T, Promise<Array<CommunityBoardCandidate>>, Promise<Array<CommunityBoardCandidateGetPayload<T>>>>

    /**
     * Create a CommunityBoardCandidate.
     * @param {CommunityBoardCandidateCreateArgs} args - Arguments to create a CommunityBoardCandidate.
     * @example
     * // Create one CommunityBoardCandidate
     * const CommunityBoardCandidate = await prisma.communityBoardCandidate.create({
     *   data: {
     *     // ... data to create a CommunityBoardCandidate
     *   }
     * })
     * 
    **/
    create<T extends CommunityBoardCandidateCreateArgs>(
      args: SelectSubset<T, CommunityBoardCandidateCreateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>>

    /**
     * Delete a CommunityBoardCandidate.
     * @param {CommunityBoardCandidateDeleteArgs} args - Arguments to delete one CommunityBoardCandidate.
     * @example
     * // Delete one CommunityBoardCandidate
     * const CommunityBoardCandidate = await prisma.communityBoardCandidate.delete({
     *   where: {
     *     // ... filter to delete one CommunityBoardCandidate
     *   }
     * })
     * 
    **/
    delete<T extends CommunityBoardCandidateDeleteArgs>(
      args: SelectSubset<T, CommunityBoardCandidateDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>>

    /**
     * Update one CommunityBoardCandidate.
     * @param {CommunityBoardCandidateUpdateArgs} args - Arguments to update one CommunityBoardCandidate.
     * @example
     * // Update one CommunityBoardCandidate
     * const communityBoardCandidate = await prisma.communityBoardCandidate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityBoardCandidateUpdateArgs>(
      args: SelectSubset<T, CommunityBoardCandidateUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>>

    /**
     * Delete zero or more CommunityBoardCandidates.
     * @param {CommunityBoardCandidateDeleteManyArgs} args - Arguments to filter CommunityBoardCandidates to delete.
     * @example
     * // Delete a few CommunityBoardCandidates
     * const { count } = await prisma.communityBoardCandidate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityBoardCandidateDeleteManyArgs>(
      args?: SelectSubset<T, CommunityBoardCandidateDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CommunityBoardCandidates.
     * @param {CommunityBoardCandidateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityBoardCandidates
     * const communityBoardCandidate = await prisma.communityBoardCandidate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityBoardCandidateUpdateManyArgs>(
      args: SelectSubset<T, CommunityBoardCandidateUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CommunityBoardCandidate.
     * @param {CommunityBoardCandidateUpsertArgs} args - Arguments to update or create a CommunityBoardCandidate.
     * @example
     * // Update or create a CommunityBoardCandidate
     * const communityBoardCandidate = await prisma.communityBoardCandidate.upsert({
     *   create: {
     *     // ... data to create a CommunityBoardCandidate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityBoardCandidate we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityBoardCandidateUpsertArgs>(
      args: SelectSubset<T, CommunityBoardCandidateUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>>

    /**
     * Count the number of CommunityBoardCandidates.
     * @param {CommunityBoardCandidateCountArgs} args - Arguments to filter CommunityBoardCandidates to count.
     * @example
     * // Count the number of CommunityBoardCandidates
     * const count = await prisma.communityBoardCandidate.count({
     *   where: {
     *     // ... the filter for the CommunityBoardCandidates we want to count
     *   }
     * })
    **/
    count<T extends CommunityBoardCandidateCountArgs>(
      args?: Subset<T, CommunityBoardCandidateCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityBoardCandidateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityBoardCandidate.
     * @param {CommunityBoardCandidateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityBoardCandidateAggregateArgs>(args: Subset<T, CommunityBoardCandidateAggregateArgs>): Promise<GetCommunityBoardCandidateAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityBoardCandidate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityBoardCandidateClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    communityBoardCandidateVotes<T extends CommunityBoardCandidateVoteFindManyArgs = {}>(args?: Subset<T, CommunityBoardCandidateVoteFindManyArgs>): CheckSelect<T, Promise<Array<CommunityBoardCandidateVote>>, Promise<Array<CommunityBoardCandidateVoteGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityBoardCandidate findUnique
   */
  export type CommunityBoardCandidateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * Throw an Error if a CommunityBoardCandidate can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardCandidate to fetch.
    **/
    where: CommunityBoardCandidateWhereUniqueInput
  }


  /**
   * CommunityBoardCandidate findFirst
   */
  export type CommunityBoardCandidateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * Throw an Error if a CommunityBoardCandidate can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardCandidate to fetch.
    **/
    where?: CommunityBoardCandidateWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoardCandidates to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBoardCandidates.
    **/
    cursor?: CommunityBoardCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidates from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidates.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CommunityBoardCandidates.
    **/
    distinct?: Enumerable<CommunityBoardCandidateScalarFieldEnum>
  }


  /**
   * CommunityBoardCandidate findMany
   */
  export type CommunityBoardCandidateFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * Filter, which CommunityBoardCandidates to fetch.
    **/
    where?: CommunityBoardCandidateWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoardCandidates to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityBoardCandidates.
    **/
    cursor?: CommunityBoardCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidates from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidates.
    **/
    skip?: number
    distinct?: Enumerable<CommunityBoardCandidateScalarFieldEnum>
  }


  /**
   * CommunityBoardCandidate create
   */
  export type CommunityBoardCandidateCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * The data needed to create a CommunityBoardCandidate.
    **/
    data: XOR<CommunityBoardCandidateUncheckedCreateInput, CommunityBoardCandidateCreateInput>
  }


  /**
   * CommunityBoardCandidate update
   */
  export type CommunityBoardCandidateUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * The data needed to update a CommunityBoardCandidate.
    **/
    data: XOR<CommunityBoardCandidateUncheckedUpdateInput, CommunityBoardCandidateUpdateInput>
    /**
     * Choose, which CommunityBoardCandidate to update.
    **/
    where: CommunityBoardCandidateWhereUniqueInput
  }


  /**
   * CommunityBoardCandidate updateMany
   */
  export type CommunityBoardCandidateUpdateManyArgs = {
    data: XOR<CommunityBoardCandidateUncheckedUpdateManyInput, CommunityBoardCandidateUpdateManyMutationInput>
    where?: CommunityBoardCandidateWhereInput
  }


  /**
   * CommunityBoardCandidate upsert
   */
  export type CommunityBoardCandidateUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * The filter to search for the CommunityBoardCandidate to update in case it exists.
    **/
    where: CommunityBoardCandidateWhereUniqueInput
    /**
     * In case the CommunityBoardCandidate found by the `where` argument doesn't exist, create a new CommunityBoardCandidate with this data.
    **/
    create: XOR<CommunityBoardCandidateUncheckedCreateInput, CommunityBoardCandidateCreateInput>
    /**
     * In case the CommunityBoardCandidate was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityBoardCandidateUncheckedUpdateInput, CommunityBoardCandidateUpdateInput>
  }


  /**
   * CommunityBoardCandidate delete
   */
  export type CommunityBoardCandidateDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * Filter which CommunityBoardCandidate to delete.
    **/
    where: CommunityBoardCandidateWhereUniqueInput
  }


  /**
   * CommunityBoardCandidate deleteMany
   */
  export type CommunityBoardCandidateDeleteManyArgs = {
    where?: CommunityBoardCandidateWhereInput
  }


  /**
   * CommunityBoardCandidate without action
   */
  export type CommunityBoardCandidateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
  }



  /**
   * Model CommunityBoardCandidateVote
   */


  export type AggregateCommunityBoardCandidateVote = {
    count: CommunityBoardCandidateVoteCountAggregateOutputType | null
    avg: CommunityBoardCandidateVoteAvgAggregateOutputType | null
    sum: CommunityBoardCandidateVoteSumAggregateOutputType | null
    min: CommunityBoardCandidateVoteMinAggregateOutputType | null
    max: CommunityBoardCandidateVoteMaxAggregateOutputType | null
  }

  export type CommunityBoardCandidateVoteAvgAggregateOutputType = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardCandidateVoteSumAggregateOutputType = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardCandidateVoteMinAggregateOutputType = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardCandidateVoteMaxAggregateOutputType = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardCandidateVoteCountAggregateOutputType = {
    boardCandidateId: number
    userId: number
    _all: number
  }


  export type CommunityBoardCandidateVoteAvgAggregateInputType = {
    boardCandidateId?: true
    userId?: true
  }

  export type CommunityBoardCandidateVoteSumAggregateInputType = {
    boardCandidateId?: true
    userId?: true
  }

  export type CommunityBoardCandidateVoteMinAggregateInputType = {
    boardCandidateId?: true
    userId?: true
  }

  export type CommunityBoardCandidateVoteMaxAggregateInputType = {
    boardCandidateId?: true
    userId?: true
  }

  export type CommunityBoardCandidateVoteCountAggregateInputType = {
    boardCandidateId?: true
    userId?: true
    _all?: true
  }

  export type CommunityBoardCandidateVoteAggregateArgs = {
    /**
     * Filter which CommunityBoardCandidateVote to aggregate.
    **/
    where?: CommunityBoardCandidateVoteWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoardCandidateVotes to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateVoteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityBoardCandidateVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidateVotes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidateVotes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityBoardCandidateVotes
    **/
    count?: true | CommunityBoardCandidateVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityBoardCandidateVoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityBoardCandidateVoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityBoardCandidateVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityBoardCandidateVoteMaxAggregateInputType
  }

  export type GetCommunityBoardCandidateVoteAggregateType<T extends CommunityBoardCandidateVoteAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityBoardCandidateVote]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityBoardCandidateVote[P]>
      : GetScalarType<T[P], AggregateCommunityBoardCandidateVote[P]>
  }



  export type CommunityBoardCandidateVoteSelect = {
    boardCandidateId?: boolean
    userId?: boolean
    communityBoardCandidate?: boolean | CommunityBoardCandidateArgs
    user?: boolean | UserArgs
  }

  export type CommunityBoardCandidateVoteInclude = {
    communityBoardCandidate?: boolean | CommunityBoardCandidateArgs
    user?: boolean | UserArgs
  }

  export type CommunityBoardCandidateVoteGetPayload<
    S extends boolean | null | undefined | CommunityBoardCandidateVoteArgs,
    U = keyof S
      > = S extends true
        ? CommunityBoardCandidateVote
    : S extends undefined
    ? never
    : S extends CommunityBoardCandidateVoteArgs | CommunityBoardCandidateVoteFindManyArgs
    ?'include' extends U
    ? CommunityBoardCandidateVote  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityBoardCandidate'
        ? CommunityBoardCandidateGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityBoardCandidateVote ?CommunityBoardCandidateVote [P]
  : 
          P extends 'communityBoardCandidate'
        ? CommunityBoardCandidateGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : CommunityBoardCandidateVote
  : CommunityBoardCandidateVote


  type CommunityBoardCandidateVoteCountArgs = Merge<
    Omit<CommunityBoardCandidateVoteFindManyArgs, 'select' | 'include'> & {
      select?: CommunityBoardCandidateVoteCountAggregateInputType | true
    }
  >

  export interface CommunityBoardCandidateVoteDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityBoardCandidateVote that matches the filter.
     * @param {CommunityBoardCandidateVoteFindUniqueArgs} args - Arguments to find a CommunityBoardCandidateVote
     * @example
     * // Get one CommunityBoardCandidateVote
     * const communityBoardCandidateVote = await prisma.communityBoardCandidateVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityBoardCandidateVoteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityBoardCandidateVoteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityBoardCandidateVote'> extends True ? CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote | null >, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T> | null >>

    /**
     * Find the first CommunityBoardCandidateVote that matches the filter.
     * @param {CommunityBoardCandidateVoteFindFirstArgs} args - Arguments to find a CommunityBoardCandidateVote
     * @example
     * // Get one CommunityBoardCandidateVote
     * const communityBoardCandidateVote = await prisma.communityBoardCandidateVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityBoardCandidateVoteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityBoardCandidateVoteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityBoardCandidateVote'> extends True ? CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote | null >, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T> | null >>

    /**
     * Find zero or more CommunityBoardCandidateVotes that matches the filter.
     * @param {CommunityBoardCandidateVoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityBoardCandidateVotes
     * const communityBoardCandidateVotes = await prisma.communityBoardCandidateVote.findMany()
     * 
     * // Get first 10 CommunityBoardCandidateVotes
     * const communityBoardCandidateVotes = await prisma.communityBoardCandidateVote.findMany({ take: 10 })
     * 
     * // Only select the `boardCandidateId`
     * const communityBoardCandidateVoteWithBoardCandidateIdOnly = await prisma.communityBoardCandidateVote.findMany({ select: { boardCandidateId: true } })
     * 
    **/
    findMany<T extends CommunityBoardCandidateVoteFindManyArgs>(
      args?: SelectSubset<T, CommunityBoardCandidateVoteFindManyArgs>
    ): CheckSelect<T, Promise<Array<CommunityBoardCandidateVote>>, Promise<Array<CommunityBoardCandidateVoteGetPayload<T>>>>

    /**
     * Create a CommunityBoardCandidateVote.
     * @param {CommunityBoardCandidateVoteCreateArgs} args - Arguments to create a CommunityBoardCandidateVote.
     * @example
     * // Create one CommunityBoardCandidateVote
     * const CommunityBoardCandidateVote = await prisma.communityBoardCandidateVote.create({
     *   data: {
     *     // ... data to create a CommunityBoardCandidateVote
     *   }
     * })
     * 
    **/
    create<T extends CommunityBoardCandidateVoteCreateArgs>(
      args: SelectSubset<T, CommunityBoardCandidateVoteCreateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>>

    /**
     * Delete a CommunityBoardCandidateVote.
     * @param {CommunityBoardCandidateVoteDeleteArgs} args - Arguments to delete one CommunityBoardCandidateVote.
     * @example
     * // Delete one CommunityBoardCandidateVote
     * const CommunityBoardCandidateVote = await prisma.communityBoardCandidateVote.delete({
     *   where: {
     *     // ... filter to delete one CommunityBoardCandidateVote
     *   }
     * })
     * 
    **/
    delete<T extends CommunityBoardCandidateVoteDeleteArgs>(
      args: SelectSubset<T, CommunityBoardCandidateVoteDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>>

    /**
     * Update one CommunityBoardCandidateVote.
     * @param {CommunityBoardCandidateVoteUpdateArgs} args - Arguments to update one CommunityBoardCandidateVote.
     * @example
     * // Update one CommunityBoardCandidateVote
     * const communityBoardCandidateVote = await prisma.communityBoardCandidateVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityBoardCandidateVoteUpdateArgs>(
      args: SelectSubset<T, CommunityBoardCandidateVoteUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>>

    /**
     * Delete zero or more CommunityBoardCandidateVotes.
     * @param {CommunityBoardCandidateVoteDeleteManyArgs} args - Arguments to filter CommunityBoardCandidateVotes to delete.
     * @example
     * // Delete a few CommunityBoardCandidateVotes
     * const { count } = await prisma.communityBoardCandidateVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityBoardCandidateVoteDeleteManyArgs>(
      args?: SelectSubset<T, CommunityBoardCandidateVoteDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CommunityBoardCandidateVotes.
     * @param {CommunityBoardCandidateVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityBoardCandidateVotes
     * const communityBoardCandidateVote = await prisma.communityBoardCandidateVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityBoardCandidateVoteUpdateManyArgs>(
      args: SelectSubset<T, CommunityBoardCandidateVoteUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CommunityBoardCandidateVote.
     * @param {CommunityBoardCandidateVoteUpsertArgs} args - Arguments to update or create a CommunityBoardCandidateVote.
     * @example
     * // Update or create a CommunityBoardCandidateVote
     * const communityBoardCandidateVote = await prisma.communityBoardCandidateVote.upsert({
     *   create: {
     *     // ... data to create a CommunityBoardCandidateVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityBoardCandidateVote we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityBoardCandidateVoteUpsertArgs>(
      args: SelectSubset<T, CommunityBoardCandidateVoteUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>>

    /**
     * Count the number of CommunityBoardCandidateVotes.
     * @param {CommunityBoardCandidateVoteCountArgs} args - Arguments to filter CommunityBoardCandidateVotes to count.
     * @example
     * // Count the number of CommunityBoardCandidateVotes
     * const count = await prisma.communityBoardCandidateVote.count({
     *   where: {
     *     // ... the filter for the CommunityBoardCandidateVotes we want to count
     *   }
     * })
    **/
    count<T extends CommunityBoardCandidateVoteCountArgs>(
      args?: Subset<T, CommunityBoardCandidateVoteCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityBoardCandidateVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityBoardCandidateVote.
     * @param {CommunityBoardCandidateVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityBoardCandidateVoteAggregateArgs>(args: Subset<T, CommunityBoardCandidateVoteAggregateArgs>): Promise<GetCommunityBoardCandidateVoteAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityBoardCandidateVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityBoardCandidateVoteClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityBoardCandidate<T extends CommunityBoardCandidateArgs = {}>(args?: Subset<T, CommunityBoardCandidateArgs>): CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate | null >, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityBoardCandidateVote findUnique
   */
  export type CommunityBoardCandidateVoteFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * Throw an Error if a CommunityBoardCandidateVote can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardCandidateVote to fetch.
    **/
    where: CommunityBoardCandidateVoteWhereUniqueInput
  }


  /**
   * CommunityBoardCandidateVote findFirst
   */
  export type CommunityBoardCandidateVoteFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * Throw an Error if a CommunityBoardCandidateVote can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardCandidateVote to fetch.
    **/
    where?: CommunityBoardCandidateVoteWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoardCandidateVotes to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateVoteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBoardCandidateVotes.
    **/
    cursor?: CommunityBoardCandidateVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidateVotes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidateVotes.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CommunityBoardCandidateVotes.
    **/
    distinct?: Enumerable<CommunityBoardCandidateVoteScalarFieldEnum>
  }


  /**
   * CommunityBoardCandidateVote findMany
   */
  export type CommunityBoardCandidateVoteFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * Filter, which CommunityBoardCandidateVotes to fetch.
    **/
    where?: CommunityBoardCandidateVoteWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoardCandidateVotes to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateVoteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityBoardCandidateVotes.
    **/
    cursor?: CommunityBoardCandidateVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidateVotes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidateVotes.
    **/
    skip?: number
    distinct?: Enumerable<CommunityBoardCandidateVoteScalarFieldEnum>
  }


  /**
   * CommunityBoardCandidateVote create
   */
  export type CommunityBoardCandidateVoteCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * The data needed to create a CommunityBoardCandidateVote.
    **/
    data: XOR<CommunityBoardCandidateVoteUncheckedCreateInput, CommunityBoardCandidateVoteCreateInput>
  }


  /**
   * CommunityBoardCandidateVote update
   */
  export type CommunityBoardCandidateVoteUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * The data needed to update a CommunityBoardCandidateVote.
    **/
    data: XOR<CommunityBoardCandidateVoteUncheckedUpdateInput, CommunityBoardCandidateVoteUpdateInput>
    /**
     * Choose, which CommunityBoardCandidateVote to update.
    **/
    where: CommunityBoardCandidateVoteWhereUniqueInput
  }


  /**
   * CommunityBoardCandidateVote updateMany
   */
  export type CommunityBoardCandidateVoteUpdateManyArgs = {
    data: XOR<CommunityBoardCandidateVoteUncheckedUpdateManyInput, CommunityBoardCandidateVoteUpdateManyMutationInput>
    where?: CommunityBoardCandidateVoteWhereInput
  }


  /**
   * CommunityBoardCandidateVote upsert
   */
  export type CommunityBoardCandidateVoteUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * The filter to search for the CommunityBoardCandidateVote to update in case it exists.
    **/
    where: CommunityBoardCandidateVoteWhereUniqueInput
    /**
     * In case the CommunityBoardCandidateVote found by the `where` argument doesn't exist, create a new CommunityBoardCandidateVote with this data.
    **/
    create: XOR<CommunityBoardCandidateVoteUncheckedCreateInput, CommunityBoardCandidateVoteCreateInput>
    /**
     * In case the CommunityBoardCandidateVote was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityBoardCandidateVoteUncheckedUpdateInput, CommunityBoardCandidateVoteUpdateInput>
  }


  /**
   * CommunityBoardCandidateVote delete
   */
  export type CommunityBoardCandidateVoteDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * Filter which CommunityBoardCandidateVote to delete.
    **/
    where: CommunityBoardCandidateVoteWhereUniqueInput
  }


  /**
   * CommunityBoardCandidateVote deleteMany
   */
  export type CommunityBoardCandidateVoteDeleteManyArgs = {
    where?: CommunityBoardCandidateVoteWhereInput
  }


  /**
   * CommunityBoardCandidateVote without action
   */
  export type CommunityBoardCandidateVoteArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
  }



  /**
   * Model CommunityBoardPin
   */


  export type AggregateCommunityBoardPin = {
    count: CommunityBoardPinCountAggregateOutputType | null
    avg: CommunityBoardPinAvgAggregateOutputType | null
    sum: CommunityBoardPinSumAggregateOutputType | null
    min: CommunityBoardPinMinAggregateOutputType | null
    max: CommunityBoardPinMaxAggregateOutputType | null
  }

  export type CommunityBoardPinAvgAggregateOutputType = {
    userId: number
    boardId: number
  }

  export type CommunityBoardPinSumAggregateOutputType = {
    userId: number
    boardId: number
  }

  export type CommunityBoardPinMinAggregateOutputType = {
    userId: number
    boardId: number
  }

  export type CommunityBoardPinMaxAggregateOutputType = {
    userId: number
    boardId: number
  }

  export type CommunityBoardPinCountAggregateOutputType = {
    userId: number
    boardId: number
    _all: number
  }


  export type CommunityBoardPinAvgAggregateInputType = {
    userId?: true
    boardId?: true
  }

  export type CommunityBoardPinSumAggregateInputType = {
    userId?: true
    boardId?: true
  }

  export type CommunityBoardPinMinAggregateInputType = {
    userId?: true
    boardId?: true
  }

  export type CommunityBoardPinMaxAggregateInputType = {
    userId?: true
    boardId?: true
  }

  export type CommunityBoardPinCountAggregateInputType = {
    userId?: true
    boardId?: true
    _all?: true
  }

  export type CommunityBoardPinAggregateArgs = {
    /**
     * Filter which CommunityBoardPin to aggregate.
    **/
    where?: CommunityBoardPinWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoardPins to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardPinOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityBoardPinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardPins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardPins.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityBoardPins
    **/
    count?: true | CommunityBoardPinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityBoardPinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityBoardPinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityBoardPinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityBoardPinMaxAggregateInputType
  }

  export type GetCommunityBoardPinAggregateType<T extends CommunityBoardPinAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityBoardPin]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityBoardPin[P]>
      : GetScalarType<T[P], AggregateCommunityBoardPin[P]>
  }



  export type CommunityBoardPinSelect = {
    userId?: boolean
    boardId?: boolean
    communityBoard?: boolean | CommunityBoardArgs
    user?: boolean | UserArgs
  }

  export type CommunityBoardPinInclude = {
    communityBoard?: boolean | CommunityBoardArgs
    user?: boolean | UserArgs
  }

  export type CommunityBoardPinGetPayload<
    S extends boolean | null | undefined | CommunityBoardPinArgs,
    U = keyof S
      > = S extends true
        ? CommunityBoardPin
    : S extends undefined
    ? never
    : S extends CommunityBoardPinArgs | CommunityBoardPinFindManyArgs
    ?'include' extends U
    ? CommunityBoardPin  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityBoard'
        ? CommunityBoardGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityBoardPin ?CommunityBoardPin [P]
  : 
          P extends 'communityBoard'
        ? CommunityBoardGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : CommunityBoardPin
  : CommunityBoardPin


  type CommunityBoardPinCountArgs = Merge<
    Omit<CommunityBoardPinFindManyArgs, 'select' | 'include'> & {
      select?: CommunityBoardPinCountAggregateInputType | true
    }
  >

  export interface CommunityBoardPinDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityBoardPin that matches the filter.
     * @param {CommunityBoardPinFindUniqueArgs} args - Arguments to find a CommunityBoardPin
     * @example
     * // Get one CommunityBoardPin
     * const communityBoardPin = await prisma.communityBoardPin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityBoardPinFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityBoardPinFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityBoardPin'> extends True ? CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin | null >, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T> | null >>

    /**
     * Find the first CommunityBoardPin that matches the filter.
     * @param {CommunityBoardPinFindFirstArgs} args - Arguments to find a CommunityBoardPin
     * @example
     * // Get one CommunityBoardPin
     * const communityBoardPin = await prisma.communityBoardPin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityBoardPinFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityBoardPinFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityBoardPin'> extends True ? CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin | null >, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T> | null >>

    /**
     * Find zero or more CommunityBoardPins that matches the filter.
     * @param {CommunityBoardPinFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityBoardPins
     * const communityBoardPins = await prisma.communityBoardPin.findMany()
     * 
     * // Get first 10 CommunityBoardPins
     * const communityBoardPins = await prisma.communityBoardPin.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const communityBoardPinWithUserIdOnly = await prisma.communityBoardPin.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CommunityBoardPinFindManyArgs>(
      args?: SelectSubset<T, CommunityBoardPinFindManyArgs>
    ): CheckSelect<T, Promise<Array<CommunityBoardPin>>, Promise<Array<CommunityBoardPinGetPayload<T>>>>

    /**
     * Create a CommunityBoardPin.
     * @param {CommunityBoardPinCreateArgs} args - Arguments to create a CommunityBoardPin.
     * @example
     * // Create one CommunityBoardPin
     * const CommunityBoardPin = await prisma.communityBoardPin.create({
     *   data: {
     *     // ... data to create a CommunityBoardPin
     *   }
     * })
     * 
    **/
    create<T extends CommunityBoardPinCreateArgs>(
      args: SelectSubset<T, CommunityBoardPinCreateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>>

    /**
     * Delete a CommunityBoardPin.
     * @param {CommunityBoardPinDeleteArgs} args - Arguments to delete one CommunityBoardPin.
     * @example
     * // Delete one CommunityBoardPin
     * const CommunityBoardPin = await prisma.communityBoardPin.delete({
     *   where: {
     *     // ... filter to delete one CommunityBoardPin
     *   }
     * })
     * 
    **/
    delete<T extends CommunityBoardPinDeleteArgs>(
      args: SelectSubset<T, CommunityBoardPinDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>>

    /**
     * Update one CommunityBoardPin.
     * @param {CommunityBoardPinUpdateArgs} args - Arguments to update one CommunityBoardPin.
     * @example
     * // Update one CommunityBoardPin
     * const communityBoardPin = await prisma.communityBoardPin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityBoardPinUpdateArgs>(
      args: SelectSubset<T, CommunityBoardPinUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>>

    /**
     * Delete zero or more CommunityBoardPins.
     * @param {CommunityBoardPinDeleteManyArgs} args - Arguments to filter CommunityBoardPins to delete.
     * @example
     * // Delete a few CommunityBoardPins
     * const { count } = await prisma.communityBoardPin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityBoardPinDeleteManyArgs>(
      args?: SelectSubset<T, CommunityBoardPinDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CommunityBoardPins.
     * @param {CommunityBoardPinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityBoardPins
     * const communityBoardPin = await prisma.communityBoardPin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityBoardPinUpdateManyArgs>(
      args: SelectSubset<T, CommunityBoardPinUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CommunityBoardPin.
     * @param {CommunityBoardPinUpsertArgs} args - Arguments to update or create a CommunityBoardPin.
     * @example
     * // Update or create a CommunityBoardPin
     * const communityBoardPin = await prisma.communityBoardPin.upsert({
     *   create: {
     *     // ... data to create a CommunityBoardPin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityBoardPin we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityBoardPinUpsertArgs>(
      args: SelectSubset<T, CommunityBoardPinUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>>

    /**
     * Count the number of CommunityBoardPins.
     * @param {CommunityBoardPinCountArgs} args - Arguments to filter CommunityBoardPins to count.
     * @example
     * // Count the number of CommunityBoardPins
     * const count = await prisma.communityBoardPin.count({
     *   where: {
     *     // ... the filter for the CommunityBoardPins we want to count
     *   }
     * })
    **/
    count<T extends CommunityBoardPinCountArgs>(
      args?: Subset<T, CommunityBoardPinCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityBoardPinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityBoardPin.
     * @param {CommunityBoardPinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityBoardPinAggregateArgs>(args: Subset<T, CommunityBoardPinAggregateArgs>): Promise<GetCommunityBoardPinAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityBoardPin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityBoardPinClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityBoard<T extends CommunityBoardArgs = {}>(args?: Subset<T, CommunityBoardArgs>): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard | null >, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityBoardPin findUnique
   */
  export type CommunityBoardPinFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * Throw an Error if a CommunityBoardPin can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardPin to fetch.
    **/
    where: CommunityBoardPinWhereUniqueInput
  }


  /**
   * CommunityBoardPin findFirst
   */
  export type CommunityBoardPinFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * Throw an Error if a CommunityBoardPin can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardPin to fetch.
    **/
    where?: CommunityBoardPinWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoardPins to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardPinOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBoardPins.
    **/
    cursor?: CommunityBoardPinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardPins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardPins.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CommunityBoardPins.
    **/
    distinct?: Enumerable<CommunityBoardPinScalarFieldEnum>
  }


  /**
   * CommunityBoardPin findMany
   */
  export type CommunityBoardPinFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * Filter, which CommunityBoardPins to fetch.
    **/
    where?: CommunityBoardPinWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityBoardPins to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardPinOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityBoardPins.
    **/
    cursor?: CommunityBoardPinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardPins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardPins.
    **/
    skip?: number
    distinct?: Enumerable<CommunityBoardPinScalarFieldEnum>
  }


  /**
   * CommunityBoardPin create
   */
  export type CommunityBoardPinCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * The data needed to create a CommunityBoardPin.
    **/
    data: XOR<CommunityBoardPinUncheckedCreateInput, CommunityBoardPinCreateInput>
  }


  /**
   * CommunityBoardPin update
   */
  export type CommunityBoardPinUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * The data needed to update a CommunityBoardPin.
    **/
    data: XOR<CommunityBoardPinUncheckedUpdateInput, CommunityBoardPinUpdateInput>
    /**
     * Choose, which CommunityBoardPin to update.
    **/
    where: CommunityBoardPinWhereUniqueInput
  }


  /**
   * CommunityBoardPin updateMany
   */
  export type CommunityBoardPinUpdateManyArgs = {
    data: XOR<CommunityBoardPinUncheckedUpdateManyInput, CommunityBoardPinUpdateManyMutationInput>
    where?: CommunityBoardPinWhereInput
  }


  /**
   * CommunityBoardPin upsert
   */
  export type CommunityBoardPinUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * The filter to search for the CommunityBoardPin to update in case it exists.
    **/
    where: CommunityBoardPinWhereUniqueInput
    /**
     * In case the CommunityBoardPin found by the `where` argument doesn't exist, create a new CommunityBoardPin with this data.
    **/
    create: XOR<CommunityBoardPinUncheckedCreateInput, CommunityBoardPinCreateInput>
    /**
     * In case the CommunityBoardPin was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityBoardPinUncheckedUpdateInput, CommunityBoardPinUpdateInput>
  }


  /**
   * CommunityBoardPin delete
   */
  export type CommunityBoardPinDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * Filter which CommunityBoardPin to delete.
    **/
    where: CommunityBoardPinWhereUniqueInput
  }


  /**
   * CommunityBoardPin deleteMany
   */
  export type CommunityBoardPinDeleteManyArgs = {
    where?: CommunityBoardPinWhereInput
  }


  /**
   * CommunityBoardPin without action
   */
  export type CommunityBoardPinArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
  }



  /**
   * Model CommunityComment
   */


  export type AggregateCommunityComment = {
    count: CommunityCommentCountAggregateOutputType | null
    avg: CommunityCommentAvgAggregateOutputType | null
    sum: CommunityCommentSumAggregateOutputType | null
    min: CommunityCommentMinAggregateOutputType | null
    max: CommunityCommentMaxAggregateOutputType | null
  }

  export type CommunityCommentAvgAggregateOutputType = {
    id: number
    postId: number
    userId: number
  }

  export type CommunityCommentSumAggregateOutputType = {
    id: number
    postId: number
    userId: number
  }

  export type CommunityCommentMinAggregateOutputType = {
    id: number
    postId: number
    userId: number
    randomNickname: string | null
    body: string | null
    commentedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunityCommentMaxAggregateOutputType = {
    id: number
    postId: number
    userId: number
    randomNickname: string | null
    body: string | null
    commentedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunityCommentCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    randomNickname: number | null
    body: number | null
    commentedAt: number | null
    isDeleted: number | null
    _all: number
  }


  export type CommunityCommentAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type CommunityCommentSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type CommunityCommentMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    randomNickname?: true
    body?: true
    commentedAt?: true
    isDeleted?: true
  }

  export type CommunityCommentMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    randomNickname?: true
    body?: true
    commentedAt?: true
    isDeleted?: true
  }

  export type CommunityCommentCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    randomNickname?: true
    body?: true
    commentedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type CommunityCommentAggregateArgs = {
    /**
     * Filter which CommunityComment to aggregate.
    **/
    where?: CommunityCommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityComments to fetch.
    **/
    orderBy?: Enumerable<CommunityCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityComments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityComments
    **/
    count?: true | CommunityCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityCommentMaxAggregateInputType
  }

  export type GetCommunityCommentAggregateType<T extends CommunityCommentAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityComment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityComment[P]>
      : GetScalarType<T[P], AggregateCommunityComment[P]>
  }



  export type CommunityCommentSelect = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    randomNickname?: boolean
    body?: boolean
    commentedAt?: boolean
    isDeleted?: boolean
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    reportComments?: boolean | ReportCommentFindManyArgs
  }

  export type CommunityCommentInclude = {
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    reportComments?: boolean | ReportCommentFindManyArgs
  }

  export type CommunityCommentGetPayload<
    S extends boolean | null | undefined | CommunityCommentArgs,
    U = keyof S
      > = S extends true
        ? CommunityComment
    : S extends undefined
    ? never
    : S extends CommunityCommentArgs | CommunityCommentFindManyArgs
    ?'include' extends U
    ? CommunityComment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['include'][P]>>  :
        P extends 'reportComments'
        ? Array < ReportCommentGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityComment ?CommunityComment [P]
  : 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['select'][P]>>  :
        P extends 'reportComments'
        ? Array < ReportCommentGetPayload<S['select'][P]>>  : never
  } 
    : CommunityComment
  : CommunityComment


  type CommunityCommentCountArgs = Merge<
    Omit<CommunityCommentFindManyArgs, 'select' | 'include'> & {
      select?: CommunityCommentCountAggregateInputType | true
    }
  >

  export interface CommunityCommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityComment that matches the filter.
     * @param {CommunityCommentFindUniqueArgs} args - Arguments to find a CommunityComment
     * @example
     * // Get one CommunityComment
     * const communityComment = await prisma.communityComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityComment'> extends True ? CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>> : CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment | null >, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T> | null >>

    /**
     * Find the first CommunityComment that matches the filter.
     * @param {CommunityCommentFindFirstArgs} args - Arguments to find a CommunityComment
     * @example
     * // Get one CommunityComment
     * const communityComment = await prisma.communityComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityComment'> extends True ? CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>> : CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment | null >, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T> | null >>

    /**
     * Find zero or more CommunityComments that matches the filter.
     * @param {CommunityCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityComments
     * const communityComments = await prisma.communityComment.findMany()
     * 
     * // Get first 10 CommunityComments
     * const communityComments = await prisma.communityComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityCommentWithIdOnly = await prisma.communityComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityCommentFindManyArgs>(
      args?: SelectSubset<T, CommunityCommentFindManyArgs>
    ): CheckSelect<T, Promise<Array<CommunityComment>>, Promise<Array<CommunityCommentGetPayload<T>>>>

    /**
     * Create a CommunityComment.
     * @param {CommunityCommentCreateArgs} args - Arguments to create a CommunityComment.
     * @example
     * // Create one CommunityComment
     * const CommunityComment = await prisma.communityComment.create({
     *   data: {
     *     // ... data to create a CommunityComment
     *   }
     * })
     * 
    **/
    create<T extends CommunityCommentCreateArgs>(
      args: SelectSubset<T, CommunityCommentCreateArgs>
    ): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>>

    /**
     * Delete a CommunityComment.
     * @param {CommunityCommentDeleteArgs} args - Arguments to delete one CommunityComment.
     * @example
     * // Delete one CommunityComment
     * const CommunityComment = await prisma.communityComment.delete({
     *   where: {
     *     // ... filter to delete one CommunityComment
     *   }
     * })
     * 
    **/
    delete<T extends CommunityCommentDeleteArgs>(
      args: SelectSubset<T, CommunityCommentDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>>

    /**
     * Update one CommunityComment.
     * @param {CommunityCommentUpdateArgs} args - Arguments to update one CommunityComment.
     * @example
     * // Update one CommunityComment
     * const communityComment = await prisma.communityComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityCommentUpdateArgs>(
      args: SelectSubset<T, CommunityCommentUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>>

    /**
     * Delete zero or more CommunityComments.
     * @param {CommunityCommentDeleteManyArgs} args - Arguments to filter CommunityComments to delete.
     * @example
     * // Delete a few CommunityComments
     * const { count } = await prisma.communityComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityCommentDeleteManyArgs>(
      args?: SelectSubset<T, CommunityCommentDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CommunityComments.
     * @param {CommunityCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityComments
     * const communityComment = await prisma.communityComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityCommentUpdateManyArgs>(
      args: SelectSubset<T, CommunityCommentUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CommunityComment.
     * @param {CommunityCommentUpsertArgs} args - Arguments to update or create a CommunityComment.
     * @example
     * // Update or create a CommunityComment
     * const communityComment = await prisma.communityComment.upsert({
     *   create: {
     *     // ... data to create a CommunityComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityComment we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityCommentUpsertArgs>(
      args: SelectSubset<T, CommunityCommentUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>>

    /**
     * Count the number of CommunityComments.
     * @param {CommunityCommentCountArgs} args - Arguments to filter CommunityComments to count.
     * @example
     * // Count the number of CommunityComments
     * const count = await prisma.communityComment.count({
     *   where: {
     *     // ... the filter for the CommunityComments we want to count
     *   }
     * })
    **/
    count<T extends CommunityCommentCountArgs>(
      args?: Subset<T, CommunityCommentCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityComment.
     * @param {CommunityCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityCommentAggregateArgs>(args: Subset<T, CommunityCommentAggregateArgs>): Promise<GetCommunityCommentAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityCommentClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityPost<T extends CommunityPostArgs = {}>(args?: Subset<T, CommunityPostArgs>): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    communitySubcomments<T extends CommunitySubcommentFindManyArgs = {}>(args?: Subset<T, CommunitySubcommentFindManyArgs>): CheckSelect<T, Promise<Array<CommunitySubcomment>>, Promise<Array<CommunitySubcommentGetPayload<T>>>>;

    reportComments<T extends ReportCommentFindManyArgs = {}>(args?: Subset<T, ReportCommentFindManyArgs>): CheckSelect<T, Promise<Array<ReportComment>>, Promise<Array<ReportCommentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityComment findUnique
   */
  export type CommunityCommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * Throw an Error if a CommunityComment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityComment to fetch.
    **/
    where: CommunityCommentWhereUniqueInput
  }


  /**
   * CommunityComment findFirst
   */
  export type CommunityCommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * Throw an Error if a CommunityComment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityComment to fetch.
    **/
    where?: CommunityCommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityComments to fetch.
    **/
    orderBy?: Enumerable<CommunityCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityComments.
    **/
    cursor?: CommunityCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityComments.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CommunityComments.
    **/
    distinct?: Enumerable<CommunityCommentScalarFieldEnum>
  }


  /**
   * CommunityComment findMany
   */
  export type CommunityCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * Filter, which CommunityComments to fetch.
    **/
    where?: CommunityCommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityComments to fetch.
    **/
    orderBy?: Enumerable<CommunityCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityComments.
    **/
    cursor?: CommunityCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityComments.
    **/
    skip?: number
    distinct?: Enumerable<CommunityCommentScalarFieldEnum>
  }


  /**
   * CommunityComment create
   */
  export type CommunityCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * The data needed to create a CommunityComment.
    **/
    data: XOR<CommunityCommentUncheckedCreateInput, CommunityCommentCreateInput>
  }


  /**
   * CommunityComment update
   */
  export type CommunityCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * The data needed to update a CommunityComment.
    **/
    data: XOR<CommunityCommentUncheckedUpdateInput, CommunityCommentUpdateInput>
    /**
     * Choose, which CommunityComment to update.
    **/
    where: CommunityCommentWhereUniqueInput
  }


  /**
   * CommunityComment updateMany
   */
  export type CommunityCommentUpdateManyArgs = {
    data: XOR<CommunityCommentUncheckedUpdateManyInput, CommunityCommentUpdateManyMutationInput>
    where?: CommunityCommentWhereInput
  }


  /**
   * CommunityComment upsert
   */
  export type CommunityCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * The filter to search for the CommunityComment to update in case it exists.
    **/
    where: CommunityCommentWhereUniqueInput
    /**
     * In case the CommunityComment found by the `where` argument doesn't exist, create a new CommunityComment with this data.
    **/
    create: XOR<CommunityCommentUncheckedCreateInput, CommunityCommentCreateInput>
    /**
     * In case the CommunityComment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityCommentUncheckedUpdateInput, CommunityCommentUpdateInput>
  }


  /**
   * CommunityComment delete
   */
  export type CommunityCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * Filter which CommunityComment to delete.
    **/
    where: CommunityCommentWhereUniqueInput
  }


  /**
   * CommunityComment deleteMany
   */
  export type CommunityCommentDeleteManyArgs = {
    where?: CommunityCommentWhereInput
  }


  /**
   * CommunityComment without action
   */
  export type CommunityCommentArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
  }



  /**
   * Model CommunityPost
   */


  export type AggregateCommunityPost = {
    count: CommunityPostCountAggregateOutputType | null
    avg: CommunityPostAvgAggregateOutputType | null
    sum: CommunityPostSumAggregateOutputType | null
    min: CommunityPostMinAggregateOutputType | null
    max: CommunityPostMaxAggregateOutputType | null
  }

  export type CommunityPostAvgAggregateOutputType = {
    id: number
    boardId: number
    userId: number
    likesCount: number
    commentsCount: number
    bookmarksCount: number
  }

  export type CommunityPostSumAggregateOutputType = {
    id: number
    boardId: number
    userId: number
    likesCount: number
    commentsCount: number
    bookmarksCount: number
  }

  export type CommunityPostMinAggregateOutputType = {
    id: number
    boardId: number
    userId: number
    title: string | null
    body: string | null
    randomNickname: string | null
    likesCount: number
    commentsCount: number
    bookmarksCount: number
    postedAt: Date | null
    editedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunityPostMaxAggregateOutputType = {
    id: number
    boardId: number
    userId: number
    title: string | null
    body: string | null
    randomNickname: string | null
    likesCount: number
    commentsCount: number
    bookmarksCount: number
    postedAt: Date | null
    editedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunityPostCountAggregateOutputType = {
    id: number
    boardId: number
    userId: number
    title: number | null
    body: number | null
    randomNickname: number | null
    likesCount: number
    commentsCount: number
    bookmarksCount: number
    postedAt: number | null
    editedAt: number | null
    isDeleted: number | null
    _all: number
  }


  export type CommunityPostAvgAggregateInputType = {
    id?: true
    boardId?: true
    userId?: true
    likesCount?: true
    commentsCount?: true
    bookmarksCount?: true
  }

  export type CommunityPostSumAggregateInputType = {
    id?: true
    boardId?: true
    userId?: true
    likesCount?: true
    commentsCount?: true
    bookmarksCount?: true
  }

  export type CommunityPostMinAggregateInputType = {
    id?: true
    boardId?: true
    userId?: true
    title?: true
    body?: true
    randomNickname?: true
    likesCount?: true
    commentsCount?: true
    bookmarksCount?: true
    postedAt?: true
    editedAt?: true
    isDeleted?: true
  }

  export type CommunityPostMaxAggregateInputType = {
    id?: true
    boardId?: true
    userId?: true
    title?: true
    body?: true
    randomNickname?: true
    likesCount?: true
    commentsCount?: true
    bookmarksCount?: true
    postedAt?: true
    editedAt?: true
    isDeleted?: true
  }

  export type CommunityPostCountAggregateInputType = {
    id?: true
    boardId?: true
    userId?: true
    title?: true
    body?: true
    randomNickname?: true
    likesCount?: true
    commentsCount?: true
    bookmarksCount?: true
    postedAt?: true
    editedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type CommunityPostAggregateArgs = {
    /**
     * Filter which CommunityPost to aggregate.
    **/
    where?: CommunityPostWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityPosts to fetch.
    **/
    orderBy?: Enumerable<CommunityPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityPosts
    **/
    count?: true | CommunityPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityPostMaxAggregateInputType
  }

  export type GetCommunityPostAggregateType<T extends CommunityPostAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityPost]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityPost[P]>
      : GetScalarType<T[P], AggregateCommunityPost[P]>
  }



  export type CommunityPostSelect = {
    id?: boolean
    boardId?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    randomNickname?: boolean
    likesCount?: boolean
    commentsCount?: boolean
    bookmarksCount?: boolean
    postedAt?: boolean
    editedAt?: boolean
    isDeleted?: boolean
    communityBoard?: boolean | CommunityBoardArgs
    user?: boolean | UserArgs
    communityComments?: boolean | CommunityCommentFindManyArgs
    communityPostBookmarks?: boolean | CommunityPostBookmarkFindManyArgs
    communityPostLikes?: boolean | CommunityPostLikeFindManyArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    reportPosts?: boolean | ReportPostFindManyArgs
  }

  export type CommunityPostInclude = {
    communityBoard?: boolean | CommunityBoardArgs
    user?: boolean | UserArgs
    communityComments?: boolean | CommunityCommentFindManyArgs
    communityPostBookmarks?: boolean | CommunityPostBookmarkFindManyArgs
    communityPostLikes?: boolean | CommunityPostLikeFindManyArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    reportPosts?: boolean | ReportPostFindManyArgs
  }

  export type CommunityPostGetPayload<
    S extends boolean | null | undefined | CommunityPostArgs,
    U = keyof S
      > = S extends true
        ? CommunityPost
    : S extends undefined
    ? never
    : S extends CommunityPostArgs | CommunityPostFindManyArgs
    ?'include' extends U
    ? CommunityPost  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityBoard'
        ? CommunityBoardGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'communityComments'
        ? Array < CommunityCommentGetPayload<S['include'][P]>>  :
        P extends 'communityPostBookmarks'
        ? Array < CommunityPostBookmarkGetPayload<S['include'][P]>>  :
        P extends 'communityPostLikes'
        ? Array < CommunityPostLikeGetPayload<S['include'][P]>>  :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['include'][P]>>  :
        P extends 'reportPosts'
        ? Array < ReportPostGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityPost ?CommunityPost [P]
  : 
          P extends 'communityBoard'
        ? CommunityBoardGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'communityComments'
        ? Array < CommunityCommentGetPayload<S['select'][P]>>  :
        P extends 'communityPostBookmarks'
        ? Array < CommunityPostBookmarkGetPayload<S['select'][P]>>  :
        P extends 'communityPostLikes'
        ? Array < CommunityPostLikeGetPayload<S['select'][P]>>  :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['select'][P]>>  :
        P extends 'reportPosts'
        ? Array < ReportPostGetPayload<S['select'][P]>>  : never
  } 
    : CommunityPost
  : CommunityPost


  type CommunityPostCountArgs = Merge<
    Omit<CommunityPostFindManyArgs, 'select' | 'include'> & {
      select?: CommunityPostCountAggregateInputType | true
    }
  >

  export interface CommunityPostDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityPost that matches the filter.
     * @param {CommunityPostFindUniqueArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityPost'> extends True ? CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>

    /**
     * Find the first CommunityPost that matches the filter.
     * @param {CommunityPostFindFirstArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityPost'> extends True ? CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>

    /**
     * Find zero or more CommunityPosts that matches the filter.
     * @param {CommunityPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityPosts
     * const communityPosts = await prisma.communityPost.findMany()
     * 
     * // Get first 10 CommunityPosts
     * const communityPosts = await prisma.communityPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityPostWithIdOnly = await prisma.communityPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityPostFindManyArgs>(
      args?: SelectSubset<T, CommunityPostFindManyArgs>
    ): CheckSelect<T, Promise<Array<CommunityPost>>, Promise<Array<CommunityPostGetPayload<T>>>>

    /**
     * Create a CommunityPost.
     * @param {CommunityPostCreateArgs} args - Arguments to create a CommunityPost.
     * @example
     * // Create one CommunityPost
     * const CommunityPost = await prisma.communityPost.create({
     *   data: {
     *     // ... data to create a CommunityPost
     *   }
     * })
     * 
    **/
    create<T extends CommunityPostCreateArgs>(
      args: SelectSubset<T, CommunityPostCreateArgs>
    ): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>>

    /**
     * Delete a CommunityPost.
     * @param {CommunityPostDeleteArgs} args - Arguments to delete one CommunityPost.
     * @example
     * // Delete one CommunityPost
     * const CommunityPost = await prisma.communityPost.delete({
     *   where: {
     *     // ... filter to delete one CommunityPost
     *   }
     * })
     * 
    **/
    delete<T extends CommunityPostDeleteArgs>(
      args: SelectSubset<T, CommunityPostDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>>

    /**
     * Update one CommunityPost.
     * @param {CommunityPostUpdateArgs} args - Arguments to update one CommunityPost.
     * @example
     * // Update one CommunityPost
     * const communityPost = await prisma.communityPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityPostUpdateArgs>(
      args: SelectSubset<T, CommunityPostUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>>

    /**
     * Delete zero or more CommunityPosts.
     * @param {CommunityPostDeleteManyArgs} args - Arguments to filter CommunityPosts to delete.
     * @example
     * // Delete a few CommunityPosts
     * const { count } = await prisma.communityPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityPostDeleteManyArgs>(
      args?: SelectSubset<T, CommunityPostDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CommunityPosts.
     * @param {CommunityPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityPosts
     * const communityPost = await prisma.communityPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityPostUpdateManyArgs>(
      args: SelectSubset<T, CommunityPostUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CommunityPost.
     * @param {CommunityPostUpsertArgs} args - Arguments to update or create a CommunityPost.
     * @example
     * // Update or create a CommunityPost
     * const communityPost = await prisma.communityPost.upsert({
     *   create: {
     *     // ... data to create a CommunityPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityPost we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityPostUpsertArgs>(
      args: SelectSubset<T, CommunityPostUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>>

    /**
     * Count the number of CommunityPosts.
     * @param {CommunityPostCountArgs} args - Arguments to filter CommunityPosts to count.
     * @example
     * // Count the number of CommunityPosts
     * const count = await prisma.communityPost.count({
     *   where: {
     *     // ... the filter for the CommunityPosts we want to count
     *   }
     * })
    **/
    count<T extends CommunityPostCountArgs>(
      args?: Subset<T, CommunityPostCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityPost.
     * @param {CommunityPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityPostAggregateArgs>(args: Subset<T, CommunityPostAggregateArgs>): Promise<GetCommunityPostAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityPostClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityBoard<T extends CommunityBoardArgs = {}>(args?: Subset<T, CommunityBoardArgs>): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard | null >, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    communityComments<T extends CommunityCommentFindManyArgs = {}>(args?: Subset<T, CommunityCommentFindManyArgs>): CheckSelect<T, Promise<Array<CommunityComment>>, Promise<Array<CommunityCommentGetPayload<T>>>>;

    communityPostBookmarks<T extends CommunityPostBookmarkFindManyArgs = {}>(args?: Subset<T, CommunityPostBookmarkFindManyArgs>): CheckSelect<T, Promise<Array<CommunityPostBookmark>>, Promise<Array<CommunityPostBookmarkGetPayload<T>>>>;

    communityPostLikes<T extends CommunityPostLikeFindManyArgs = {}>(args?: Subset<T, CommunityPostLikeFindManyArgs>): CheckSelect<T, Promise<Array<CommunityPostLike>>, Promise<Array<CommunityPostLikeGetPayload<T>>>>;

    communitySubcomments<T extends CommunitySubcommentFindManyArgs = {}>(args?: Subset<T, CommunitySubcommentFindManyArgs>): CheckSelect<T, Promise<Array<CommunitySubcomment>>, Promise<Array<CommunitySubcommentGetPayload<T>>>>;

    reportPosts<T extends ReportPostFindManyArgs = {}>(args?: Subset<T, ReportPostFindManyArgs>): CheckSelect<T, Promise<Array<ReportPost>>, Promise<Array<ReportPostGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityPost findUnique
   */
  export type CommunityPostFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * Throw an Error if a CommunityPost can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPost to fetch.
    **/
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost findFirst
   */
  export type CommunityPostFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * Throw an Error if a CommunityPost can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPost to fetch.
    **/
    where?: CommunityPostWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityPosts to fetch.
    **/
    orderBy?: Enumerable<CommunityPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPosts.
    **/
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CommunityPosts.
    **/
    distinct?: Enumerable<CommunityPostScalarFieldEnum>
  }


  /**
   * CommunityPost findMany
   */
  export type CommunityPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * Filter, which CommunityPosts to fetch.
    **/
    where?: CommunityPostWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityPosts to fetch.
    **/
    orderBy?: Enumerable<CommunityPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityPosts.
    **/
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
    **/
    skip?: number
    distinct?: Enumerable<CommunityPostScalarFieldEnum>
  }


  /**
   * CommunityPost create
   */
  export type CommunityPostCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * The data needed to create a CommunityPost.
    **/
    data: XOR<CommunityPostUncheckedCreateInput, CommunityPostCreateInput>
  }


  /**
   * CommunityPost update
   */
  export type CommunityPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * The data needed to update a CommunityPost.
    **/
    data: XOR<CommunityPostUncheckedUpdateInput, CommunityPostUpdateInput>
    /**
     * Choose, which CommunityPost to update.
    **/
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost updateMany
   */
  export type CommunityPostUpdateManyArgs = {
    data: XOR<CommunityPostUncheckedUpdateManyInput, CommunityPostUpdateManyMutationInput>
    where?: CommunityPostWhereInput
  }


  /**
   * CommunityPost upsert
   */
  export type CommunityPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * The filter to search for the CommunityPost to update in case it exists.
    **/
    where: CommunityPostWhereUniqueInput
    /**
     * In case the CommunityPost found by the `where` argument doesn't exist, create a new CommunityPost with this data.
    **/
    create: XOR<CommunityPostUncheckedCreateInput, CommunityPostCreateInput>
    /**
     * In case the CommunityPost was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityPostUncheckedUpdateInput, CommunityPostUpdateInput>
  }


  /**
   * CommunityPost delete
   */
  export type CommunityPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * Filter which CommunityPost to delete.
    **/
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost deleteMany
   */
  export type CommunityPostDeleteManyArgs = {
    where?: CommunityPostWhereInput
  }


  /**
   * CommunityPost without action
   */
  export type CommunityPostArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
  }



  /**
   * Model CommunityPostBookmark
   */


  export type AggregateCommunityPostBookmark = {
    count: CommunityPostBookmarkCountAggregateOutputType | null
    avg: CommunityPostBookmarkAvgAggregateOutputType | null
    sum: CommunityPostBookmarkSumAggregateOutputType | null
    min: CommunityPostBookmarkMinAggregateOutputType | null
    max: CommunityPostBookmarkMaxAggregateOutputType | null
  }

  export type CommunityPostBookmarkAvgAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostBookmarkSumAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostBookmarkMinAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostBookmarkMaxAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostBookmarkCountAggregateOutputType = {
    userId: number
    postId: number
    _all: number
  }


  export type CommunityPostBookmarkAvgAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostBookmarkSumAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostBookmarkMinAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostBookmarkMaxAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostBookmarkCountAggregateInputType = {
    userId?: true
    postId?: true
    _all?: true
  }

  export type CommunityPostBookmarkAggregateArgs = {
    /**
     * Filter which CommunityPostBookmark to aggregate.
    **/
    where?: CommunityPostBookmarkWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityPostBookmarks to fetch.
    **/
    orderBy?: Enumerable<CommunityPostBookmarkOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityPostBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostBookmarks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostBookmarks.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityPostBookmarks
    **/
    count?: true | CommunityPostBookmarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityPostBookmarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityPostBookmarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityPostBookmarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityPostBookmarkMaxAggregateInputType
  }

  export type GetCommunityPostBookmarkAggregateType<T extends CommunityPostBookmarkAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityPostBookmark]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityPostBookmark[P]>
      : GetScalarType<T[P], AggregateCommunityPostBookmark[P]>
  }



  export type CommunityPostBookmarkSelect = {
    userId?: boolean
    postId?: boolean
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type CommunityPostBookmarkInclude = {
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type CommunityPostBookmarkGetPayload<
    S extends boolean | null | undefined | CommunityPostBookmarkArgs,
    U = keyof S
      > = S extends true
        ? CommunityPostBookmark
    : S extends undefined
    ? never
    : S extends CommunityPostBookmarkArgs | CommunityPostBookmarkFindManyArgs
    ?'include' extends U
    ? CommunityPostBookmark  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityPostBookmark ?CommunityPostBookmark [P]
  : 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : CommunityPostBookmark
  : CommunityPostBookmark


  type CommunityPostBookmarkCountArgs = Merge<
    Omit<CommunityPostBookmarkFindManyArgs, 'select' | 'include'> & {
      select?: CommunityPostBookmarkCountAggregateInputType | true
    }
  >

  export interface CommunityPostBookmarkDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityPostBookmark that matches the filter.
     * @param {CommunityPostBookmarkFindUniqueArgs} args - Arguments to find a CommunityPostBookmark
     * @example
     * // Get one CommunityPostBookmark
     * const communityPostBookmark = await prisma.communityPostBookmark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityPostBookmarkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityPostBookmarkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityPostBookmark'> extends True ? CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark | null >, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T> | null >>

    /**
     * Find the first CommunityPostBookmark that matches the filter.
     * @param {CommunityPostBookmarkFindFirstArgs} args - Arguments to find a CommunityPostBookmark
     * @example
     * // Get one CommunityPostBookmark
     * const communityPostBookmark = await prisma.communityPostBookmark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityPostBookmarkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityPostBookmarkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityPostBookmark'> extends True ? CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark | null >, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T> | null >>

    /**
     * Find zero or more CommunityPostBookmarks that matches the filter.
     * @param {CommunityPostBookmarkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityPostBookmarks
     * const communityPostBookmarks = await prisma.communityPostBookmark.findMany()
     * 
     * // Get first 10 CommunityPostBookmarks
     * const communityPostBookmarks = await prisma.communityPostBookmark.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const communityPostBookmarkWithUserIdOnly = await prisma.communityPostBookmark.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CommunityPostBookmarkFindManyArgs>(
      args?: SelectSubset<T, CommunityPostBookmarkFindManyArgs>
    ): CheckSelect<T, Promise<Array<CommunityPostBookmark>>, Promise<Array<CommunityPostBookmarkGetPayload<T>>>>

    /**
     * Create a CommunityPostBookmark.
     * @param {CommunityPostBookmarkCreateArgs} args - Arguments to create a CommunityPostBookmark.
     * @example
     * // Create one CommunityPostBookmark
     * const CommunityPostBookmark = await prisma.communityPostBookmark.create({
     *   data: {
     *     // ... data to create a CommunityPostBookmark
     *   }
     * })
     * 
    **/
    create<T extends CommunityPostBookmarkCreateArgs>(
      args: SelectSubset<T, CommunityPostBookmarkCreateArgs>
    ): CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>>

    /**
     * Delete a CommunityPostBookmark.
     * @param {CommunityPostBookmarkDeleteArgs} args - Arguments to delete one CommunityPostBookmark.
     * @example
     * // Delete one CommunityPostBookmark
     * const CommunityPostBookmark = await prisma.communityPostBookmark.delete({
     *   where: {
     *     // ... filter to delete one CommunityPostBookmark
     *   }
     * })
     * 
    **/
    delete<T extends CommunityPostBookmarkDeleteArgs>(
      args: SelectSubset<T, CommunityPostBookmarkDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>>

    /**
     * Update one CommunityPostBookmark.
     * @param {CommunityPostBookmarkUpdateArgs} args - Arguments to update one CommunityPostBookmark.
     * @example
     * // Update one CommunityPostBookmark
     * const communityPostBookmark = await prisma.communityPostBookmark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityPostBookmarkUpdateArgs>(
      args: SelectSubset<T, CommunityPostBookmarkUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>>

    /**
     * Delete zero or more CommunityPostBookmarks.
     * @param {CommunityPostBookmarkDeleteManyArgs} args - Arguments to filter CommunityPostBookmarks to delete.
     * @example
     * // Delete a few CommunityPostBookmarks
     * const { count } = await prisma.communityPostBookmark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityPostBookmarkDeleteManyArgs>(
      args?: SelectSubset<T, CommunityPostBookmarkDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CommunityPostBookmarks.
     * @param {CommunityPostBookmarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityPostBookmarks
     * const communityPostBookmark = await prisma.communityPostBookmark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityPostBookmarkUpdateManyArgs>(
      args: SelectSubset<T, CommunityPostBookmarkUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CommunityPostBookmark.
     * @param {CommunityPostBookmarkUpsertArgs} args - Arguments to update or create a CommunityPostBookmark.
     * @example
     * // Update or create a CommunityPostBookmark
     * const communityPostBookmark = await prisma.communityPostBookmark.upsert({
     *   create: {
     *     // ... data to create a CommunityPostBookmark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityPostBookmark we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityPostBookmarkUpsertArgs>(
      args: SelectSubset<T, CommunityPostBookmarkUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>>

    /**
     * Count the number of CommunityPostBookmarks.
     * @param {CommunityPostBookmarkCountArgs} args - Arguments to filter CommunityPostBookmarks to count.
     * @example
     * // Count the number of CommunityPostBookmarks
     * const count = await prisma.communityPostBookmark.count({
     *   where: {
     *     // ... the filter for the CommunityPostBookmarks we want to count
     *   }
     * })
    **/
    count<T extends CommunityPostBookmarkCountArgs>(
      args?: Subset<T, CommunityPostBookmarkCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityPostBookmarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityPostBookmark.
     * @param {CommunityPostBookmarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityPostBookmarkAggregateArgs>(args: Subset<T, CommunityPostBookmarkAggregateArgs>): Promise<GetCommunityPostBookmarkAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityPostBookmark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityPostBookmarkClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityPost<T extends CommunityPostArgs = {}>(args?: Subset<T, CommunityPostArgs>): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityPostBookmark findUnique
   */
  export type CommunityPostBookmarkFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * Throw an Error if a CommunityPostBookmark can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPostBookmark to fetch.
    **/
    where: CommunityPostBookmarkWhereUniqueInput
  }


  /**
   * CommunityPostBookmark findFirst
   */
  export type CommunityPostBookmarkFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * Throw an Error if a CommunityPostBookmark can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPostBookmark to fetch.
    **/
    where?: CommunityPostBookmarkWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityPostBookmarks to fetch.
    **/
    orderBy?: Enumerable<CommunityPostBookmarkOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPostBookmarks.
    **/
    cursor?: CommunityPostBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostBookmarks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostBookmarks.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CommunityPostBookmarks.
    **/
    distinct?: Enumerable<CommunityPostBookmarkScalarFieldEnum>
  }


  /**
   * CommunityPostBookmark findMany
   */
  export type CommunityPostBookmarkFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * Filter, which CommunityPostBookmarks to fetch.
    **/
    where?: CommunityPostBookmarkWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityPostBookmarks to fetch.
    **/
    orderBy?: Enumerable<CommunityPostBookmarkOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityPostBookmarks.
    **/
    cursor?: CommunityPostBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostBookmarks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostBookmarks.
    **/
    skip?: number
    distinct?: Enumerable<CommunityPostBookmarkScalarFieldEnum>
  }


  /**
   * CommunityPostBookmark create
   */
  export type CommunityPostBookmarkCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * The data needed to create a CommunityPostBookmark.
    **/
    data: XOR<CommunityPostBookmarkUncheckedCreateInput, CommunityPostBookmarkCreateInput>
  }


  /**
   * CommunityPostBookmark update
   */
  export type CommunityPostBookmarkUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * The data needed to update a CommunityPostBookmark.
    **/
    data: XOR<CommunityPostBookmarkUncheckedUpdateInput, CommunityPostBookmarkUpdateInput>
    /**
     * Choose, which CommunityPostBookmark to update.
    **/
    where: CommunityPostBookmarkWhereUniqueInput
  }


  /**
   * CommunityPostBookmark updateMany
   */
  export type CommunityPostBookmarkUpdateManyArgs = {
    data: XOR<CommunityPostBookmarkUncheckedUpdateManyInput, CommunityPostBookmarkUpdateManyMutationInput>
    where?: CommunityPostBookmarkWhereInput
  }


  /**
   * CommunityPostBookmark upsert
   */
  export type CommunityPostBookmarkUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * The filter to search for the CommunityPostBookmark to update in case it exists.
    **/
    where: CommunityPostBookmarkWhereUniqueInput
    /**
     * In case the CommunityPostBookmark found by the `where` argument doesn't exist, create a new CommunityPostBookmark with this data.
    **/
    create: XOR<CommunityPostBookmarkUncheckedCreateInput, CommunityPostBookmarkCreateInput>
    /**
     * In case the CommunityPostBookmark was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityPostBookmarkUncheckedUpdateInput, CommunityPostBookmarkUpdateInput>
  }


  /**
   * CommunityPostBookmark delete
   */
  export type CommunityPostBookmarkDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * Filter which CommunityPostBookmark to delete.
    **/
    where: CommunityPostBookmarkWhereUniqueInput
  }


  /**
   * CommunityPostBookmark deleteMany
   */
  export type CommunityPostBookmarkDeleteManyArgs = {
    where?: CommunityPostBookmarkWhereInput
  }


  /**
   * CommunityPostBookmark without action
   */
  export type CommunityPostBookmarkArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
  }



  /**
   * Model CommunityPostLike
   */


  export type AggregateCommunityPostLike = {
    count: CommunityPostLikeCountAggregateOutputType | null
    avg: CommunityPostLikeAvgAggregateOutputType | null
    sum: CommunityPostLikeSumAggregateOutputType | null
    min: CommunityPostLikeMinAggregateOutputType | null
    max: CommunityPostLikeMaxAggregateOutputType | null
  }

  export type CommunityPostLikeAvgAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeSumAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeMinAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeMaxAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeCountAggregateOutputType = {
    userId: number
    postId: number
    _all: number
  }


  export type CommunityPostLikeAvgAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostLikeSumAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostLikeMinAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostLikeMaxAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostLikeCountAggregateInputType = {
    userId?: true
    postId?: true
    _all?: true
  }

  export type CommunityPostLikeAggregateArgs = {
    /**
     * Filter which CommunityPostLike to aggregate.
    **/
    where?: CommunityPostLikeWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityPostLikes to fetch.
    **/
    orderBy?: Enumerable<CommunityPostLikeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityPostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostLikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostLikes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityPostLikes
    **/
    count?: true | CommunityPostLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityPostLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityPostLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityPostLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityPostLikeMaxAggregateInputType
  }

  export type GetCommunityPostLikeAggregateType<T extends CommunityPostLikeAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityPostLike]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityPostLike[P]>
      : GetScalarType<T[P], AggregateCommunityPostLike[P]>
  }



  export type CommunityPostLikeSelect = {
    userId?: boolean
    postId?: boolean
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type CommunityPostLikeInclude = {
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type CommunityPostLikeGetPayload<
    S extends boolean | null | undefined | CommunityPostLikeArgs,
    U = keyof S
      > = S extends true
        ? CommunityPostLike
    : S extends undefined
    ? never
    : S extends CommunityPostLikeArgs | CommunityPostLikeFindManyArgs
    ?'include' extends U
    ? CommunityPostLike  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityPostLike ?CommunityPostLike [P]
  : 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : CommunityPostLike
  : CommunityPostLike


  type CommunityPostLikeCountArgs = Merge<
    Omit<CommunityPostLikeFindManyArgs, 'select' | 'include'> & {
      select?: CommunityPostLikeCountAggregateInputType | true
    }
  >

  export interface CommunityPostLikeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityPostLike that matches the filter.
     * @param {CommunityPostLikeFindUniqueArgs} args - Arguments to find a CommunityPostLike
     * @example
     * // Get one CommunityPostLike
     * const communityPostLike = await prisma.communityPostLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityPostLikeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityPostLikeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityPostLike'> extends True ? CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike | null >, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T> | null >>

    /**
     * Find the first CommunityPostLike that matches the filter.
     * @param {CommunityPostLikeFindFirstArgs} args - Arguments to find a CommunityPostLike
     * @example
     * // Get one CommunityPostLike
     * const communityPostLike = await prisma.communityPostLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityPostLikeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityPostLikeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityPostLike'> extends True ? CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike | null >, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T> | null >>

    /**
     * Find zero or more CommunityPostLikes that matches the filter.
     * @param {CommunityPostLikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityPostLikes
     * const communityPostLikes = await prisma.communityPostLike.findMany()
     * 
     * // Get first 10 CommunityPostLikes
     * const communityPostLikes = await prisma.communityPostLike.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const communityPostLikeWithUserIdOnly = await prisma.communityPostLike.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CommunityPostLikeFindManyArgs>(
      args?: SelectSubset<T, CommunityPostLikeFindManyArgs>
    ): CheckSelect<T, Promise<Array<CommunityPostLike>>, Promise<Array<CommunityPostLikeGetPayload<T>>>>

    /**
     * Create a CommunityPostLike.
     * @param {CommunityPostLikeCreateArgs} args - Arguments to create a CommunityPostLike.
     * @example
     * // Create one CommunityPostLike
     * const CommunityPostLike = await prisma.communityPostLike.create({
     *   data: {
     *     // ... data to create a CommunityPostLike
     *   }
     * })
     * 
    **/
    create<T extends CommunityPostLikeCreateArgs>(
      args: SelectSubset<T, CommunityPostLikeCreateArgs>
    ): CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>>

    /**
     * Delete a CommunityPostLike.
     * @param {CommunityPostLikeDeleteArgs} args - Arguments to delete one CommunityPostLike.
     * @example
     * // Delete one CommunityPostLike
     * const CommunityPostLike = await prisma.communityPostLike.delete({
     *   where: {
     *     // ... filter to delete one CommunityPostLike
     *   }
     * })
     * 
    **/
    delete<T extends CommunityPostLikeDeleteArgs>(
      args: SelectSubset<T, CommunityPostLikeDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>>

    /**
     * Update one CommunityPostLike.
     * @param {CommunityPostLikeUpdateArgs} args - Arguments to update one CommunityPostLike.
     * @example
     * // Update one CommunityPostLike
     * const communityPostLike = await prisma.communityPostLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityPostLikeUpdateArgs>(
      args: SelectSubset<T, CommunityPostLikeUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>>

    /**
     * Delete zero or more CommunityPostLikes.
     * @param {CommunityPostLikeDeleteManyArgs} args - Arguments to filter CommunityPostLikes to delete.
     * @example
     * // Delete a few CommunityPostLikes
     * const { count } = await prisma.communityPostLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityPostLikeDeleteManyArgs>(
      args?: SelectSubset<T, CommunityPostLikeDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CommunityPostLikes.
     * @param {CommunityPostLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityPostLikes
     * const communityPostLike = await prisma.communityPostLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityPostLikeUpdateManyArgs>(
      args: SelectSubset<T, CommunityPostLikeUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CommunityPostLike.
     * @param {CommunityPostLikeUpsertArgs} args - Arguments to update or create a CommunityPostLike.
     * @example
     * // Update or create a CommunityPostLike
     * const communityPostLike = await prisma.communityPostLike.upsert({
     *   create: {
     *     // ... data to create a CommunityPostLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityPostLike we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityPostLikeUpsertArgs>(
      args: SelectSubset<T, CommunityPostLikeUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>>

    /**
     * Count the number of CommunityPostLikes.
     * @param {CommunityPostLikeCountArgs} args - Arguments to filter CommunityPostLikes to count.
     * @example
     * // Count the number of CommunityPostLikes
     * const count = await prisma.communityPostLike.count({
     *   where: {
     *     // ... the filter for the CommunityPostLikes we want to count
     *   }
     * })
    **/
    count<T extends CommunityPostLikeCountArgs>(
      args?: Subset<T, CommunityPostLikeCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityPostLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityPostLike.
     * @param {CommunityPostLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityPostLikeAggregateArgs>(args: Subset<T, CommunityPostLikeAggregateArgs>): Promise<GetCommunityPostLikeAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityPostLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityPostLikeClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityPost<T extends CommunityPostArgs = {}>(args?: Subset<T, CommunityPostArgs>): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityPostLike findUnique
   */
  export type CommunityPostLikeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * Throw an Error if a CommunityPostLike can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPostLike to fetch.
    **/
    where: CommunityPostLikeWhereUniqueInput
  }


  /**
   * CommunityPostLike findFirst
   */
  export type CommunityPostLikeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * Throw an Error if a CommunityPostLike can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPostLike to fetch.
    **/
    where?: CommunityPostLikeWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityPostLikes to fetch.
    **/
    orderBy?: Enumerable<CommunityPostLikeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPostLikes.
    **/
    cursor?: CommunityPostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostLikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostLikes.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CommunityPostLikes.
    **/
    distinct?: Enumerable<CommunityPostLikeScalarFieldEnum>
  }


  /**
   * CommunityPostLike findMany
   */
  export type CommunityPostLikeFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * Filter, which CommunityPostLikes to fetch.
    **/
    where?: CommunityPostLikeWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunityPostLikes to fetch.
    **/
    orderBy?: Enumerable<CommunityPostLikeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityPostLikes.
    **/
    cursor?: CommunityPostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostLikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostLikes.
    **/
    skip?: number
    distinct?: Enumerable<CommunityPostLikeScalarFieldEnum>
  }


  /**
   * CommunityPostLike create
   */
  export type CommunityPostLikeCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * The data needed to create a CommunityPostLike.
    **/
    data: XOR<CommunityPostLikeUncheckedCreateInput, CommunityPostLikeCreateInput>
  }


  /**
   * CommunityPostLike update
   */
  export type CommunityPostLikeUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * The data needed to update a CommunityPostLike.
    **/
    data: XOR<CommunityPostLikeUncheckedUpdateInput, CommunityPostLikeUpdateInput>
    /**
     * Choose, which CommunityPostLike to update.
    **/
    where: CommunityPostLikeWhereUniqueInput
  }


  /**
   * CommunityPostLike updateMany
   */
  export type CommunityPostLikeUpdateManyArgs = {
    data: XOR<CommunityPostLikeUncheckedUpdateManyInput, CommunityPostLikeUpdateManyMutationInput>
    where?: CommunityPostLikeWhereInput
  }


  /**
   * CommunityPostLike upsert
   */
  export type CommunityPostLikeUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * The filter to search for the CommunityPostLike to update in case it exists.
    **/
    where: CommunityPostLikeWhereUniqueInput
    /**
     * In case the CommunityPostLike found by the `where` argument doesn't exist, create a new CommunityPostLike with this data.
    **/
    create: XOR<CommunityPostLikeUncheckedCreateInput, CommunityPostLikeCreateInput>
    /**
     * In case the CommunityPostLike was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityPostLikeUncheckedUpdateInput, CommunityPostLikeUpdateInput>
  }


  /**
   * CommunityPostLike delete
   */
  export type CommunityPostLikeDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * Filter which CommunityPostLike to delete.
    **/
    where: CommunityPostLikeWhereUniqueInput
  }


  /**
   * CommunityPostLike deleteMany
   */
  export type CommunityPostLikeDeleteManyArgs = {
    where?: CommunityPostLikeWhereInput
  }


  /**
   * CommunityPostLike without action
   */
  export type CommunityPostLikeArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
  }



  /**
   * Model CommunitySubcomment
   */


  export type AggregateCommunitySubcomment = {
    count: CommunitySubcommentCountAggregateOutputType | null
    avg: CommunitySubcommentAvgAggregateOutputType | null
    sum: CommunitySubcommentSumAggregateOutputType | null
    min: CommunitySubcommentMinAggregateOutputType | null
    max: CommunitySubcommentMaxAggregateOutputType | null
  }

  export type CommunitySubcommentAvgAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
  }

  export type CommunitySubcommentSumAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
  }

  export type CommunitySubcommentMinAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
    randomNickname: string | null
    body: string | null
    subcommentedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunitySubcommentMaxAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
    randomNickname: string | null
    body: string | null
    subcommentedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunitySubcommentCountAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
    randomNickname: number | null
    body: number | null
    subcommentedAt: number | null
    isDeleted: number | null
    _all: number
  }


  export type CommunitySubcommentAvgAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
  }

  export type CommunitySubcommentSumAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
  }

  export type CommunitySubcommentMinAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    randomNickname?: true
    body?: true
    subcommentedAt?: true
    isDeleted?: true
  }

  export type CommunitySubcommentMaxAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    randomNickname?: true
    body?: true
    subcommentedAt?: true
    isDeleted?: true
  }

  export type CommunitySubcommentCountAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    randomNickname?: true
    body?: true
    subcommentedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type CommunitySubcommentAggregateArgs = {
    /**
     * Filter which CommunitySubcomment to aggregate.
    **/
    where?: CommunitySubcommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunitySubcomments to fetch.
    **/
    orderBy?: Enumerable<CommunitySubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunitySubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunitySubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunitySubcomments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunitySubcomments
    **/
    count?: true | CommunitySubcommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunitySubcommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunitySubcommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunitySubcommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunitySubcommentMaxAggregateInputType
  }

  export type GetCommunitySubcommentAggregateType<T extends CommunitySubcommentAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunitySubcomment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunitySubcomment[P]>
      : GetScalarType<T[P], AggregateCommunitySubcomment[P]>
  }



  export type CommunitySubcommentSelect = {
    id?: boolean
    userId?: boolean
    postId?: boolean
    commentId?: boolean
    randomNickname?: boolean
    body?: boolean
    subcommentedAt?: boolean
    isDeleted?: boolean
    communityComment?: boolean | CommunityCommentArgs
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
    reportSubcomments?: boolean | ReportSubcommentFindManyArgs
  }

  export type CommunitySubcommentInclude = {
    communityComment?: boolean | CommunityCommentArgs
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
    reportSubcomments?: boolean | ReportSubcommentFindManyArgs
  }

  export type CommunitySubcommentGetPayload<
    S extends boolean | null | undefined | CommunitySubcommentArgs,
    U = keyof S
      > = S extends true
        ? CommunitySubcomment
    : S extends undefined
    ? never
    : S extends CommunitySubcommentArgs | CommunitySubcommentFindManyArgs
    ?'include' extends U
    ? CommunitySubcomment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityComment'
        ? CommunityCommentGetPayload<S['include'][P]> :
        P extends 'communityPost'
        ? CommunityPostGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'reportSubcomments'
        ? Array < ReportSubcommentGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunitySubcomment ?CommunitySubcomment [P]
  : 
          P extends 'communityComment'
        ? CommunityCommentGetPayload<S['select'][P]> :
        P extends 'communityPost'
        ? CommunityPostGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'reportSubcomments'
        ? Array < ReportSubcommentGetPayload<S['select'][P]>>  : never
  } 
    : CommunitySubcomment
  : CommunitySubcomment


  type CommunitySubcommentCountArgs = Merge<
    Omit<CommunitySubcommentFindManyArgs, 'select' | 'include'> & {
      select?: CommunitySubcommentCountAggregateInputType | true
    }
  >

  export interface CommunitySubcommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunitySubcomment that matches the filter.
     * @param {CommunitySubcommentFindUniqueArgs} args - Arguments to find a CommunitySubcomment
     * @example
     * // Get one CommunitySubcomment
     * const communitySubcomment = await prisma.communitySubcomment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunitySubcommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunitySubcommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunitySubcomment'> extends True ? CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>> : CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment | null >, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T> | null >>

    /**
     * Find the first CommunitySubcomment that matches the filter.
     * @param {CommunitySubcommentFindFirstArgs} args - Arguments to find a CommunitySubcomment
     * @example
     * // Get one CommunitySubcomment
     * const communitySubcomment = await prisma.communitySubcomment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunitySubcommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunitySubcommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunitySubcomment'> extends True ? CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>> : CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment | null >, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T> | null >>

    /**
     * Find zero or more CommunitySubcomments that matches the filter.
     * @param {CommunitySubcommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunitySubcomments
     * const communitySubcomments = await prisma.communitySubcomment.findMany()
     * 
     * // Get first 10 CommunitySubcomments
     * const communitySubcomments = await prisma.communitySubcomment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communitySubcommentWithIdOnly = await prisma.communitySubcomment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunitySubcommentFindManyArgs>(
      args?: SelectSubset<T, CommunitySubcommentFindManyArgs>
    ): CheckSelect<T, Promise<Array<CommunitySubcomment>>, Promise<Array<CommunitySubcommentGetPayload<T>>>>

    /**
     * Create a CommunitySubcomment.
     * @param {CommunitySubcommentCreateArgs} args - Arguments to create a CommunitySubcomment.
     * @example
     * // Create one CommunitySubcomment
     * const CommunitySubcomment = await prisma.communitySubcomment.create({
     *   data: {
     *     // ... data to create a CommunitySubcomment
     *   }
     * })
     * 
    **/
    create<T extends CommunitySubcommentCreateArgs>(
      args: SelectSubset<T, CommunitySubcommentCreateArgs>
    ): CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>>

    /**
     * Delete a CommunitySubcomment.
     * @param {CommunitySubcommentDeleteArgs} args - Arguments to delete one CommunitySubcomment.
     * @example
     * // Delete one CommunitySubcomment
     * const CommunitySubcomment = await prisma.communitySubcomment.delete({
     *   where: {
     *     // ... filter to delete one CommunitySubcomment
     *   }
     * })
     * 
    **/
    delete<T extends CommunitySubcommentDeleteArgs>(
      args: SelectSubset<T, CommunitySubcommentDeleteArgs>
    ): CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>>

    /**
     * Update one CommunitySubcomment.
     * @param {CommunitySubcommentUpdateArgs} args - Arguments to update one CommunitySubcomment.
     * @example
     * // Update one CommunitySubcomment
     * const communitySubcomment = await prisma.communitySubcomment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunitySubcommentUpdateArgs>(
      args: SelectSubset<T, CommunitySubcommentUpdateArgs>
    ): CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>>

    /**
     * Delete zero or more CommunitySubcomments.
     * @param {CommunitySubcommentDeleteManyArgs} args - Arguments to filter CommunitySubcomments to delete.
     * @example
     * // Delete a few CommunitySubcomments
     * const { count } = await prisma.communitySubcomment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunitySubcommentDeleteManyArgs>(
      args?: SelectSubset<T, CommunitySubcommentDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CommunitySubcomments.
     * @param {CommunitySubcommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunitySubcomments
     * const communitySubcomment = await prisma.communitySubcomment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunitySubcommentUpdateManyArgs>(
      args: SelectSubset<T, CommunitySubcommentUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CommunitySubcomment.
     * @param {CommunitySubcommentUpsertArgs} args - Arguments to update or create a CommunitySubcomment.
     * @example
     * // Update or create a CommunitySubcomment
     * const communitySubcomment = await prisma.communitySubcomment.upsert({
     *   create: {
     *     // ... data to create a CommunitySubcomment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunitySubcomment we want to update
     *   }
     * })
    **/
    upsert<T extends CommunitySubcommentUpsertArgs>(
      args: SelectSubset<T, CommunitySubcommentUpsertArgs>
    ): CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>>

    /**
     * Count the number of CommunitySubcomments.
     * @param {CommunitySubcommentCountArgs} args - Arguments to filter CommunitySubcomments to count.
     * @example
     * // Count the number of CommunitySubcomments
     * const count = await prisma.communitySubcomment.count({
     *   where: {
     *     // ... the filter for the CommunitySubcomments we want to count
     *   }
     * })
    **/
    count<T extends CommunitySubcommentCountArgs>(
      args?: Subset<T, CommunitySubcommentCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunitySubcommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunitySubcomment.
     * @param {CommunitySubcommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunitySubcommentAggregateArgs>(args: Subset<T, CommunitySubcommentAggregateArgs>): Promise<GetCommunitySubcommentAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunitySubcomment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunitySubcommentClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityComment<T extends CommunityCommentArgs = {}>(args?: Subset<T, CommunityCommentArgs>): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment | null >, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T> | null >>;

    communityPost<T extends CommunityPostArgs = {}>(args?: Subset<T, CommunityPostArgs>): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    reportSubcomments<T extends ReportSubcommentFindManyArgs = {}>(args?: Subset<T, ReportSubcommentFindManyArgs>): CheckSelect<T, Promise<Array<ReportSubcomment>>, Promise<Array<ReportSubcommentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunitySubcomment findUnique
   */
  export type CommunitySubcommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * Throw an Error if a CommunitySubcomment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunitySubcomment to fetch.
    **/
    where: CommunitySubcommentWhereUniqueInput
  }


  /**
   * CommunitySubcomment findFirst
   */
  export type CommunitySubcommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * Throw an Error if a CommunitySubcomment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunitySubcomment to fetch.
    **/
    where?: CommunitySubcommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunitySubcomments to fetch.
    **/
    orderBy?: Enumerable<CommunitySubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunitySubcomments.
    **/
    cursor?: CommunitySubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunitySubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunitySubcomments.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CommunitySubcomments.
    **/
    distinct?: Enumerable<CommunitySubcommentScalarFieldEnum>
  }


  /**
   * CommunitySubcomment findMany
   */
  export type CommunitySubcommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * Filter, which CommunitySubcomments to fetch.
    **/
    where?: CommunitySubcommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CommunitySubcomments to fetch.
    **/
    orderBy?: Enumerable<CommunitySubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunitySubcomments.
    **/
    cursor?: CommunitySubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunitySubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunitySubcomments.
    **/
    skip?: number
    distinct?: Enumerable<CommunitySubcommentScalarFieldEnum>
  }


  /**
   * CommunitySubcomment create
   */
  export type CommunitySubcommentCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * The data needed to create a CommunitySubcomment.
    **/
    data: XOR<CommunitySubcommentUncheckedCreateInput, CommunitySubcommentCreateInput>
  }


  /**
   * CommunitySubcomment update
   */
  export type CommunitySubcommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * The data needed to update a CommunitySubcomment.
    **/
    data: XOR<CommunitySubcommentUncheckedUpdateInput, CommunitySubcommentUpdateInput>
    /**
     * Choose, which CommunitySubcomment to update.
    **/
    where: CommunitySubcommentWhereUniqueInput
  }


  /**
   * CommunitySubcomment updateMany
   */
  export type CommunitySubcommentUpdateManyArgs = {
    data: XOR<CommunitySubcommentUncheckedUpdateManyInput, CommunitySubcommentUpdateManyMutationInput>
    where?: CommunitySubcommentWhereInput
  }


  /**
   * CommunitySubcomment upsert
   */
  export type CommunitySubcommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * The filter to search for the CommunitySubcomment to update in case it exists.
    **/
    where: CommunitySubcommentWhereUniqueInput
    /**
     * In case the CommunitySubcomment found by the `where` argument doesn't exist, create a new CommunitySubcomment with this data.
    **/
    create: XOR<CommunitySubcommentUncheckedCreateInput, CommunitySubcommentCreateInput>
    /**
     * In case the CommunitySubcomment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunitySubcommentUncheckedUpdateInput, CommunitySubcommentUpdateInput>
  }


  /**
   * CommunitySubcomment delete
   */
  export type CommunitySubcommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * Filter which CommunitySubcomment to delete.
    **/
    where: CommunitySubcommentWhereUniqueInput
  }


  /**
   * CommunitySubcomment deleteMany
   */
  export type CommunitySubcommentDeleteManyArgs = {
    where?: CommunitySubcommentWhereInput
  }


  /**
   * CommunitySubcomment without action
   */
  export type CommunitySubcommentArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
  }



  /**
   * Model CoverageMajor
   */


  export type AggregateCoverageMajor = {
    count: CoverageMajorCountAggregateOutputType | null
    min: CoverageMajorMinAggregateOutputType | null
    max: CoverageMajorMaxAggregateOutputType | null
  }

  export type CoverageMajorMinAggregateOutputType = {
    coverageCollege: string | null
    name: string | null
    code: string | null
  }

  export type CoverageMajorMaxAggregateOutputType = {
    coverageCollege: string | null
    name: string | null
    code: string | null
  }

  export type CoverageMajorCountAggregateOutputType = {
    coverageCollege: number | null
    name: number | null
    code: number | null
    _all: number
  }


  export type CoverageMajorMinAggregateInputType = {
    coverageCollege?: true
    name?: true
    code?: true
  }

  export type CoverageMajorMaxAggregateInputType = {
    coverageCollege?: true
    name?: true
    code?: true
  }

  export type CoverageMajorCountAggregateInputType = {
    coverageCollege?: true
    name?: true
    code?: true
    _all?: true
  }

  export type CoverageMajorAggregateArgs = {
    /**
     * Filter which CoverageMajor to aggregate.
    **/
    where?: CoverageMajorWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CoverageMajors to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CoverageMajorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajors.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoverageMajors
    **/
    count?: true | CoverageMajorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CoverageMajorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CoverageMajorMaxAggregateInputType
  }

  export type GetCoverageMajorAggregateType<T extends CoverageMajorAggregateArgs> = {
    [P in keyof T & keyof AggregateCoverageMajor]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoverageMajor[P]>
      : GetScalarType<T[P], AggregateCoverageMajor[P]>
  }



  export type CoverageMajorSelect = {
    coverageCollege?: boolean
    name?: boolean
    code?: boolean
    coverageMajorLectures?: boolean | CoverageMajorLectureFindManyArgs
  }

  export type CoverageMajorInclude = {
    coverageMajorLectures?: boolean | CoverageMajorLectureFindManyArgs
  }

  export type CoverageMajorGetPayload<
    S extends boolean | null | undefined | CoverageMajorArgs,
    U = keyof S
      > = S extends true
        ? CoverageMajor
    : S extends undefined
    ? never
    : S extends CoverageMajorArgs | CoverageMajorFindManyArgs
    ?'include' extends U
    ? CoverageMajor  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'coverageMajorLectures'
        ? Array < CoverageMajorLectureGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CoverageMajor ?CoverageMajor [P]
  : 
          P extends 'coverageMajorLectures'
        ? Array < CoverageMajorLectureGetPayload<S['select'][P]>>  : never
  } 
    : CoverageMajor
  : CoverageMajor


  type CoverageMajorCountArgs = Merge<
    Omit<CoverageMajorFindManyArgs, 'select' | 'include'> & {
      select?: CoverageMajorCountAggregateInputType | true
    }
  >

  export interface CoverageMajorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CoverageMajor that matches the filter.
     * @param {CoverageMajorFindUniqueArgs} args - Arguments to find a CoverageMajor
     * @example
     * // Get one CoverageMajor
     * const coverageMajor = await prisma.coverageMajor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoverageMajorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CoverageMajorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CoverageMajor'> extends True ? CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>> : CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor | null >, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T> | null >>

    /**
     * Find the first CoverageMajor that matches the filter.
     * @param {CoverageMajorFindFirstArgs} args - Arguments to find a CoverageMajor
     * @example
     * // Get one CoverageMajor
     * const coverageMajor = await prisma.coverageMajor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoverageMajorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CoverageMajorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CoverageMajor'> extends True ? CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>> : CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor | null >, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T> | null >>

    /**
     * Find zero or more CoverageMajors that matches the filter.
     * @param {CoverageMajorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoverageMajors
     * const coverageMajors = await prisma.coverageMajor.findMany()
     * 
     * // Get first 10 CoverageMajors
     * const coverageMajors = await prisma.coverageMajor.findMany({ take: 10 })
     * 
     * // Only select the `coverageCollege`
     * const coverageMajorWithCoverageCollegeOnly = await prisma.coverageMajor.findMany({ select: { coverageCollege: true } })
     * 
    **/
    findMany<T extends CoverageMajorFindManyArgs>(
      args?: SelectSubset<T, CoverageMajorFindManyArgs>
    ): CheckSelect<T, Promise<Array<CoverageMajor>>, Promise<Array<CoverageMajorGetPayload<T>>>>

    /**
     * Create a CoverageMajor.
     * @param {CoverageMajorCreateArgs} args - Arguments to create a CoverageMajor.
     * @example
     * // Create one CoverageMajor
     * const CoverageMajor = await prisma.coverageMajor.create({
     *   data: {
     *     // ... data to create a CoverageMajor
     *   }
     * })
     * 
    **/
    create<T extends CoverageMajorCreateArgs>(
      args: SelectSubset<T, CoverageMajorCreateArgs>
    ): CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>>

    /**
     * Delete a CoverageMajor.
     * @param {CoverageMajorDeleteArgs} args - Arguments to delete one CoverageMajor.
     * @example
     * // Delete one CoverageMajor
     * const CoverageMajor = await prisma.coverageMajor.delete({
     *   where: {
     *     // ... filter to delete one CoverageMajor
     *   }
     * })
     * 
    **/
    delete<T extends CoverageMajorDeleteArgs>(
      args: SelectSubset<T, CoverageMajorDeleteArgs>
    ): CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>>

    /**
     * Update one CoverageMajor.
     * @param {CoverageMajorUpdateArgs} args - Arguments to update one CoverageMajor.
     * @example
     * // Update one CoverageMajor
     * const coverageMajor = await prisma.coverageMajor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoverageMajorUpdateArgs>(
      args: SelectSubset<T, CoverageMajorUpdateArgs>
    ): CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>>

    /**
     * Delete zero or more CoverageMajors.
     * @param {CoverageMajorDeleteManyArgs} args - Arguments to filter CoverageMajors to delete.
     * @example
     * // Delete a few CoverageMajors
     * const { count } = await prisma.coverageMajor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoverageMajorDeleteManyArgs>(
      args?: SelectSubset<T, CoverageMajorDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CoverageMajors.
     * @param {CoverageMajorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoverageMajors
     * const coverageMajor = await prisma.coverageMajor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoverageMajorUpdateManyArgs>(
      args: SelectSubset<T, CoverageMajorUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CoverageMajor.
     * @param {CoverageMajorUpsertArgs} args - Arguments to update or create a CoverageMajor.
     * @example
     * // Update or create a CoverageMajor
     * const coverageMajor = await prisma.coverageMajor.upsert({
     *   create: {
     *     // ... data to create a CoverageMajor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoverageMajor we want to update
     *   }
     * })
    **/
    upsert<T extends CoverageMajorUpsertArgs>(
      args: SelectSubset<T, CoverageMajorUpsertArgs>
    ): CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>>

    /**
     * Count the number of CoverageMajors.
     * @param {CoverageMajorCountArgs} args - Arguments to filter CoverageMajors to count.
     * @example
     * // Count the number of CoverageMajors
     * const count = await prisma.coverageMajor.count({
     *   where: {
     *     // ... the filter for the CoverageMajors we want to count
     *   }
     * })
    **/
    count<T extends CoverageMajorCountArgs>(
      args?: Subset<T, CoverageMajorCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoverageMajorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoverageMajor.
     * @param {CoverageMajorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoverageMajorAggregateArgs>(args: Subset<T, CoverageMajorAggregateArgs>): Promise<GetCoverageMajorAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CoverageMajor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CoverageMajorClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    coverageMajorLectures<T extends CoverageMajorLectureFindManyArgs = {}>(args?: Subset<T, CoverageMajorLectureFindManyArgs>): CheckSelect<T, Promise<Array<CoverageMajorLecture>>, Promise<Array<CoverageMajorLectureGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CoverageMajor findUnique
   */
  export type CoverageMajorFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * Throw an Error if a CoverageMajor can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CoverageMajor to fetch.
    **/
    where: CoverageMajorWhereUniqueInput
  }


  /**
   * CoverageMajor findFirst
   */
  export type CoverageMajorFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * Throw an Error if a CoverageMajor can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CoverageMajor to fetch.
    **/
    where?: CoverageMajorWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CoverageMajors to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoverageMajors.
    **/
    cursor?: CoverageMajorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajors.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CoverageMajors.
    **/
    distinct?: Enumerable<CoverageMajorScalarFieldEnum>
  }


  /**
   * CoverageMajor findMany
   */
  export type CoverageMajorFindManyArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * Filter, which CoverageMajors to fetch.
    **/
    where?: CoverageMajorWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CoverageMajors to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoverageMajors.
    **/
    cursor?: CoverageMajorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajors.
    **/
    skip?: number
    distinct?: Enumerable<CoverageMajorScalarFieldEnum>
  }


  /**
   * CoverageMajor create
   */
  export type CoverageMajorCreateArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * The data needed to create a CoverageMajor.
    **/
    data: XOR<CoverageMajorUncheckedCreateInput, CoverageMajorCreateInput>
  }


  /**
   * CoverageMajor update
   */
  export type CoverageMajorUpdateArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * The data needed to update a CoverageMajor.
    **/
    data: XOR<CoverageMajorUncheckedUpdateInput, CoverageMajorUpdateInput>
    /**
     * Choose, which CoverageMajor to update.
    **/
    where: CoverageMajorWhereUniqueInput
  }


  /**
   * CoverageMajor updateMany
   */
  export type CoverageMajorUpdateManyArgs = {
    data: XOR<CoverageMajorUncheckedUpdateManyInput, CoverageMajorUpdateManyMutationInput>
    where?: CoverageMajorWhereInput
  }


  /**
   * CoverageMajor upsert
   */
  export type CoverageMajorUpsertArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * The filter to search for the CoverageMajor to update in case it exists.
    **/
    where: CoverageMajorWhereUniqueInput
    /**
     * In case the CoverageMajor found by the `where` argument doesn't exist, create a new CoverageMajor with this data.
    **/
    create: XOR<CoverageMajorUncheckedCreateInput, CoverageMajorCreateInput>
    /**
     * In case the CoverageMajor was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CoverageMajorUncheckedUpdateInput, CoverageMajorUpdateInput>
  }


  /**
   * CoverageMajor delete
   */
  export type CoverageMajorDeleteArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * Filter which CoverageMajor to delete.
    **/
    where: CoverageMajorWhereUniqueInput
  }


  /**
   * CoverageMajor deleteMany
   */
  export type CoverageMajorDeleteManyArgs = {
    where?: CoverageMajorWhereInput
  }


  /**
   * CoverageMajor without action
   */
  export type CoverageMajorArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
  }



  /**
   * Model CoverageMajorLecture
   */


  export type AggregateCoverageMajorLecture = {
    count: CoverageMajorLectureCountAggregateOutputType | null
    min: CoverageMajorLectureMinAggregateOutputType | null
    max: CoverageMajorLectureMaxAggregateOutputType | null
  }

  export type CoverageMajorLectureMinAggregateOutputType = {
    lectureId: string | null
    majorCode: string | null
  }

  export type CoverageMajorLectureMaxAggregateOutputType = {
    lectureId: string | null
    majorCode: string | null
  }

  export type CoverageMajorLectureCountAggregateOutputType = {
    lectureId: number | null
    majorCode: number | null
    _all: number
  }


  export type CoverageMajorLectureMinAggregateInputType = {
    lectureId?: true
    majorCode?: true
  }

  export type CoverageMajorLectureMaxAggregateInputType = {
    lectureId?: true
    majorCode?: true
  }

  export type CoverageMajorLectureCountAggregateInputType = {
    lectureId?: true
    majorCode?: true
    _all?: true
  }

  export type CoverageMajorLectureAggregateArgs = {
    /**
     * Filter which CoverageMajorLecture to aggregate.
    **/
    where?: CoverageMajorLectureWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CoverageMajorLectures to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorLectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CoverageMajorLectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajorLectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajorLectures.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoverageMajorLectures
    **/
    count?: true | CoverageMajorLectureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CoverageMajorLectureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CoverageMajorLectureMaxAggregateInputType
  }

  export type GetCoverageMajorLectureAggregateType<T extends CoverageMajorLectureAggregateArgs> = {
    [P in keyof T & keyof AggregateCoverageMajorLecture]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoverageMajorLecture[P]>
      : GetScalarType<T[P], AggregateCoverageMajorLecture[P]>
  }



  export type CoverageMajorLectureSelect = {
    lectureId?: boolean
    majorCode?: boolean
    lecture?: boolean | LectureArgs
    coverageMajor?: boolean | CoverageMajorArgs
  }

  export type CoverageMajorLectureInclude = {
    lecture?: boolean | LectureArgs
    coverageMajor?: boolean | CoverageMajorArgs
  }

  export type CoverageMajorLectureGetPayload<
    S extends boolean | null | undefined | CoverageMajorLectureArgs,
    U = keyof S
      > = S extends true
        ? CoverageMajorLecture
    : S extends undefined
    ? never
    : S extends CoverageMajorLectureArgs | CoverageMajorLectureFindManyArgs
    ?'include' extends U
    ? CoverageMajorLecture  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'lecture'
        ? LectureGetPayload<S['include'][P]> :
        P extends 'coverageMajor'
        ? CoverageMajorGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CoverageMajorLecture ?CoverageMajorLecture [P]
  : 
          P extends 'lecture'
        ? LectureGetPayload<S['select'][P]> :
        P extends 'coverageMajor'
        ? CoverageMajorGetPayload<S['select'][P]> : never
  } 
    : CoverageMajorLecture
  : CoverageMajorLecture


  type CoverageMajorLectureCountArgs = Merge<
    Omit<CoverageMajorLectureFindManyArgs, 'select' | 'include'> & {
      select?: CoverageMajorLectureCountAggregateInputType | true
    }
  >

  export interface CoverageMajorLectureDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CoverageMajorLecture that matches the filter.
     * @param {CoverageMajorLectureFindUniqueArgs} args - Arguments to find a CoverageMajorLecture
     * @example
     * // Get one CoverageMajorLecture
     * const coverageMajorLecture = await prisma.coverageMajorLecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoverageMajorLectureFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CoverageMajorLectureFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CoverageMajorLecture'> extends True ? CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>> : CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture | null >, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T> | null >>

    /**
     * Find the first CoverageMajorLecture that matches the filter.
     * @param {CoverageMajorLectureFindFirstArgs} args - Arguments to find a CoverageMajorLecture
     * @example
     * // Get one CoverageMajorLecture
     * const coverageMajorLecture = await prisma.coverageMajorLecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoverageMajorLectureFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CoverageMajorLectureFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CoverageMajorLecture'> extends True ? CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>> : CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture | null >, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T> | null >>

    /**
     * Find zero or more CoverageMajorLectures that matches the filter.
     * @param {CoverageMajorLectureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoverageMajorLectures
     * const coverageMajorLectures = await prisma.coverageMajorLecture.findMany()
     * 
     * // Get first 10 CoverageMajorLectures
     * const coverageMajorLectures = await prisma.coverageMajorLecture.findMany({ take: 10 })
     * 
     * // Only select the `lectureId`
     * const coverageMajorLectureWithLectureIdOnly = await prisma.coverageMajorLecture.findMany({ select: { lectureId: true } })
     * 
    **/
    findMany<T extends CoverageMajorLectureFindManyArgs>(
      args?: SelectSubset<T, CoverageMajorLectureFindManyArgs>
    ): CheckSelect<T, Promise<Array<CoverageMajorLecture>>, Promise<Array<CoverageMajorLectureGetPayload<T>>>>

    /**
     * Create a CoverageMajorLecture.
     * @param {CoverageMajorLectureCreateArgs} args - Arguments to create a CoverageMajorLecture.
     * @example
     * // Create one CoverageMajorLecture
     * const CoverageMajorLecture = await prisma.coverageMajorLecture.create({
     *   data: {
     *     // ... data to create a CoverageMajorLecture
     *   }
     * })
     * 
    **/
    create<T extends CoverageMajorLectureCreateArgs>(
      args: SelectSubset<T, CoverageMajorLectureCreateArgs>
    ): CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>>

    /**
     * Delete a CoverageMajorLecture.
     * @param {CoverageMajorLectureDeleteArgs} args - Arguments to delete one CoverageMajorLecture.
     * @example
     * // Delete one CoverageMajorLecture
     * const CoverageMajorLecture = await prisma.coverageMajorLecture.delete({
     *   where: {
     *     // ... filter to delete one CoverageMajorLecture
     *   }
     * })
     * 
    **/
    delete<T extends CoverageMajorLectureDeleteArgs>(
      args: SelectSubset<T, CoverageMajorLectureDeleteArgs>
    ): CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>>

    /**
     * Update one CoverageMajorLecture.
     * @param {CoverageMajorLectureUpdateArgs} args - Arguments to update one CoverageMajorLecture.
     * @example
     * // Update one CoverageMajorLecture
     * const coverageMajorLecture = await prisma.coverageMajorLecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoverageMajorLectureUpdateArgs>(
      args: SelectSubset<T, CoverageMajorLectureUpdateArgs>
    ): CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>>

    /**
     * Delete zero or more CoverageMajorLectures.
     * @param {CoverageMajorLectureDeleteManyArgs} args - Arguments to filter CoverageMajorLectures to delete.
     * @example
     * // Delete a few CoverageMajorLectures
     * const { count } = await prisma.coverageMajorLecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoverageMajorLectureDeleteManyArgs>(
      args?: SelectSubset<T, CoverageMajorLectureDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more CoverageMajorLectures.
     * @param {CoverageMajorLectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoverageMajorLectures
     * const coverageMajorLecture = await prisma.coverageMajorLecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoverageMajorLectureUpdateManyArgs>(
      args: SelectSubset<T, CoverageMajorLectureUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one CoverageMajorLecture.
     * @param {CoverageMajorLectureUpsertArgs} args - Arguments to update or create a CoverageMajorLecture.
     * @example
     * // Update or create a CoverageMajorLecture
     * const coverageMajorLecture = await prisma.coverageMajorLecture.upsert({
     *   create: {
     *     // ... data to create a CoverageMajorLecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoverageMajorLecture we want to update
     *   }
     * })
    **/
    upsert<T extends CoverageMajorLectureUpsertArgs>(
      args: SelectSubset<T, CoverageMajorLectureUpsertArgs>
    ): CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>>

    /**
     * Count the number of CoverageMajorLectures.
     * @param {CoverageMajorLectureCountArgs} args - Arguments to filter CoverageMajorLectures to count.
     * @example
     * // Count the number of CoverageMajorLectures
     * const count = await prisma.coverageMajorLecture.count({
     *   where: {
     *     // ... the filter for the CoverageMajorLectures we want to count
     *   }
     * })
    **/
    count<T extends CoverageMajorLectureCountArgs>(
      args?: Subset<T, CoverageMajorLectureCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoverageMajorLectureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoverageMajorLecture.
     * @param {CoverageMajorLectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoverageMajorLectureAggregateArgs>(args: Subset<T, CoverageMajorLectureAggregateArgs>): Promise<GetCoverageMajorLectureAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CoverageMajorLecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CoverageMajorLectureClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    lecture<T extends LectureArgs = {}>(args?: Subset<T, LectureArgs>): CheckSelect<T, Prisma__LectureClient<Lecture | null >, Prisma__LectureClient<LectureGetPayload<T> | null >>;

    coverageMajor<T extends CoverageMajorArgs = {}>(args?: Subset<T, CoverageMajorArgs>): CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor | null >, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CoverageMajorLecture findUnique
   */
  export type CoverageMajorLectureFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * Throw an Error if a CoverageMajorLecture can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CoverageMajorLecture to fetch.
    **/
    where: CoverageMajorLectureWhereUniqueInput
  }


  /**
   * CoverageMajorLecture findFirst
   */
  export type CoverageMajorLectureFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * Throw an Error if a CoverageMajorLecture can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CoverageMajorLecture to fetch.
    **/
    where?: CoverageMajorLectureWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CoverageMajorLectures to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorLectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoverageMajorLectures.
    **/
    cursor?: CoverageMajorLectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajorLectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajorLectures.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of CoverageMajorLectures.
    **/
    distinct?: Enumerable<CoverageMajorLectureScalarFieldEnum>
  }


  /**
   * CoverageMajorLecture findMany
   */
  export type CoverageMajorLectureFindManyArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * Filter, which CoverageMajorLectures to fetch.
    **/
    where?: CoverageMajorLectureWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of CoverageMajorLectures to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorLectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoverageMajorLectures.
    **/
    cursor?: CoverageMajorLectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajorLectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajorLectures.
    **/
    skip?: number
    distinct?: Enumerable<CoverageMajorLectureScalarFieldEnum>
  }


  /**
   * CoverageMajorLecture create
   */
  export type CoverageMajorLectureCreateArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * The data needed to create a CoverageMajorLecture.
    **/
    data: XOR<CoverageMajorLectureUncheckedCreateInput, CoverageMajorLectureCreateInput>
  }


  /**
   * CoverageMajorLecture update
   */
  export type CoverageMajorLectureUpdateArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * The data needed to update a CoverageMajorLecture.
    **/
    data: XOR<CoverageMajorLectureUncheckedUpdateInput, CoverageMajorLectureUpdateInput>
    /**
     * Choose, which CoverageMajorLecture to update.
    **/
    where: CoverageMajorLectureWhereUniqueInput
  }


  /**
   * CoverageMajorLecture updateMany
   */
  export type CoverageMajorLectureUpdateManyArgs = {
    data: XOR<CoverageMajorLectureUncheckedUpdateManyInput, CoverageMajorLectureUpdateManyMutationInput>
    where?: CoverageMajorLectureWhereInput
  }


  /**
   * CoverageMajorLecture upsert
   */
  export type CoverageMajorLectureUpsertArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * The filter to search for the CoverageMajorLecture to update in case it exists.
    **/
    where: CoverageMajorLectureWhereUniqueInput
    /**
     * In case the CoverageMajorLecture found by the `where` argument doesn't exist, create a new CoverageMajorLecture with this data.
    **/
    create: XOR<CoverageMajorLectureUncheckedCreateInput, CoverageMajorLectureCreateInput>
    /**
     * In case the CoverageMajorLecture was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CoverageMajorLectureUncheckedUpdateInput, CoverageMajorLectureUpdateInput>
  }


  /**
   * CoverageMajorLecture delete
   */
  export type CoverageMajorLectureDeleteArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * Filter which CoverageMajorLecture to delete.
    **/
    where: CoverageMajorLectureWhereUniqueInput
  }


  /**
   * CoverageMajorLecture deleteMany
   */
  export type CoverageMajorLectureDeleteManyArgs = {
    where?: CoverageMajorLectureWhereInput
  }


  /**
   * CoverageMajorLecture without action
   */
  export type CoverageMajorLectureArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
  }



  /**
   * Model Lecture
   */


  export type AggregateLecture = {
    count: LectureCountAggregateOutputType | null
    avg: LectureAvgAggregateOutputType | null
    sum: LectureSumAggregateOutputType | null
    min: LectureMinAggregateOutputType | null
    max: LectureMaxAggregateOutputType | null
  }

  export type LectureAvgAggregateOutputType = {
    year: number | null
    grade: number | null
    credit: number | null
    building: number | null
  }

  export type LectureSumAggregateOutputType = {
    year: number | null
    grade: number | null
    credit: number | null
    building: number | null
  }

  export type LectureMinAggregateOutputType = {
    id: string | null
    year: number | null
    semester: string | null
    campus: string | null
    college: string | null
    major: string | null
    grade: number | null
    credit: number | null
    course: string | null
    section: string | null
    code: string | null
    name: string | null
    professor: string | null
    schedule: string | null
    building: number | null
    room: string | null
    note: string | null
  }

  export type LectureMaxAggregateOutputType = {
    id: string | null
    year: number | null
    semester: string | null
    campus: string | null
    college: string | null
    major: string | null
    grade: number | null
    credit: number | null
    course: string | null
    section: string | null
    code: string | null
    name: string | null
    professor: string | null
    schedule: string | null
    building: number | null
    room: string | null
    note: string | null
  }

  export type LectureCountAggregateOutputType = {
    id: number | null
    year: number | null
    semester: number | null
    campus: number | null
    college: number | null
    major: number | null
    grade: number | null
    credit: number | null
    course: number | null
    section: number | null
    code: number | null
    name: number | null
    professor: number | null
    schedule: number | null
    building: number | null
    room: number | null
    note: number | null
    _all: number
  }


  export type LectureAvgAggregateInputType = {
    year?: true
    grade?: true
    credit?: true
    building?: true
  }

  export type LectureSumAggregateInputType = {
    year?: true
    grade?: true
    credit?: true
    building?: true
  }

  export type LectureMinAggregateInputType = {
    id?: true
    year?: true
    semester?: true
    campus?: true
    college?: true
    major?: true
    grade?: true
    credit?: true
    course?: true
    section?: true
    code?: true
    name?: true
    professor?: true
    schedule?: true
    building?: true
    room?: true
    note?: true
  }

  export type LectureMaxAggregateInputType = {
    id?: true
    year?: true
    semester?: true
    campus?: true
    college?: true
    major?: true
    grade?: true
    credit?: true
    course?: true
    section?: true
    code?: true
    name?: true
    professor?: true
    schedule?: true
    building?: true
    room?: true
    note?: true
  }

  export type LectureCountAggregateInputType = {
    id?: true
    year?: true
    semester?: true
    campus?: true
    college?: true
    major?: true
    grade?: true
    credit?: true
    course?: true
    section?: true
    code?: true
    name?: true
    professor?: true
    schedule?: true
    building?: true
    room?: true
    note?: true
    _all?: true
  }

  export type LectureAggregateArgs = {
    /**
     * Filter which Lecture to aggregate.
    **/
    where?: LectureWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Lectures to fetch.
    **/
    orderBy?: Enumerable<LectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lectures
    **/
    count?: true | LectureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: LectureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: LectureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: LectureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: LectureMaxAggregateInputType
  }

  export type GetLectureAggregateType<T extends LectureAggregateArgs> = {
    [P in keyof T & keyof AggregateLecture]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecture[P]>
      : GetScalarType<T[P], AggregateLecture[P]>
  }



  export type LectureSelect = {
    id?: boolean
    year?: boolean
    semester?: boolean
    campus?: boolean
    college?: boolean
    major?: boolean
    grade?: boolean
    credit?: boolean
    course?: boolean
    section?: boolean
    code?: boolean
    name?: boolean
    professor?: boolean
    schedule?: boolean
    building?: boolean
    room?: boolean
    note?: boolean
    coverageMajorLectures?: boolean | CoverageMajorLectureFindManyArgs
    periods?: boolean | PeriodFindManyArgs
  }

  export type LectureInclude = {
    coverageMajorLectures?: boolean | CoverageMajorLectureFindManyArgs
    periods?: boolean | PeriodFindManyArgs
  }

  export type LectureGetPayload<
    S extends boolean | null | undefined | LectureArgs,
    U = keyof S
      > = S extends true
        ? Lecture
    : S extends undefined
    ? never
    : S extends LectureArgs | LectureFindManyArgs
    ?'include' extends U
    ? Lecture  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'coverageMajorLectures'
        ? Array < CoverageMajorLectureGetPayload<S['include'][P]>>  :
        P extends 'periods'
        ? Array < PeriodGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Lecture ?Lecture [P]
  : 
          P extends 'coverageMajorLectures'
        ? Array < CoverageMajorLectureGetPayload<S['select'][P]>>  :
        P extends 'periods'
        ? Array < PeriodGetPayload<S['select'][P]>>  : never
  } 
    : Lecture
  : Lecture


  type LectureCountArgs = Merge<
    Omit<LectureFindManyArgs, 'select' | 'include'> & {
      select?: LectureCountAggregateInputType | true
    }
  >

  export interface LectureDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Lecture that matches the filter.
     * @param {LectureFindUniqueArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LectureFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LectureFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Lecture'> extends True ? CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>> : CheckSelect<T, Prisma__LectureClient<Lecture | null >, Prisma__LectureClient<LectureGetPayload<T> | null >>

    /**
     * Find the first Lecture that matches the filter.
     * @param {LectureFindFirstArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LectureFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LectureFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Lecture'> extends True ? CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>> : CheckSelect<T, Prisma__LectureClient<Lecture | null >, Prisma__LectureClient<LectureGetPayload<T> | null >>

    /**
     * Find zero or more Lectures that matches the filter.
     * @param {LectureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lectures
     * const lectures = await prisma.lecture.findMany()
     * 
     * // Get first 10 Lectures
     * const lectures = await prisma.lecture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lectureWithIdOnly = await prisma.lecture.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LectureFindManyArgs>(
      args?: SelectSubset<T, LectureFindManyArgs>
    ): CheckSelect<T, Promise<Array<Lecture>>, Promise<Array<LectureGetPayload<T>>>>

    /**
     * Create a Lecture.
     * @param {LectureCreateArgs} args - Arguments to create a Lecture.
     * @example
     * // Create one Lecture
     * const Lecture = await prisma.lecture.create({
     *   data: {
     *     // ... data to create a Lecture
     *   }
     * })
     * 
    **/
    create<T extends LectureCreateArgs>(
      args: SelectSubset<T, LectureCreateArgs>
    ): CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>>

    /**
     * Delete a Lecture.
     * @param {LectureDeleteArgs} args - Arguments to delete one Lecture.
     * @example
     * // Delete one Lecture
     * const Lecture = await prisma.lecture.delete({
     *   where: {
     *     // ... filter to delete one Lecture
     *   }
     * })
     * 
    **/
    delete<T extends LectureDeleteArgs>(
      args: SelectSubset<T, LectureDeleteArgs>
    ): CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>>

    /**
     * Update one Lecture.
     * @param {LectureUpdateArgs} args - Arguments to update one Lecture.
     * @example
     * // Update one Lecture
     * const lecture = await prisma.lecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LectureUpdateArgs>(
      args: SelectSubset<T, LectureUpdateArgs>
    ): CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>>

    /**
     * Delete zero or more Lectures.
     * @param {LectureDeleteManyArgs} args - Arguments to filter Lectures to delete.
     * @example
     * // Delete a few Lectures
     * const { count } = await prisma.lecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LectureDeleteManyArgs>(
      args?: SelectSubset<T, LectureDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Lectures.
     * @param {LectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lectures
     * const lecture = await prisma.lecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LectureUpdateManyArgs>(
      args: SelectSubset<T, LectureUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Lecture.
     * @param {LectureUpsertArgs} args - Arguments to update or create a Lecture.
     * @example
     * // Update or create a Lecture
     * const lecture = await prisma.lecture.upsert({
     *   create: {
     *     // ... data to create a Lecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecture we want to update
     *   }
     * })
    **/
    upsert<T extends LectureUpsertArgs>(
      args: SelectSubset<T, LectureUpsertArgs>
    ): CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>>

    /**
     * Count the number of Lectures.
     * @param {LectureCountArgs} args - Arguments to filter Lectures to count.
     * @example
     * // Count the number of Lectures
     * const count = await prisma.lecture.count({
     *   where: {
     *     // ... the filter for the Lectures we want to count
     *   }
     * })
    **/
    count<T extends LectureCountArgs>(
      args?: Subset<T, LectureCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LectureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lecture.
     * @param {LectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LectureAggregateArgs>(args: Subset<T, LectureAggregateArgs>): Promise<GetLectureAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Lecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LectureClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    coverageMajorLectures<T extends CoverageMajorLectureFindManyArgs = {}>(args?: Subset<T, CoverageMajorLectureFindManyArgs>): CheckSelect<T, Promise<Array<CoverageMajorLecture>>, Promise<Array<CoverageMajorLectureGetPayload<T>>>>;

    periods<T extends PeriodFindManyArgs = {}>(args?: Subset<T, PeriodFindManyArgs>): CheckSelect<T, Promise<Array<Period>>, Promise<Array<PeriodGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Lecture findUnique
   */
  export type LectureFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * Throw an Error if a Lecture can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Lecture to fetch.
    **/
    where: LectureWhereUniqueInput
  }


  /**
   * Lecture findFirst
   */
  export type LectureFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * Throw an Error if a Lecture can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Lecture to fetch.
    **/
    where?: LectureWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Lectures to fetch.
    **/
    orderBy?: Enumerable<LectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lectures.
    **/
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Lectures.
    **/
    distinct?: Enumerable<LectureScalarFieldEnum>
  }


  /**
   * Lecture findMany
   */
  export type LectureFindManyArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * Filter, which Lectures to fetch.
    **/
    where?: LectureWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Lectures to fetch.
    **/
    orderBy?: Enumerable<LectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lectures.
    **/
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
    **/
    skip?: number
    distinct?: Enumerable<LectureScalarFieldEnum>
  }


  /**
   * Lecture create
   */
  export type LectureCreateArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * The data needed to create a Lecture.
    **/
    data: XOR<LectureUncheckedCreateInput, LectureCreateInput>
  }


  /**
   * Lecture update
   */
  export type LectureUpdateArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * The data needed to update a Lecture.
    **/
    data: XOR<LectureUncheckedUpdateInput, LectureUpdateInput>
    /**
     * Choose, which Lecture to update.
    **/
    where: LectureWhereUniqueInput
  }


  /**
   * Lecture updateMany
   */
  export type LectureUpdateManyArgs = {
    data: XOR<LectureUncheckedUpdateManyInput, LectureUpdateManyMutationInput>
    where?: LectureWhereInput
  }


  /**
   * Lecture upsert
   */
  export type LectureUpsertArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * The filter to search for the Lecture to update in case it exists.
    **/
    where: LectureWhereUniqueInput
    /**
     * In case the Lecture found by the `where` argument doesn't exist, create a new Lecture with this data.
    **/
    create: XOR<LectureUncheckedCreateInput, LectureCreateInput>
    /**
     * In case the Lecture was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<LectureUncheckedUpdateInput, LectureUpdateInput>
  }


  /**
   * Lecture delete
   */
  export type LectureDeleteArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * Filter which Lecture to delete.
    **/
    where: LectureWhereUniqueInput
  }


  /**
   * Lecture deleteMany
   */
  export type LectureDeleteManyArgs = {
    where?: LectureWhereInput
  }


  /**
   * Lecture without action
   */
  export type LectureArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
  }



  /**
   * Model LiveChat
   */


  export type AggregateLiveChat = {
    count: LiveChatCountAggregateOutputType | null
    avg: LiveChatAvgAggregateOutputType | null
    sum: LiveChatSumAggregateOutputType | null
    min: LiveChatMinAggregateOutputType | null
    max: LiveChatMaxAggregateOutputType | null
  }

  export type LiveChatAvgAggregateOutputType = {
    id: number
    userId: number
  }

  export type LiveChatSumAggregateOutputType = {
    id: number
    userId: number
  }

  export type LiveChatMinAggregateOutputType = {
    id: number
    message: string | null
    createdAt: Date | null
    userId: number
    randomNickname: string | null
  }

  export type LiveChatMaxAggregateOutputType = {
    id: number
    message: string | null
    createdAt: Date | null
    userId: number
    randomNickname: string | null
  }

  export type LiveChatCountAggregateOutputType = {
    id: number
    message: number | null
    createdAt: number | null
    userId: number
    randomNickname: number | null
    _all: number
  }


  export type LiveChatAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LiveChatSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LiveChatMinAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    userId?: true
    randomNickname?: true
  }

  export type LiveChatMaxAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    userId?: true
    randomNickname?: true
  }

  export type LiveChatCountAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    userId?: true
    randomNickname?: true
    _all?: true
  }

  export type LiveChatAggregateArgs = {
    /**
     * Filter which LiveChat to aggregate.
    **/
    where?: LiveChatWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of LiveChats to fetch.
    **/
    orderBy?: Enumerable<LiveChatOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: LiveChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveChats from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveChats.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiveChats
    **/
    count?: true | LiveChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: LiveChatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: LiveChatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: LiveChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: LiveChatMaxAggregateInputType
  }

  export type GetLiveChatAggregateType<T extends LiveChatAggregateArgs> = {
    [P in keyof T & keyof AggregateLiveChat]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiveChat[P]>
      : GetScalarType<T[P], AggregateLiveChat[P]>
  }



  export type LiveChatSelect = {
    id?: boolean
    message?: boolean
    createdAt?: boolean
    userId?: boolean
    randomNickname?: boolean
    user?: boolean | UserArgs
  }

  export type LiveChatInclude = {
    user?: boolean | UserArgs
  }

  export type LiveChatGetPayload<
    S extends boolean | null | undefined | LiveChatArgs,
    U = keyof S
      > = S extends true
        ? LiveChat
    : S extends undefined
    ? never
    : S extends LiveChatArgs | LiveChatFindManyArgs
    ?'include' extends U
    ? LiveChat  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LiveChat ?LiveChat [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : LiveChat
  : LiveChat


  type LiveChatCountArgs = Merge<
    Omit<LiveChatFindManyArgs, 'select' | 'include'> & {
      select?: LiveChatCountAggregateInputType | true
    }
  >

  export interface LiveChatDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one LiveChat that matches the filter.
     * @param {LiveChatFindUniqueArgs} args - Arguments to find a LiveChat
     * @example
     * // Get one LiveChat
     * const liveChat = await prisma.liveChat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LiveChatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LiveChatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LiveChat'> extends True ? CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>> : CheckSelect<T, Prisma__LiveChatClient<LiveChat | null >, Prisma__LiveChatClient<LiveChatGetPayload<T> | null >>

    /**
     * Find the first LiveChat that matches the filter.
     * @param {LiveChatFindFirstArgs} args - Arguments to find a LiveChat
     * @example
     * // Get one LiveChat
     * const liveChat = await prisma.liveChat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LiveChatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LiveChatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LiveChat'> extends True ? CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>> : CheckSelect<T, Prisma__LiveChatClient<LiveChat | null >, Prisma__LiveChatClient<LiveChatGetPayload<T> | null >>

    /**
     * Find zero or more LiveChats that matches the filter.
     * @param {LiveChatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiveChats
     * const liveChats = await prisma.liveChat.findMany()
     * 
     * // Get first 10 LiveChats
     * const liveChats = await prisma.liveChat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liveChatWithIdOnly = await prisma.liveChat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LiveChatFindManyArgs>(
      args?: SelectSubset<T, LiveChatFindManyArgs>
    ): CheckSelect<T, Promise<Array<LiveChat>>, Promise<Array<LiveChatGetPayload<T>>>>

    /**
     * Create a LiveChat.
     * @param {LiveChatCreateArgs} args - Arguments to create a LiveChat.
     * @example
     * // Create one LiveChat
     * const LiveChat = await prisma.liveChat.create({
     *   data: {
     *     // ... data to create a LiveChat
     *   }
     * })
     * 
    **/
    create<T extends LiveChatCreateArgs>(
      args: SelectSubset<T, LiveChatCreateArgs>
    ): CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>>

    /**
     * Delete a LiveChat.
     * @param {LiveChatDeleteArgs} args - Arguments to delete one LiveChat.
     * @example
     * // Delete one LiveChat
     * const LiveChat = await prisma.liveChat.delete({
     *   where: {
     *     // ... filter to delete one LiveChat
     *   }
     * })
     * 
    **/
    delete<T extends LiveChatDeleteArgs>(
      args: SelectSubset<T, LiveChatDeleteArgs>
    ): CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>>

    /**
     * Update one LiveChat.
     * @param {LiveChatUpdateArgs} args - Arguments to update one LiveChat.
     * @example
     * // Update one LiveChat
     * const liveChat = await prisma.liveChat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LiveChatUpdateArgs>(
      args: SelectSubset<T, LiveChatUpdateArgs>
    ): CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>>

    /**
     * Delete zero or more LiveChats.
     * @param {LiveChatDeleteManyArgs} args - Arguments to filter LiveChats to delete.
     * @example
     * // Delete a few LiveChats
     * const { count } = await prisma.liveChat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LiveChatDeleteManyArgs>(
      args?: SelectSubset<T, LiveChatDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more LiveChats.
     * @param {LiveChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiveChats
     * const liveChat = await prisma.liveChat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LiveChatUpdateManyArgs>(
      args: SelectSubset<T, LiveChatUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one LiveChat.
     * @param {LiveChatUpsertArgs} args - Arguments to update or create a LiveChat.
     * @example
     * // Update or create a LiveChat
     * const liveChat = await prisma.liveChat.upsert({
     *   create: {
     *     // ... data to create a LiveChat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiveChat we want to update
     *   }
     * })
    **/
    upsert<T extends LiveChatUpsertArgs>(
      args: SelectSubset<T, LiveChatUpsertArgs>
    ): CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>>

    /**
     * Count the number of LiveChats.
     * @param {LiveChatCountArgs} args - Arguments to filter LiveChats to count.
     * @example
     * // Count the number of LiveChats
     * const count = await prisma.liveChat.count({
     *   where: {
     *     // ... the filter for the LiveChats we want to count
     *   }
     * })
    **/
    count<T extends LiveChatCountArgs>(
      args?: Subset<T, LiveChatCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiveChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiveChat.
     * @param {LiveChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiveChatAggregateArgs>(args: Subset<T, LiveChatAggregateArgs>): Promise<GetLiveChatAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for LiveChat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LiveChatClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * LiveChat findUnique
   */
  export type LiveChatFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * Throw an Error if a LiveChat can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LiveChat to fetch.
    **/
    where: LiveChatWhereUniqueInput
  }


  /**
   * LiveChat findFirst
   */
  export type LiveChatFindFirstArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * Throw an Error if a LiveChat can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LiveChat to fetch.
    **/
    where?: LiveChatWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of LiveChats to fetch.
    **/
    orderBy?: Enumerable<LiveChatOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiveChats.
    **/
    cursor?: LiveChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveChats from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveChats.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of LiveChats.
    **/
    distinct?: Enumerable<LiveChatScalarFieldEnum>
  }


  /**
   * LiveChat findMany
   */
  export type LiveChatFindManyArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * Filter, which LiveChats to fetch.
    **/
    where?: LiveChatWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of LiveChats to fetch.
    **/
    orderBy?: Enumerable<LiveChatOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiveChats.
    **/
    cursor?: LiveChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveChats from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveChats.
    **/
    skip?: number
    distinct?: Enumerable<LiveChatScalarFieldEnum>
  }


  /**
   * LiveChat create
   */
  export type LiveChatCreateArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * The data needed to create a LiveChat.
    **/
    data: XOR<LiveChatUncheckedCreateInput, LiveChatCreateInput>
  }


  /**
   * LiveChat update
   */
  export type LiveChatUpdateArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * The data needed to update a LiveChat.
    **/
    data: XOR<LiveChatUncheckedUpdateInput, LiveChatUpdateInput>
    /**
     * Choose, which LiveChat to update.
    **/
    where: LiveChatWhereUniqueInput
  }


  /**
   * LiveChat updateMany
   */
  export type LiveChatUpdateManyArgs = {
    data: XOR<LiveChatUncheckedUpdateManyInput, LiveChatUpdateManyMutationInput>
    where?: LiveChatWhereInput
  }


  /**
   * LiveChat upsert
   */
  export type LiveChatUpsertArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * The filter to search for the LiveChat to update in case it exists.
    **/
    where: LiveChatWhereUniqueInput
    /**
     * In case the LiveChat found by the `where` argument doesn't exist, create a new LiveChat with this data.
    **/
    create: XOR<LiveChatUncheckedCreateInput, LiveChatCreateInput>
    /**
     * In case the LiveChat was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<LiveChatUncheckedUpdateInput, LiveChatUpdateInput>
  }


  /**
   * LiveChat delete
   */
  export type LiveChatDeleteArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * Filter which LiveChat to delete.
    **/
    where: LiveChatWhereUniqueInput
  }


  /**
   * LiveChat deleteMany
   */
  export type LiveChatDeleteManyArgs = {
    where?: LiveChatWhereInput
  }


  /**
   * LiveChat without action
   */
  export type LiveChatArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
  }



  /**
   * Model NoticeNotificationsSubscription
   */


  export type AggregateNoticeNotificationsSubscription = {
    count: NoticeNotificationsSubscriptionCountAggregateOutputType | null
    avg: NoticeNotificationsSubscriptionAvgAggregateOutputType | null
    sum: NoticeNotificationsSubscriptionSumAggregateOutputType | null
    min: NoticeNotificationsSubscriptionMinAggregateOutputType | null
    max: NoticeNotificationsSubscriptionMaxAggregateOutputType | null
  }

  export type NoticeNotificationsSubscriptionAvgAggregateOutputType = {
    id: number
    userId: number
  }

  export type NoticeNotificationsSubscriptionSumAggregateOutputType = {
    id: number
    userId: number
  }

  export type NoticeNotificationsSubscriptionMinAggregateOutputType = {
    id: number
    userId: number
    noticeKey: string | null
    subscribedAt: Date | null
  }

  export type NoticeNotificationsSubscriptionMaxAggregateOutputType = {
    id: number
    userId: number
    noticeKey: string | null
    subscribedAt: Date | null
  }

  export type NoticeNotificationsSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    noticeKey: number | null
    subscribedAt: number | null
    _all: number
  }


  export type NoticeNotificationsSubscriptionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NoticeNotificationsSubscriptionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NoticeNotificationsSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    noticeKey?: true
    subscribedAt?: true
  }

  export type NoticeNotificationsSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    noticeKey?: true
    subscribedAt?: true
  }

  export type NoticeNotificationsSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    noticeKey?: true
    subscribedAt?: true
    _all?: true
  }

  export type NoticeNotificationsSubscriptionAggregateArgs = {
    /**
     * Filter which NoticeNotificationsSubscription to aggregate.
    **/
    where?: NoticeNotificationsSubscriptionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of NoticeNotificationsSubscriptions to fetch.
    **/
    orderBy?: Enumerable<NoticeNotificationsSubscriptionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: NoticeNotificationsSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoticeNotificationsSubscriptions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoticeNotificationsSubscriptions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoticeNotificationsSubscriptions
    **/
    count?: true | NoticeNotificationsSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: NoticeNotificationsSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: NoticeNotificationsSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: NoticeNotificationsSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: NoticeNotificationsSubscriptionMaxAggregateInputType
  }

  export type GetNoticeNotificationsSubscriptionAggregateType<T extends NoticeNotificationsSubscriptionAggregateArgs> = {
    [P in keyof T & keyof AggregateNoticeNotificationsSubscription]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoticeNotificationsSubscription[P]>
      : GetScalarType<T[P], AggregateNoticeNotificationsSubscription[P]>
  }



  export type NoticeNotificationsSubscriptionSelect = {
    id?: boolean
    userId?: boolean
    noticeKey?: boolean
    subscribedAt?: boolean
    user?: boolean | UserArgs
  }

  export type NoticeNotificationsSubscriptionInclude = {
    user?: boolean | UserArgs
  }

  export type NoticeNotificationsSubscriptionGetPayload<
    S extends boolean | null | undefined | NoticeNotificationsSubscriptionArgs,
    U = keyof S
      > = S extends true
        ? NoticeNotificationsSubscription
    : S extends undefined
    ? never
    : S extends NoticeNotificationsSubscriptionArgs | NoticeNotificationsSubscriptionFindManyArgs
    ?'include' extends U
    ? NoticeNotificationsSubscription  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof NoticeNotificationsSubscription ?NoticeNotificationsSubscription [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : NoticeNotificationsSubscription
  : NoticeNotificationsSubscription


  type NoticeNotificationsSubscriptionCountArgs = Merge<
    Omit<NoticeNotificationsSubscriptionFindManyArgs, 'select' | 'include'> & {
      select?: NoticeNotificationsSubscriptionCountAggregateInputType | true
    }
  >

  export interface NoticeNotificationsSubscriptionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one NoticeNotificationsSubscription that matches the filter.
     * @param {NoticeNotificationsSubscriptionFindUniqueArgs} args - Arguments to find a NoticeNotificationsSubscription
     * @example
     * // Get one NoticeNotificationsSubscription
     * const noticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NoticeNotificationsSubscriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NoticeNotificationsSubscription'> extends True ? CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription | null >, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T> | null >>

    /**
     * Find the first NoticeNotificationsSubscription that matches the filter.
     * @param {NoticeNotificationsSubscriptionFindFirstArgs} args - Arguments to find a NoticeNotificationsSubscription
     * @example
     * // Get one NoticeNotificationsSubscription
     * const noticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NoticeNotificationsSubscriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NoticeNotificationsSubscriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NoticeNotificationsSubscription'> extends True ? CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription | null >, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T> | null >>

    /**
     * Find zero or more NoticeNotificationsSubscriptions that matches the filter.
     * @param {NoticeNotificationsSubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoticeNotificationsSubscriptions
     * const noticeNotificationsSubscriptions = await prisma.noticeNotificationsSubscription.findMany()
     * 
     * // Get first 10 NoticeNotificationsSubscriptions
     * const noticeNotificationsSubscriptions = await prisma.noticeNotificationsSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeNotificationsSubscriptionWithIdOnly = await prisma.noticeNotificationsSubscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NoticeNotificationsSubscriptionFindManyArgs>(
      args?: SelectSubset<T, NoticeNotificationsSubscriptionFindManyArgs>
    ): CheckSelect<T, Promise<Array<NoticeNotificationsSubscription>>, Promise<Array<NoticeNotificationsSubscriptionGetPayload<T>>>>

    /**
     * Create a NoticeNotificationsSubscription.
     * @param {NoticeNotificationsSubscriptionCreateArgs} args - Arguments to create a NoticeNotificationsSubscription.
     * @example
     * // Create one NoticeNotificationsSubscription
     * const NoticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.create({
     *   data: {
     *     // ... data to create a NoticeNotificationsSubscription
     *   }
     * })
     * 
    **/
    create<T extends NoticeNotificationsSubscriptionCreateArgs>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionCreateArgs>
    ): CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>>

    /**
     * Delete a NoticeNotificationsSubscription.
     * @param {NoticeNotificationsSubscriptionDeleteArgs} args - Arguments to delete one NoticeNotificationsSubscription.
     * @example
     * // Delete one NoticeNotificationsSubscription
     * const NoticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.delete({
     *   where: {
     *     // ... filter to delete one NoticeNotificationsSubscription
     *   }
     * })
     * 
    **/
    delete<T extends NoticeNotificationsSubscriptionDeleteArgs>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionDeleteArgs>
    ): CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>>

    /**
     * Update one NoticeNotificationsSubscription.
     * @param {NoticeNotificationsSubscriptionUpdateArgs} args - Arguments to update one NoticeNotificationsSubscription.
     * @example
     * // Update one NoticeNotificationsSubscription
     * const noticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NoticeNotificationsSubscriptionUpdateArgs>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionUpdateArgs>
    ): CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>>

    /**
     * Delete zero or more NoticeNotificationsSubscriptions.
     * @param {NoticeNotificationsSubscriptionDeleteManyArgs} args - Arguments to filter NoticeNotificationsSubscriptions to delete.
     * @example
     * // Delete a few NoticeNotificationsSubscriptions
     * const { count } = await prisma.noticeNotificationsSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NoticeNotificationsSubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, NoticeNotificationsSubscriptionDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more NoticeNotificationsSubscriptions.
     * @param {NoticeNotificationsSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoticeNotificationsSubscriptions
     * const noticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NoticeNotificationsSubscriptionUpdateManyArgs>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one NoticeNotificationsSubscription.
     * @param {NoticeNotificationsSubscriptionUpsertArgs} args - Arguments to update or create a NoticeNotificationsSubscription.
     * @example
     * // Update or create a NoticeNotificationsSubscription
     * const noticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.upsert({
     *   create: {
     *     // ... data to create a NoticeNotificationsSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoticeNotificationsSubscription we want to update
     *   }
     * })
    **/
    upsert<T extends NoticeNotificationsSubscriptionUpsertArgs>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionUpsertArgs>
    ): CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>>

    /**
     * Count the number of NoticeNotificationsSubscriptions.
     * @param {NoticeNotificationsSubscriptionCountArgs} args - Arguments to filter NoticeNotificationsSubscriptions to count.
     * @example
     * // Count the number of NoticeNotificationsSubscriptions
     * const count = await prisma.noticeNotificationsSubscription.count({
     *   where: {
     *     // ... the filter for the NoticeNotificationsSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends NoticeNotificationsSubscriptionCountArgs>(
      args?: Subset<T, NoticeNotificationsSubscriptionCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeNotificationsSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoticeNotificationsSubscription.
     * @param {NoticeNotificationsSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeNotificationsSubscriptionAggregateArgs>(args: Subset<T, NoticeNotificationsSubscriptionAggregateArgs>): Promise<GetNoticeNotificationsSubscriptionAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for NoticeNotificationsSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NoticeNotificationsSubscriptionClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * NoticeNotificationsSubscription findUnique
   */
  export type NoticeNotificationsSubscriptionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * Throw an Error if a NoticeNotificationsSubscription can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NoticeNotificationsSubscription to fetch.
    **/
    where: NoticeNotificationsSubscriptionWhereUniqueInput
  }


  /**
   * NoticeNotificationsSubscription findFirst
   */
  export type NoticeNotificationsSubscriptionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * Throw an Error if a NoticeNotificationsSubscription can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NoticeNotificationsSubscription to fetch.
    **/
    where?: NoticeNotificationsSubscriptionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of NoticeNotificationsSubscriptions to fetch.
    **/
    orderBy?: Enumerable<NoticeNotificationsSubscriptionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoticeNotificationsSubscriptions.
    **/
    cursor?: NoticeNotificationsSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoticeNotificationsSubscriptions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoticeNotificationsSubscriptions.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of NoticeNotificationsSubscriptions.
    **/
    distinct?: Enumerable<NoticeNotificationsSubscriptionScalarFieldEnum>
  }


  /**
   * NoticeNotificationsSubscription findMany
   */
  export type NoticeNotificationsSubscriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * Filter, which NoticeNotificationsSubscriptions to fetch.
    **/
    where?: NoticeNotificationsSubscriptionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of NoticeNotificationsSubscriptions to fetch.
    **/
    orderBy?: Enumerable<NoticeNotificationsSubscriptionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoticeNotificationsSubscriptions.
    **/
    cursor?: NoticeNotificationsSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoticeNotificationsSubscriptions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoticeNotificationsSubscriptions.
    **/
    skip?: number
    distinct?: Enumerable<NoticeNotificationsSubscriptionScalarFieldEnum>
  }


  /**
   * NoticeNotificationsSubscription create
   */
  export type NoticeNotificationsSubscriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * The data needed to create a NoticeNotificationsSubscription.
    **/
    data: XOR<NoticeNotificationsSubscriptionUncheckedCreateInput, NoticeNotificationsSubscriptionCreateInput>
  }


  /**
   * NoticeNotificationsSubscription update
   */
  export type NoticeNotificationsSubscriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * The data needed to update a NoticeNotificationsSubscription.
    **/
    data: XOR<NoticeNotificationsSubscriptionUncheckedUpdateInput, NoticeNotificationsSubscriptionUpdateInput>
    /**
     * Choose, which NoticeNotificationsSubscription to update.
    **/
    where: NoticeNotificationsSubscriptionWhereUniqueInput
  }


  /**
   * NoticeNotificationsSubscription updateMany
   */
  export type NoticeNotificationsSubscriptionUpdateManyArgs = {
    data: XOR<NoticeNotificationsSubscriptionUncheckedUpdateManyInput, NoticeNotificationsSubscriptionUpdateManyMutationInput>
    where?: NoticeNotificationsSubscriptionWhereInput
  }


  /**
   * NoticeNotificationsSubscription upsert
   */
  export type NoticeNotificationsSubscriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * The filter to search for the NoticeNotificationsSubscription to update in case it exists.
    **/
    where: NoticeNotificationsSubscriptionWhereUniqueInput
    /**
     * In case the NoticeNotificationsSubscription found by the `where` argument doesn't exist, create a new NoticeNotificationsSubscription with this data.
    **/
    create: XOR<NoticeNotificationsSubscriptionUncheckedCreateInput, NoticeNotificationsSubscriptionCreateInput>
    /**
     * In case the NoticeNotificationsSubscription was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<NoticeNotificationsSubscriptionUncheckedUpdateInput, NoticeNotificationsSubscriptionUpdateInput>
  }


  /**
   * NoticeNotificationsSubscription delete
   */
  export type NoticeNotificationsSubscriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * Filter which NoticeNotificationsSubscription to delete.
    **/
    where: NoticeNotificationsSubscriptionWhereUniqueInput
  }


  /**
   * NoticeNotificationsSubscription deleteMany
   */
  export type NoticeNotificationsSubscriptionDeleteManyArgs = {
    where?: NoticeNotificationsSubscriptionWhereInput
  }


  /**
   * NoticeNotificationsSubscription without action
   */
  export type NoticeNotificationsSubscriptionArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
  }



  /**
   * Model PendingUser
   */


  export type AggregatePendingUser = {
    count: PendingUserCountAggregateOutputType | null
    avg: PendingUserAvgAggregateOutputType | null
    sum: PendingUserSumAggregateOutputType | null
    min: PendingUserMinAggregateOutputType | null
    max: PendingUserMaxAggregateOutputType | null
  }

  export type PendingUserAvgAggregateOutputType = {
    id: number
  }

  export type PendingUserSumAggregateOutputType = {
    id: number
  }

  export type PendingUserMinAggregateOutputType = {
    id: number
    portalId: string | null
    password: string | null
    nickname: string | null
    randomNickname: string | null
    joinedAt: Date | null
    token: string | null
  }

  export type PendingUserMaxAggregateOutputType = {
    id: number
    portalId: string | null
    password: string | null
    nickname: string | null
    randomNickname: string | null
    joinedAt: Date | null
    token: string | null
  }

  export type PendingUserCountAggregateOutputType = {
    id: number
    portalId: number | null
    password: number | null
    nickname: number | null
    randomNickname: number | null
    joinedAt: number | null
    token: number | null
    _all: number
  }


  export type PendingUserAvgAggregateInputType = {
    id?: true
  }

  export type PendingUserSumAggregateInputType = {
    id?: true
  }

  export type PendingUserMinAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    joinedAt?: true
    token?: true
  }

  export type PendingUserMaxAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    joinedAt?: true
    token?: true
  }

  export type PendingUserCountAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    joinedAt?: true
    token?: true
    _all?: true
  }

  export type PendingUserAggregateArgs = {
    /**
     * Filter which PendingUser to aggregate.
    **/
    where?: PendingUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of PendingUsers to fetch.
    **/
    orderBy?: Enumerable<PendingUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PendingUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingUsers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingUsers
    **/
    count?: true | PendingUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PendingUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PendingUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PendingUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PendingUserMaxAggregateInputType
  }

  export type GetPendingUserAggregateType<T extends PendingUserAggregateArgs> = {
    [P in keyof T & keyof AggregatePendingUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingUser[P]>
      : GetScalarType<T[P], AggregatePendingUser[P]>
  }



  export type PendingUserSelect = {
    id?: boolean
    portalId?: boolean
    password?: boolean
    nickname?: boolean
    randomNickname?: boolean
    joinedAt?: boolean
    token?: boolean
  }

  export type PendingUserGetPayload<
    S extends boolean | null | undefined | PendingUserArgs,
    U = keyof S
      > = S extends true
        ? PendingUser
    : S extends undefined
    ? never
    : S extends PendingUserArgs | PendingUserFindManyArgs
    ?'include' extends U
    ? PendingUser 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PendingUser ?PendingUser [P]
  : 
     never
  } 
    : PendingUser
  : PendingUser


  type PendingUserCountArgs = Merge<
    Omit<PendingUserFindManyArgs, 'select' | 'include'> & {
      select?: PendingUserCountAggregateInputType | true
    }
  >

  export interface PendingUserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PendingUser that matches the filter.
     * @param {PendingUserFindUniqueArgs} args - Arguments to find a PendingUser
     * @example
     * // Get one PendingUser
     * const pendingUser = await prisma.pendingUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PendingUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PendingUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PendingUser'> extends True ? CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>> : CheckSelect<T, Prisma__PendingUserClient<PendingUser | null >, Prisma__PendingUserClient<PendingUserGetPayload<T> | null >>

    /**
     * Find the first PendingUser that matches the filter.
     * @param {PendingUserFindFirstArgs} args - Arguments to find a PendingUser
     * @example
     * // Get one PendingUser
     * const pendingUser = await prisma.pendingUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PendingUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PendingUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PendingUser'> extends True ? CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>> : CheckSelect<T, Prisma__PendingUserClient<PendingUser | null >, Prisma__PendingUserClient<PendingUserGetPayload<T> | null >>

    /**
     * Find zero or more PendingUsers that matches the filter.
     * @param {PendingUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingUsers
     * const pendingUsers = await prisma.pendingUser.findMany()
     * 
     * // Get first 10 PendingUsers
     * const pendingUsers = await prisma.pendingUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingUserWithIdOnly = await prisma.pendingUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PendingUserFindManyArgs>(
      args?: SelectSubset<T, PendingUserFindManyArgs>
    ): CheckSelect<T, Promise<Array<PendingUser>>, Promise<Array<PendingUserGetPayload<T>>>>

    /**
     * Create a PendingUser.
     * @param {PendingUserCreateArgs} args - Arguments to create a PendingUser.
     * @example
     * // Create one PendingUser
     * const PendingUser = await prisma.pendingUser.create({
     *   data: {
     *     // ... data to create a PendingUser
     *   }
     * })
     * 
    **/
    create<T extends PendingUserCreateArgs>(
      args: SelectSubset<T, PendingUserCreateArgs>
    ): CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>>

    /**
     * Delete a PendingUser.
     * @param {PendingUserDeleteArgs} args - Arguments to delete one PendingUser.
     * @example
     * // Delete one PendingUser
     * const PendingUser = await prisma.pendingUser.delete({
     *   where: {
     *     // ... filter to delete one PendingUser
     *   }
     * })
     * 
    **/
    delete<T extends PendingUserDeleteArgs>(
      args: SelectSubset<T, PendingUserDeleteArgs>
    ): CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>>

    /**
     * Update one PendingUser.
     * @param {PendingUserUpdateArgs} args - Arguments to update one PendingUser.
     * @example
     * // Update one PendingUser
     * const pendingUser = await prisma.pendingUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PendingUserUpdateArgs>(
      args: SelectSubset<T, PendingUserUpdateArgs>
    ): CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>>

    /**
     * Delete zero or more PendingUsers.
     * @param {PendingUserDeleteManyArgs} args - Arguments to filter PendingUsers to delete.
     * @example
     * // Delete a few PendingUsers
     * const { count } = await prisma.pendingUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PendingUserDeleteManyArgs>(
      args?: SelectSubset<T, PendingUserDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more PendingUsers.
     * @param {PendingUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingUsers
     * const pendingUser = await prisma.pendingUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PendingUserUpdateManyArgs>(
      args: SelectSubset<T, PendingUserUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one PendingUser.
     * @param {PendingUserUpsertArgs} args - Arguments to update or create a PendingUser.
     * @example
     * // Update or create a PendingUser
     * const pendingUser = await prisma.pendingUser.upsert({
     *   create: {
     *     // ... data to create a PendingUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingUser we want to update
     *   }
     * })
    **/
    upsert<T extends PendingUserUpsertArgs>(
      args: SelectSubset<T, PendingUserUpsertArgs>
    ): CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>>

    /**
     * Count the number of PendingUsers.
     * @param {PendingUserCountArgs} args - Arguments to filter PendingUsers to count.
     * @example
     * // Count the number of PendingUsers
     * const count = await prisma.pendingUser.count({
     *   where: {
     *     // ... the filter for the PendingUsers we want to count
     *   }
     * })
    **/
    count<T extends PendingUserCountArgs>(
      args?: Subset<T, PendingUserCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingUser.
     * @param {PendingUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingUserAggregateArgs>(args: Subset<T, PendingUserAggregateArgs>): Promise<GetPendingUserAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PendingUserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PendingUser findUnique
   */
  export type PendingUserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * Throw an Error if a PendingUser can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PendingUser to fetch.
    **/
    where: PendingUserWhereUniqueInput
  }


  /**
   * PendingUser findFirst
   */
  export type PendingUserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * Throw an Error if a PendingUser can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PendingUser to fetch.
    **/
    where?: PendingUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of PendingUsers to fetch.
    **/
    orderBy?: Enumerable<PendingUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingUsers.
    **/
    cursor?: PendingUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingUsers.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of PendingUsers.
    **/
    distinct?: Enumerable<PendingUserScalarFieldEnum>
  }


  /**
   * PendingUser findMany
   */
  export type PendingUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * Filter, which PendingUsers to fetch.
    **/
    where?: PendingUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of PendingUsers to fetch.
    **/
    orderBy?: Enumerable<PendingUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingUsers.
    **/
    cursor?: PendingUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingUsers.
    **/
    skip?: number
    distinct?: Enumerable<PendingUserScalarFieldEnum>
  }


  /**
   * PendingUser create
   */
  export type PendingUserCreateArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * The data needed to create a PendingUser.
    **/
    data: XOR<PendingUserUncheckedCreateInput, PendingUserCreateInput>
  }


  /**
   * PendingUser update
   */
  export type PendingUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * The data needed to update a PendingUser.
    **/
    data: XOR<PendingUserUncheckedUpdateInput, PendingUserUpdateInput>
    /**
     * Choose, which PendingUser to update.
    **/
    where: PendingUserWhereUniqueInput
  }


  /**
   * PendingUser updateMany
   */
  export type PendingUserUpdateManyArgs = {
    data: XOR<PendingUserUncheckedUpdateManyInput, PendingUserUpdateManyMutationInput>
    where?: PendingUserWhereInput
  }


  /**
   * PendingUser upsert
   */
  export type PendingUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * The filter to search for the PendingUser to update in case it exists.
    **/
    where: PendingUserWhereUniqueInput
    /**
     * In case the PendingUser found by the `where` argument doesn't exist, create a new PendingUser with this data.
    **/
    create: XOR<PendingUserUncheckedCreateInput, PendingUserCreateInput>
    /**
     * In case the PendingUser was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PendingUserUncheckedUpdateInput, PendingUserUpdateInput>
  }


  /**
   * PendingUser delete
   */
  export type PendingUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * Filter which PendingUser to delete.
    **/
    where: PendingUserWhereUniqueInput
  }


  /**
   * PendingUser deleteMany
   */
  export type PendingUserDeleteManyArgs = {
    where?: PendingUserWhereInput
  }


  /**
   * PendingUser without action
   */
  export type PendingUserArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
  }



  /**
   * Model Period
   */


  export type AggregatePeriod = {
    count: PeriodCountAggregateOutputType | null
    avg: PeriodAvgAggregateOutputType | null
    sum: PeriodSumAggregateOutputType | null
    min: PeriodMinAggregateOutputType | null
    max: PeriodMaxAggregateOutputType | null
  }

  export type PeriodAvgAggregateOutputType = {
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodSumAggregateOutputType = {
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodMinAggregateOutputType = {
    lectureId: string | null
    day: string | null
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodMaxAggregateOutputType = {
    lectureId: string | null
    day: string | null
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodCountAggregateOutputType = {
    lectureId: number | null
    day: number | null
    startH: number
    startM: number
    endH: number
    endM: number
    _all: number
  }


  export type PeriodAvgAggregateInputType = {
    startH?: true
    startM?: true
    endH?: true
    endM?: true
  }

  export type PeriodSumAggregateInputType = {
    startH?: true
    startM?: true
    endH?: true
    endM?: true
  }

  export type PeriodMinAggregateInputType = {
    lectureId?: true
    day?: true
    startH?: true
    startM?: true
    endH?: true
    endM?: true
  }

  export type PeriodMaxAggregateInputType = {
    lectureId?: true
    day?: true
    startH?: true
    startM?: true
    endH?: true
    endM?: true
  }

  export type PeriodCountAggregateInputType = {
    lectureId?: true
    day?: true
    startH?: true
    startM?: true
    endH?: true
    endM?: true
    _all?: true
  }

  export type PeriodAggregateArgs = {
    /**
     * Filter which Period to aggregate.
    **/
    where?: PeriodWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Periods to fetch.
    **/
    orderBy?: Enumerable<PeriodOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Periods
    **/
    count?: true | PeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PeriodMaxAggregateInputType
  }

  export type GetPeriodAggregateType<T extends PeriodAggregateArgs> = {
    [P in keyof T & keyof AggregatePeriod]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeriod[P]>
      : GetScalarType<T[P], AggregatePeriod[P]>
  }



  export type PeriodSelect = {
    lectureId?: boolean
    day?: boolean
    startH?: boolean
    startM?: boolean
    endH?: boolean
    endM?: boolean
    lecture?: boolean | LectureArgs
  }

  export type PeriodInclude = {
    lecture?: boolean | LectureArgs
  }

  export type PeriodGetPayload<
    S extends boolean | null | undefined | PeriodArgs,
    U = keyof S
      > = S extends true
        ? Period
    : S extends undefined
    ? never
    : S extends PeriodArgs | PeriodFindManyArgs
    ?'include' extends U
    ? Period  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'lecture'
        ? LectureGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Period ?Period [P]
  : 
          P extends 'lecture'
        ? LectureGetPayload<S['select'][P]> : never
  } 
    : Period
  : Period


  type PeriodCountArgs = Merge<
    Omit<PeriodFindManyArgs, 'select' | 'include'> & {
      select?: PeriodCountAggregateInputType | true
    }
  >

  export interface PeriodDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Period that matches the filter.
     * @param {PeriodFindUniqueArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PeriodFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PeriodFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Period'> extends True ? CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>> : CheckSelect<T, Prisma__PeriodClient<Period | null >, Prisma__PeriodClient<PeriodGetPayload<T> | null >>

    /**
     * Find the first Period that matches the filter.
     * @param {PeriodFindFirstArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PeriodFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PeriodFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Period'> extends True ? CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>> : CheckSelect<T, Prisma__PeriodClient<Period | null >, Prisma__PeriodClient<PeriodGetPayload<T> | null >>

    /**
     * Find zero or more Periods that matches the filter.
     * @param {PeriodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Periods
     * const periods = await prisma.period.findMany()
     * 
     * // Get first 10 Periods
     * const periods = await prisma.period.findMany({ take: 10 })
     * 
     * // Only select the `lectureId`
     * const periodWithLectureIdOnly = await prisma.period.findMany({ select: { lectureId: true } })
     * 
    **/
    findMany<T extends PeriodFindManyArgs>(
      args?: SelectSubset<T, PeriodFindManyArgs>
    ): CheckSelect<T, Promise<Array<Period>>, Promise<Array<PeriodGetPayload<T>>>>

    /**
     * Create a Period.
     * @param {PeriodCreateArgs} args - Arguments to create a Period.
     * @example
     * // Create one Period
     * const Period = await prisma.period.create({
     *   data: {
     *     // ... data to create a Period
     *   }
     * })
     * 
    **/
    create<T extends PeriodCreateArgs>(
      args: SelectSubset<T, PeriodCreateArgs>
    ): CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>>

    /**
     * Delete a Period.
     * @param {PeriodDeleteArgs} args - Arguments to delete one Period.
     * @example
     * // Delete one Period
     * const Period = await prisma.period.delete({
     *   where: {
     *     // ... filter to delete one Period
     *   }
     * })
     * 
    **/
    delete<T extends PeriodDeleteArgs>(
      args: SelectSubset<T, PeriodDeleteArgs>
    ): CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>>

    /**
     * Update one Period.
     * @param {PeriodUpdateArgs} args - Arguments to update one Period.
     * @example
     * // Update one Period
     * const period = await prisma.period.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PeriodUpdateArgs>(
      args: SelectSubset<T, PeriodUpdateArgs>
    ): CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>>

    /**
     * Delete zero or more Periods.
     * @param {PeriodDeleteManyArgs} args - Arguments to filter Periods to delete.
     * @example
     * // Delete a few Periods
     * const { count } = await prisma.period.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PeriodDeleteManyArgs>(
      args?: SelectSubset<T, PeriodDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Periods.
     * @param {PeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Periods
     * const period = await prisma.period.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PeriodUpdateManyArgs>(
      args: SelectSubset<T, PeriodUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Period.
     * @param {PeriodUpsertArgs} args - Arguments to update or create a Period.
     * @example
     * // Update or create a Period
     * const period = await prisma.period.upsert({
     *   create: {
     *     // ... data to create a Period
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Period we want to update
     *   }
     * })
    **/
    upsert<T extends PeriodUpsertArgs>(
      args: SelectSubset<T, PeriodUpsertArgs>
    ): CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>>

    /**
     * Count the number of Periods.
     * @param {PeriodCountArgs} args - Arguments to filter Periods to count.
     * @example
     * // Count the number of Periods
     * const count = await prisma.period.count({
     *   where: {
     *     // ... the filter for the Periods we want to count
     *   }
     * })
    **/
    count<T extends PeriodCountArgs>(
      args?: Subset<T, PeriodCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Period.
     * @param {PeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeriodAggregateArgs>(args: Subset<T, PeriodAggregateArgs>): Promise<GetPeriodAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Period.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PeriodClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    lecture<T extends LectureArgs = {}>(args?: Subset<T, LectureArgs>): CheckSelect<T, Prisma__LectureClient<Lecture | null >, Prisma__LectureClient<LectureGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Period findUnique
   */
  export type PeriodFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * Throw an Error if a Period can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Period to fetch.
    **/
    where: PeriodWhereUniqueInput
  }


  /**
   * Period findFirst
   */
  export type PeriodFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * Throw an Error if a Period can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Period to fetch.
    **/
    where?: PeriodWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Periods to fetch.
    **/
    orderBy?: Enumerable<PeriodOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Periods.
    **/
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Periods.
    **/
    distinct?: Enumerable<PeriodScalarFieldEnum>
  }


  /**
   * Period findMany
   */
  export type PeriodFindManyArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * Filter, which Periods to fetch.
    **/
    where?: PeriodWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Periods to fetch.
    **/
    orderBy?: Enumerable<PeriodOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Periods.
    **/
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
    **/
    skip?: number
    distinct?: Enumerable<PeriodScalarFieldEnum>
  }


  /**
   * Period create
   */
  export type PeriodCreateArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * The data needed to create a Period.
    **/
    data: XOR<PeriodUncheckedCreateInput, PeriodCreateInput>
  }


  /**
   * Period update
   */
  export type PeriodUpdateArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * The data needed to update a Period.
    **/
    data: XOR<PeriodUncheckedUpdateInput, PeriodUpdateInput>
    /**
     * Choose, which Period to update.
    **/
    where: PeriodWhereUniqueInput
  }


  /**
   * Period updateMany
   */
  export type PeriodUpdateManyArgs = {
    data: XOR<PeriodUncheckedUpdateManyInput, PeriodUpdateManyMutationInput>
    where?: PeriodWhereInput
  }


  /**
   * Period upsert
   */
  export type PeriodUpsertArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * The filter to search for the Period to update in case it exists.
    **/
    where: PeriodWhereUniqueInput
    /**
     * In case the Period found by the `where` argument doesn't exist, create a new Period with this data.
    **/
    create: XOR<PeriodUncheckedCreateInput, PeriodCreateInput>
    /**
     * In case the Period was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PeriodUncheckedUpdateInput, PeriodUpdateInput>
  }


  /**
   * Period delete
   */
  export type PeriodDeleteArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * Filter which Period to delete.
    **/
    where: PeriodWhereUniqueInput
  }


  /**
   * Period deleteMany
   */
  export type PeriodDeleteManyArgs = {
    where?: PeriodWhereInput
  }


  /**
   * Period without action
   */
  export type PeriodArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
  }



  /**
   * Model Push
   */


  export type AggregatePush = {
    count: PushCountAggregateOutputType | null
    avg: PushAvgAggregateOutputType | null
    sum: PushSumAggregateOutputType | null
    min: PushMinAggregateOutputType | null
    max: PushMaxAggregateOutputType | null
  }

  export type PushAvgAggregateOutputType = {
    userId: number
  }

  export type PushSumAggregateOutputType = {
    userId: number
  }

  export type PushMinAggregateOutputType = {
    userId: number
    expoPushToken: string | null
    registeredAt: Date | null
    activeAt: Date | null
  }

  export type PushMaxAggregateOutputType = {
    userId: number
    expoPushToken: string | null
    registeredAt: Date | null
    activeAt: Date | null
  }

  export type PushCountAggregateOutputType = {
    userId: number
    expoPushToken: number | null
    registeredAt: number | null
    activeAt: number | null
    _all: number
  }


  export type PushAvgAggregateInputType = {
    userId?: true
  }

  export type PushSumAggregateInputType = {
    userId?: true
  }

  export type PushMinAggregateInputType = {
    userId?: true
    expoPushToken?: true
    registeredAt?: true
    activeAt?: true
  }

  export type PushMaxAggregateInputType = {
    userId?: true
    expoPushToken?: true
    registeredAt?: true
    activeAt?: true
  }

  export type PushCountAggregateInputType = {
    userId?: true
    expoPushToken?: true
    registeredAt?: true
    activeAt?: true
    _all?: true
  }

  export type PushAggregateArgs = {
    /**
     * Filter which Push to aggregate.
    **/
    where?: PushWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Pushes to fetch.
    **/
    orderBy?: Enumerable<PushOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PushWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pushes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pushes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pushes
    **/
    count?: true | PushCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PushAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PushSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PushMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PushMaxAggregateInputType
  }

  export type GetPushAggregateType<T extends PushAggregateArgs> = {
    [P in keyof T & keyof AggregatePush]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePush[P]>
      : GetScalarType<T[P], AggregatePush[P]>
  }



  export type PushSelect = {
    userId?: boolean
    expoPushToken?: boolean
    registeredAt?: boolean
    activeAt?: boolean
    user?: boolean | UserArgs
  }

  export type PushInclude = {
    user?: boolean | UserArgs
  }

  export type PushGetPayload<
    S extends boolean | null | undefined | PushArgs,
    U = keyof S
      > = S extends true
        ? Push
    : S extends undefined
    ? never
    : S extends PushArgs | PushFindManyArgs
    ?'include' extends U
    ? Push  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Push ?Push [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Push
  : Push


  type PushCountArgs = Merge<
    Omit<PushFindManyArgs, 'select' | 'include'> & {
      select?: PushCountAggregateInputType | true
    }
  >

  export interface PushDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Push that matches the filter.
     * @param {PushFindUniqueArgs} args - Arguments to find a Push
     * @example
     * // Get one Push
     * const push = await prisma.push.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PushFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PushFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Push'> extends True ? CheckSelect<T, Prisma__PushClient<Push>, Prisma__PushClient<PushGetPayload<T>>> : CheckSelect<T, Prisma__PushClient<Push | null >, Prisma__PushClient<PushGetPayload<T> | null >>

    /**
     * Find the first Push that matches the filter.
     * @param {PushFindFirstArgs} args - Arguments to find a Push
     * @example
     * // Get one Push
     * const push = await prisma.push.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PushFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PushFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Push'> extends True ? CheckSelect<T, Prisma__PushClient<Push>, Prisma__PushClient<PushGetPayload<T>>> : CheckSelect<T, Prisma__PushClient<Push | null >, Prisma__PushClient<PushGetPayload<T> | null >>

    /**
     * Find zero or more Pushes that matches the filter.
     * @param {PushFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pushes
     * const pushes = await prisma.push.findMany()
     * 
     * // Get first 10 Pushes
     * const pushes = await prisma.push.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const pushWithUserIdOnly = await prisma.push.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends PushFindManyArgs>(
      args?: SelectSubset<T, PushFindManyArgs>
    ): CheckSelect<T, Promise<Array<Push>>, Promise<Array<PushGetPayload<T>>>>

    /**
     * Create a Push.
     * @param {PushCreateArgs} args - Arguments to create a Push.
     * @example
     * // Create one Push
     * const Push = await prisma.push.create({
     *   data: {
     *     // ... data to create a Push
     *   }
     * })
     * 
    **/
    create<T extends PushCreateArgs>(
      args: SelectSubset<T, PushCreateArgs>
    ): CheckSelect<T, Prisma__PushClient<Push>, Prisma__PushClient<PushGetPayload<T>>>

    /**
     * Delete a Push.
     * @param {PushDeleteArgs} args - Arguments to delete one Push.
     * @example
     * // Delete one Push
     * const Push = await prisma.push.delete({
     *   where: {
     *     // ... filter to delete one Push
     *   }
     * })
     * 
    **/
    delete<T extends PushDeleteArgs>(
      args: SelectSubset<T, PushDeleteArgs>
    ): CheckSelect<T, Prisma__PushClient<Push>, Prisma__PushClient<PushGetPayload<T>>>

    /**
     * Update one Push.
     * @param {PushUpdateArgs} args - Arguments to update one Push.
     * @example
     * // Update one Push
     * const push = await prisma.push.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PushUpdateArgs>(
      args: SelectSubset<T, PushUpdateArgs>
    ): CheckSelect<T, Prisma__PushClient<Push>, Prisma__PushClient<PushGetPayload<T>>>

    /**
     * Delete zero or more Pushes.
     * @param {PushDeleteManyArgs} args - Arguments to filter Pushes to delete.
     * @example
     * // Delete a few Pushes
     * const { count } = await prisma.push.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PushDeleteManyArgs>(
      args?: SelectSubset<T, PushDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Pushes.
     * @param {PushUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pushes
     * const push = await prisma.push.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PushUpdateManyArgs>(
      args: SelectSubset<T, PushUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Push.
     * @param {PushUpsertArgs} args - Arguments to update or create a Push.
     * @example
     * // Update or create a Push
     * const push = await prisma.push.upsert({
     *   create: {
     *     // ... data to create a Push
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Push we want to update
     *   }
     * })
    **/
    upsert<T extends PushUpsertArgs>(
      args: SelectSubset<T, PushUpsertArgs>
    ): CheckSelect<T, Prisma__PushClient<Push>, Prisma__PushClient<PushGetPayload<T>>>

    /**
     * Count the number of Pushes.
     * @param {PushCountArgs} args - Arguments to filter Pushes to count.
     * @example
     * // Count the number of Pushes
     * const count = await prisma.push.count({
     *   where: {
     *     // ... the filter for the Pushes we want to count
     *   }
     * })
    **/
    count<T extends PushCountArgs>(
      args?: Subset<T, PushCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Push.
     * @param {PushAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushAggregateArgs>(args: Subset<T, PushAggregateArgs>): Promise<GetPushAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Push.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PushClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Push findUnique
   */
  export type PushFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Push
    **/
    select?: PushSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PushInclude | null
    /**
     * Throw an Error if a Push can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Push to fetch.
    **/
    where: PushWhereUniqueInput
  }


  /**
   * Push findFirst
   */
  export type PushFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Push
    **/
    select?: PushSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PushInclude | null
    /**
     * Throw an Error if a Push can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Push to fetch.
    **/
    where?: PushWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Pushes to fetch.
    **/
    orderBy?: Enumerable<PushOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pushes.
    **/
    cursor?: PushWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pushes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pushes.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Pushes.
    **/
    distinct?: Enumerable<PushScalarFieldEnum>
  }


  /**
   * Push findMany
   */
  export type PushFindManyArgs = {
    /**
     * Select specific fields to fetch from the Push
    **/
    select?: PushSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PushInclude | null
    /**
     * Filter, which Pushes to fetch.
    **/
    where?: PushWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Pushes to fetch.
    **/
    orderBy?: Enumerable<PushOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pushes.
    **/
    cursor?: PushWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pushes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pushes.
    **/
    skip?: number
    distinct?: Enumerable<PushScalarFieldEnum>
  }


  /**
   * Push create
   */
  export type PushCreateArgs = {
    /**
     * Select specific fields to fetch from the Push
    **/
    select?: PushSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PushInclude | null
    /**
     * The data needed to create a Push.
    **/
    data: XOR<PushUncheckedCreateInput, PushCreateInput>
  }


  /**
   * Push update
   */
  export type PushUpdateArgs = {
    /**
     * Select specific fields to fetch from the Push
    **/
    select?: PushSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PushInclude | null
    /**
     * The data needed to update a Push.
    **/
    data: XOR<PushUncheckedUpdateInput, PushUpdateInput>
    /**
     * Choose, which Push to update.
    **/
    where: PushWhereUniqueInput
  }


  /**
   * Push updateMany
   */
  export type PushUpdateManyArgs = {
    data: XOR<PushUncheckedUpdateManyInput, PushUpdateManyMutationInput>
    where?: PushWhereInput
  }


  /**
   * Push upsert
   */
  export type PushUpsertArgs = {
    /**
     * Select specific fields to fetch from the Push
    **/
    select?: PushSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PushInclude | null
    /**
     * The filter to search for the Push to update in case it exists.
    **/
    where: PushWhereUniqueInput
    /**
     * In case the Push found by the `where` argument doesn't exist, create a new Push with this data.
    **/
    create: XOR<PushUncheckedCreateInput, PushCreateInput>
    /**
     * In case the Push was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PushUncheckedUpdateInput, PushUpdateInput>
  }


  /**
   * Push delete
   */
  export type PushDeleteArgs = {
    /**
     * Select specific fields to fetch from the Push
    **/
    select?: PushSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PushInclude | null
    /**
     * Filter which Push to delete.
    **/
    where: PushWhereUniqueInput
  }


  /**
   * Push deleteMany
   */
  export type PushDeleteManyArgs = {
    where?: PushWhereInput
  }


  /**
   * Push without action
   */
  export type PushArgs = {
    /**
     * Select specific fields to fetch from the Push
    **/
    select?: PushSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PushInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    count: UserCountAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number
  }

  export type UserSumAggregateOutputType = {
    id: number
  }

  export type UserMinAggregateOutputType = {
    id: number
    portalId: string | null
    password: string | null
    nickname: string | null
    randomNickname: string | null
    joinedAt: Date | null
    refreshToken: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number
    portalId: string | null
    password: string | null
    nickname: string | null
    randomNickname: string | null
    joinedAt: Date | null
    refreshToken: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    portalId: number | null
    password: number | null
    nickname: number | null
    randomNickname: number | null
    joinedAt: number | null
    refreshToken: number | null
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    joinedAt?: true
    refreshToken?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    joinedAt?: true
    refreshToken?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    joinedAt?: true
    refreshToken?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
    **/
    where?: UserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }



  export type UserSelect = {
    id?: boolean
    portalId?: boolean
    password?: boolean
    nickname?: boolean
    randomNickname?: boolean
    joinedAt?: boolean
    refreshToken?: boolean
    admin?: boolean | AdminArgs
    changePassword?: boolean | ChangePasswordArgs
    communityBoards?: boolean | CommunityBoardFindManyArgs
    communityBoardCandidates?: boolean | CommunityBoardCandidateFindManyArgs
    communityBoardCandidateVotes?: boolean | CommunityBoardCandidateVoteFindManyArgs
    communityBoardPins?: boolean | CommunityBoardPinFindManyArgs
    communityComments?: boolean | CommunityCommentFindManyArgs
    communityPosts?: boolean | CommunityPostFindManyArgs
    communityPostBookmarks?: boolean | CommunityPostBookmarkFindManyArgs
    communityPostLikes?: boolean | CommunityPostLikeFindManyArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    liveChats?: boolean | LiveChatFindManyArgs
    noticeNotificationsSubscriptions?: boolean | NoticeNotificationsSubscriptionFindManyArgs
    pushes?: boolean | PushFindManyArgs
    reportComments?: boolean | ReportCommentFindManyArgs
    reportPosts?: boolean | ReportPostFindManyArgs
    reportSubcomments?: boolean | ReportSubcommentFindManyArgs
  }

  export type UserInclude = {
    admin?: boolean | AdminArgs
    changePassword?: boolean | ChangePasswordArgs
    communityBoards?: boolean | CommunityBoardFindManyArgs
    communityBoardCandidates?: boolean | CommunityBoardCandidateFindManyArgs
    communityBoardCandidateVotes?: boolean | CommunityBoardCandidateVoteFindManyArgs
    communityBoardPins?: boolean | CommunityBoardPinFindManyArgs
    communityComments?: boolean | CommunityCommentFindManyArgs
    communityPosts?: boolean | CommunityPostFindManyArgs
    communityPostBookmarks?: boolean | CommunityPostBookmarkFindManyArgs
    communityPostLikes?: boolean | CommunityPostLikeFindManyArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    liveChats?: boolean | LiveChatFindManyArgs
    noticeNotificationsSubscriptions?: boolean | NoticeNotificationsSubscriptionFindManyArgs
    pushes?: boolean | PushFindManyArgs
    reportComments?: boolean | ReportCommentFindManyArgs
    reportPosts?: boolean | ReportPostFindManyArgs
    reportSubcomments?: boolean | ReportSubcommentFindManyArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'admin'
        ? AdminGetPayload<S['include'][P]> | null :
        P extends 'changePassword'
        ? ChangePasswordGetPayload<S['include'][P]> | null :
        P extends 'communityBoards'
        ? Array < CommunityBoardGetPayload<S['include'][P]>>  :
        P extends 'communityBoardCandidates'
        ? Array < CommunityBoardCandidateGetPayload<S['include'][P]>>  :
        P extends 'communityBoardCandidateVotes'
        ? Array < CommunityBoardCandidateVoteGetPayload<S['include'][P]>>  :
        P extends 'communityBoardPins'
        ? Array < CommunityBoardPinGetPayload<S['include'][P]>>  :
        P extends 'communityComments'
        ? Array < CommunityCommentGetPayload<S['include'][P]>>  :
        P extends 'communityPosts'
        ? Array < CommunityPostGetPayload<S['include'][P]>>  :
        P extends 'communityPostBookmarks'
        ? Array < CommunityPostBookmarkGetPayload<S['include'][P]>>  :
        P extends 'communityPostLikes'
        ? Array < CommunityPostLikeGetPayload<S['include'][P]>>  :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['include'][P]>>  :
        P extends 'liveChats'
        ? Array < LiveChatGetPayload<S['include'][P]>>  :
        P extends 'noticeNotificationsSubscriptions'
        ? Array < NoticeNotificationsSubscriptionGetPayload<S['include'][P]>>  :
        P extends 'pushes'
        ? Array < PushGetPayload<S['include'][P]>>  :
        P extends 'reportComments'
        ? Array < ReportCommentGetPayload<S['include'][P]>>  :
        P extends 'reportPosts'
        ? Array < ReportPostGetPayload<S['include'][P]>>  :
        P extends 'reportSubcomments'
        ? Array < ReportSubcommentGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'admin'
        ? AdminGetPayload<S['select'][P]> | null :
        P extends 'changePassword'
        ? ChangePasswordGetPayload<S['select'][P]> | null :
        P extends 'communityBoards'
        ? Array < CommunityBoardGetPayload<S['select'][P]>>  :
        P extends 'communityBoardCandidates'
        ? Array < CommunityBoardCandidateGetPayload<S['select'][P]>>  :
        P extends 'communityBoardCandidateVotes'
        ? Array < CommunityBoardCandidateVoteGetPayload<S['select'][P]>>  :
        P extends 'communityBoardPins'
        ? Array < CommunityBoardPinGetPayload<S['select'][P]>>  :
        P extends 'communityComments'
        ? Array < CommunityCommentGetPayload<S['select'][P]>>  :
        P extends 'communityPosts'
        ? Array < CommunityPostGetPayload<S['select'][P]>>  :
        P extends 'communityPostBookmarks'
        ? Array < CommunityPostBookmarkGetPayload<S['select'][P]>>  :
        P extends 'communityPostLikes'
        ? Array < CommunityPostLikeGetPayload<S['select'][P]>>  :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['select'][P]>>  :
        P extends 'liveChats'
        ? Array < LiveChatGetPayload<S['select'][P]>>  :
        P extends 'noticeNotificationsSubscriptions'
        ? Array < NoticeNotificationsSubscriptionGetPayload<S['select'][P]>>  :
        P extends 'pushes'
        ? Array < PushGetPayload<S['select'][P]>>  :
        P extends 'reportComments'
        ? Array < ReportCommentGetPayload<S['select'][P]>>  :
        P extends 'reportPosts'
        ? Array < ReportPostGetPayload<S['select'][P]>>  :
        P extends 'reportSubcomments'
        ? Array < ReportSubcommentGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Users.
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Promise<GetUserAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    admin<T extends AdminArgs = {}>(args?: Subset<T, AdminArgs>): CheckSelect<T, Prisma__AdminClient<Admin | null >, Prisma__AdminClient<AdminGetPayload<T> | null >>;

    changePassword<T extends ChangePasswordArgs = {}>(args?: Subset<T, ChangePasswordArgs>): CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword | null >, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T> | null >>;

    communityBoards<T extends CommunityBoardFindManyArgs = {}>(args?: Subset<T, CommunityBoardFindManyArgs>): CheckSelect<T, Promise<Array<CommunityBoard>>, Promise<Array<CommunityBoardGetPayload<T>>>>;

    communityBoardCandidates<T extends CommunityBoardCandidateFindManyArgs = {}>(args?: Subset<T, CommunityBoardCandidateFindManyArgs>): CheckSelect<T, Promise<Array<CommunityBoardCandidate>>, Promise<Array<CommunityBoardCandidateGetPayload<T>>>>;

    communityBoardCandidateVotes<T extends CommunityBoardCandidateVoteFindManyArgs = {}>(args?: Subset<T, CommunityBoardCandidateVoteFindManyArgs>): CheckSelect<T, Promise<Array<CommunityBoardCandidateVote>>, Promise<Array<CommunityBoardCandidateVoteGetPayload<T>>>>;

    communityBoardPins<T extends CommunityBoardPinFindManyArgs = {}>(args?: Subset<T, CommunityBoardPinFindManyArgs>): CheckSelect<T, Promise<Array<CommunityBoardPin>>, Promise<Array<CommunityBoardPinGetPayload<T>>>>;

    communityComments<T extends CommunityCommentFindManyArgs = {}>(args?: Subset<T, CommunityCommentFindManyArgs>): CheckSelect<T, Promise<Array<CommunityComment>>, Promise<Array<CommunityCommentGetPayload<T>>>>;

    communityPosts<T extends CommunityPostFindManyArgs = {}>(args?: Subset<T, CommunityPostFindManyArgs>): CheckSelect<T, Promise<Array<CommunityPost>>, Promise<Array<CommunityPostGetPayload<T>>>>;

    communityPostBookmarks<T extends CommunityPostBookmarkFindManyArgs = {}>(args?: Subset<T, CommunityPostBookmarkFindManyArgs>): CheckSelect<T, Promise<Array<CommunityPostBookmark>>, Promise<Array<CommunityPostBookmarkGetPayload<T>>>>;

    communityPostLikes<T extends CommunityPostLikeFindManyArgs = {}>(args?: Subset<T, CommunityPostLikeFindManyArgs>): CheckSelect<T, Promise<Array<CommunityPostLike>>, Promise<Array<CommunityPostLikeGetPayload<T>>>>;

    communitySubcomments<T extends CommunitySubcommentFindManyArgs = {}>(args?: Subset<T, CommunitySubcommentFindManyArgs>): CheckSelect<T, Promise<Array<CommunitySubcomment>>, Promise<Array<CommunitySubcommentGetPayload<T>>>>;

    liveChats<T extends LiveChatFindManyArgs = {}>(args?: Subset<T, LiveChatFindManyArgs>): CheckSelect<T, Promise<Array<LiveChat>>, Promise<Array<LiveChatGetPayload<T>>>>;

    noticeNotificationsSubscriptions<T extends NoticeNotificationsSubscriptionFindManyArgs = {}>(args?: Subset<T, NoticeNotificationsSubscriptionFindManyArgs>): CheckSelect<T, Promise<Array<NoticeNotificationsSubscription>>, Promise<Array<NoticeNotificationsSubscriptionGetPayload<T>>>>;

    pushes<T extends PushFindManyArgs = {}>(args?: Subset<T, PushFindManyArgs>): CheckSelect<T, Promise<Array<Push>>, Promise<Array<PushGetPayload<T>>>>;

    reportComments<T extends ReportCommentFindManyArgs = {}>(args?: Subset<T, ReportCommentFindManyArgs>): CheckSelect<T, Promise<Array<ReportComment>>, Promise<Array<ReportCommentGetPayload<T>>>>;

    reportPosts<T extends ReportPostFindManyArgs = {}>(args?: Subset<T, ReportPostFindManyArgs>): CheckSelect<T, Promise<Array<ReportPost>>, Promise<Array<ReportPostGetPayload<T>>>>;

    reportSubcomments<T extends ReportSubcommentFindManyArgs = {}>(args?: Subset<T, ReportSubcommentFindManyArgs>): CheckSelect<T, Promise<Array<ReportSubcomment>>, Promise<Array<ReportSubcommentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where?: UserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Users.
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
    **/
    data: XOR<UserUncheckedCreateInput, UserCreateInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
    **/
    data: XOR<UserUncheckedUpdateInput, UserUpdateInput>
    /**
     * Choose, which User to update.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUncheckedUpdateManyInput, UserUpdateManyMutationInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
    **/
    create: XOR<UserUncheckedCreateInput, UserCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserUncheckedUpdateInput, UserUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
  }



  /**
   * Model ReportComment
   */


  export type AggregateReportComment = {
    count: ReportCommentCountAggregateOutputType | null
    avg: ReportCommentAvgAggregateOutputType | null
    sum: ReportCommentSumAggregateOutputType | null
    min: ReportCommentMinAggregateOutputType | null
    max: ReportCommentMaxAggregateOutputType | null
  }

  export type ReportCommentAvgAggregateOutputType = {
    id: number
    commentId: number
    userId: number
  }

  export type ReportCommentSumAggregateOutputType = {
    id: number
    commentId: number
    userId: number
  }

  export type ReportCommentMinAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportCommentMaxAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportCommentCountAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    title: number | null
    body: number | null
    reportedAt: number | null
    _all: number
  }


  export type ReportCommentAvgAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type ReportCommentSumAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type ReportCommentMinAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportCommentMaxAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportCommentCountAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
    _all?: true
  }

  export type ReportCommentAggregateArgs = {
    /**
     * Filter which ReportComment to aggregate.
    **/
    where?: ReportCommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ReportComments to fetch.
    **/
    orderBy?: Enumerable<ReportCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ReportCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportComments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportComments
    **/
    count?: true | ReportCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ReportCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ReportCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ReportCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ReportCommentMaxAggregateInputType
  }

  export type GetReportCommentAggregateType<T extends ReportCommentAggregateArgs> = {
    [P in keyof T & keyof AggregateReportComment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportComment[P]>
      : GetScalarType<T[P], AggregateReportComment[P]>
  }



  export type ReportCommentSelect = {
    id?: boolean
    commentId?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    reportedAt?: boolean
    communityComment?: boolean | CommunityCommentArgs
    user?: boolean | UserArgs
  }

  export type ReportCommentInclude = {
    communityComment?: boolean | CommunityCommentArgs
    user?: boolean | UserArgs
  }

  export type ReportCommentGetPayload<
    S extends boolean | null | undefined | ReportCommentArgs,
    U = keyof S
      > = S extends true
        ? ReportComment
    : S extends undefined
    ? never
    : S extends ReportCommentArgs | ReportCommentFindManyArgs
    ?'include' extends U
    ? ReportComment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityComment'
        ? CommunityCommentGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ReportComment ?ReportComment [P]
  : 
          P extends 'communityComment'
        ? CommunityCommentGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ReportComment
  : ReportComment


  type ReportCommentCountArgs = Merge<
    Omit<ReportCommentFindManyArgs, 'select' | 'include'> & {
      select?: ReportCommentCountAggregateInputType | true
    }
  >

  export interface ReportCommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReportComment that matches the filter.
     * @param {ReportCommentFindUniqueArgs} args - Arguments to find a ReportComment
     * @example
     * // Get one ReportComment
     * const reportComment = await prisma.reportComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReportCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReportComment'> extends True ? CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>> : CheckSelect<T, Prisma__ReportCommentClient<ReportComment | null >, Prisma__ReportCommentClient<ReportCommentGetPayload<T> | null >>

    /**
     * Find the first ReportComment that matches the filter.
     * @param {ReportCommentFindFirstArgs} args - Arguments to find a ReportComment
     * @example
     * // Get one ReportComment
     * const reportComment = await prisma.reportComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReportCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReportComment'> extends True ? CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>> : CheckSelect<T, Prisma__ReportCommentClient<ReportComment | null >, Prisma__ReportCommentClient<ReportCommentGetPayload<T> | null >>

    /**
     * Find zero or more ReportComments that matches the filter.
     * @param {ReportCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportComments
     * const reportComments = await prisma.reportComment.findMany()
     * 
     * // Get first 10 ReportComments
     * const reportComments = await prisma.reportComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportCommentWithIdOnly = await prisma.reportComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportCommentFindManyArgs>(
      args?: SelectSubset<T, ReportCommentFindManyArgs>
    ): CheckSelect<T, Promise<Array<ReportComment>>, Promise<Array<ReportCommentGetPayload<T>>>>

    /**
     * Create a ReportComment.
     * @param {ReportCommentCreateArgs} args - Arguments to create a ReportComment.
     * @example
     * // Create one ReportComment
     * const ReportComment = await prisma.reportComment.create({
     *   data: {
     *     // ... data to create a ReportComment
     *   }
     * })
     * 
    **/
    create<T extends ReportCommentCreateArgs>(
      args: SelectSubset<T, ReportCommentCreateArgs>
    ): CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>>

    /**
     * Delete a ReportComment.
     * @param {ReportCommentDeleteArgs} args - Arguments to delete one ReportComment.
     * @example
     * // Delete one ReportComment
     * const ReportComment = await prisma.reportComment.delete({
     *   where: {
     *     // ... filter to delete one ReportComment
     *   }
     * })
     * 
    **/
    delete<T extends ReportCommentDeleteArgs>(
      args: SelectSubset<T, ReportCommentDeleteArgs>
    ): CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>>

    /**
     * Update one ReportComment.
     * @param {ReportCommentUpdateArgs} args - Arguments to update one ReportComment.
     * @example
     * // Update one ReportComment
     * const reportComment = await prisma.reportComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportCommentUpdateArgs>(
      args: SelectSubset<T, ReportCommentUpdateArgs>
    ): CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>>

    /**
     * Delete zero or more ReportComments.
     * @param {ReportCommentDeleteManyArgs} args - Arguments to filter ReportComments to delete.
     * @example
     * // Delete a few ReportComments
     * const { count } = await prisma.reportComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportCommentDeleteManyArgs>(
      args?: SelectSubset<T, ReportCommentDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more ReportComments.
     * @param {ReportCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportComments
     * const reportComment = await prisma.reportComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportCommentUpdateManyArgs>(
      args: SelectSubset<T, ReportCommentUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one ReportComment.
     * @param {ReportCommentUpsertArgs} args - Arguments to update or create a ReportComment.
     * @example
     * // Update or create a ReportComment
     * const reportComment = await prisma.reportComment.upsert({
     *   create: {
     *     // ... data to create a ReportComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportComment we want to update
     *   }
     * })
    **/
    upsert<T extends ReportCommentUpsertArgs>(
      args: SelectSubset<T, ReportCommentUpsertArgs>
    ): CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>>

    /**
     * Count the number of ReportComments.
     * @param {ReportCommentCountArgs} args - Arguments to filter ReportComments to count.
     * @example
     * // Count the number of ReportComments
     * const count = await prisma.reportComment.count({
     *   where: {
     *     // ... the filter for the ReportComments we want to count
     *   }
     * })
    **/
    count<T extends ReportCommentCountArgs>(
      args?: Subset<T, ReportCommentCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportComment.
     * @param {ReportCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportCommentAggregateArgs>(args: Subset<T, ReportCommentAggregateArgs>): Promise<GetReportCommentAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportCommentClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityComment<T extends CommunityCommentArgs = {}>(args?: Subset<T, CommunityCommentArgs>): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment | null >, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReportComment findUnique
   */
  export type ReportCommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * Throw an Error if a ReportComment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportComment to fetch.
    **/
    where: ReportCommentWhereUniqueInput
  }


  /**
   * ReportComment findFirst
   */
  export type ReportCommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * Throw an Error if a ReportComment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportComment to fetch.
    **/
    where?: ReportCommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ReportComments to fetch.
    **/
    orderBy?: Enumerable<ReportCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportComments.
    **/
    cursor?: ReportCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportComments.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of ReportComments.
    **/
    distinct?: Enumerable<ReportCommentScalarFieldEnum>
  }


  /**
   * ReportComment findMany
   */
  export type ReportCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * Filter, which ReportComments to fetch.
    **/
    where?: ReportCommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ReportComments to fetch.
    **/
    orderBy?: Enumerable<ReportCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportComments.
    **/
    cursor?: ReportCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportComments.
    **/
    skip?: number
    distinct?: Enumerable<ReportCommentScalarFieldEnum>
  }


  /**
   * ReportComment create
   */
  export type ReportCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * The data needed to create a ReportComment.
    **/
    data: XOR<ReportCommentUncheckedCreateInput, ReportCommentCreateInput>
  }


  /**
   * ReportComment update
   */
  export type ReportCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * The data needed to update a ReportComment.
    **/
    data: XOR<ReportCommentUncheckedUpdateInput, ReportCommentUpdateInput>
    /**
     * Choose, which ReportComment to update.
    **/
    where: ReportCommentWhereUniqueInput
  }


  /**
   * ReportComment updateMany
   */
  export type ReportCommentUpdateManyArgs = {
    data: XOR<ReportCommentUncheckedUpdateManyInput, ReportCommentUpdateManyMutationInput>
    where?: ReportCommentWhereInput
  }


  /**
   * ReportComment upsert
   */
  export type ReportCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * The filter to search for the ReportComment to update in case it exists.
    **/
    where: ReportCommentWhereUniqueInput
    /**
     * In case the ReportComment found by the `where` argument doesn't exist, create a new ReportComment with this data.
    **/
    create: XOR<ReportCommentUncheckedCreateInput, ReportCommentCreateInput>
    /**
     * In case the ReportComment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ReportCommentUncheckedUpdateInput, ReportCommentUpdateInput>
  }


  /**
   * ReportComment delete
   */
  export type ReportCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * Filter which ReportComment to delete.
    **/
    where: ReportCommentWhereUniqueInput
  }


  /**
   * ReportComment deleteMany
   */
  export type ReportCommentDeleteManyArgs = {
    where?: ReportCommentWhereInput
  }


  /**
   * ReportComment without action
   */
  export type ReportCommentArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
  }



  /**
   * Model ReportPost
   */


  export type AggregateReportPost = {
    count: ReportPostCountAggregateOutputType | null
    avg: ReportPostAvgAggregateOutputType | null
    sum: ReportPostSumAggregateOutputType | null
    min: ReportPostMinAggregateOutputType | null
    max: ReportPostMaxAggregateOutputType | null
  }

  export type ReportPostAvgAggregateOutputType = {
    id: number
    postId: number
    userId: number
  }

  export type ReportPostSumAggregateOutputType = {
    id: number
    postId: number
    userId: number
  }

  export type ReportPostMinAggregateOutputType = {
    id: number
    postId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportPostMaxAggregateOutputType = {
    id: number
    postId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportPostCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    title: number | null
    body: number | null
    reportedAt: number | null
    _all: number
  }


  export type ReportPostAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type ReportPostSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type ReportPostMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportPostMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportPostCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
    _all?: true
  }

  export type ReportPostAggregateArgs = {
    /**
     * Filter which ReportPost to aggregate.
    **/
    where?: ReportPostWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ReportPosts to fetch.
    **/
    orderBy?: Enumerable<ReportPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ReportPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPosts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportPosts
    **/
    count?: true | ReportPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ReportPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ReportPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ReportPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ReportPostMaxAggregateInputType
  }

  export type GetReportPostAggregateType<T extends ReportPostAggregateArgs> = {
    [P in keyof T & keyof AggregateReportPost]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportPost[P]>
      : GetScalarType<T[P], AggregateReportPost[P]>
  }



  export type ReportPostSelect = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    reportedAt?: boolean
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type ReportPostInclude = {
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type ReportPostGetPayload<
    S extends boolean | null | undefined | ReportPostArgs,
    U = keyof S
      > = S extends true
        ? ReportPost
    : S extends undefined
    ? never
    : S extends ReportPostArgs | ReportPostFindManyArgs
    ?'include' extends U
    ? ReportPost  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ReportPost ?ReportPost [P]
  : 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ReportPost
  : ReportPost


  type ReportPostCountArgs = Merge<
    Omit<ReportPostFindManyArgs, 'select' | 'include'> & {
      select?: ReportPostCountAggregateInputType | true
    }
  >

  export interface ReportPostDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReportPost that matches the filter.
     * @param {ReportPostFindUniqueArgs} args - Arguments to find a ReportPost
     * @example
     * // Get one ReportPost
     * const reportPost = await prisma.reportPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReportPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReportPost'> extends True ? CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>> : CheckSelect<T, Prisma__ReportPostClient<ReportPost | null >, Prisma__ReportPostClient<ReportPostGetPayload<T> | null >>

    /**
     * Find the first ReportPost that matches the filter.
     * @param {ReportPostFindFirstArgs} args - Arguments to find a ReportPost
     * @example
     * // Get one ReportPost
     * const reportPost = await prisma.reportPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReportPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReportPost'> extends True ? CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>> : CheckSelect<T, Prisma__ReportPostClient<ReportPost | null >, Prisma__ReportPostClient<ReportPostGetPayload<T> | null >>

    /**
     * Find zero or more ReportPosts that matches the filter.
     * @param {ReportPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportPosts
     * const reportPosts = await prisma.reportPost.findMany()
     * 
     * // Get first 10 ReportPosts
     * const reportPosts = await prisma.reportPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportPostWithIdOnly = await prisma.reportPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportPostFindManyArgs>(
      args?: SelectSubset<T, ReportPostFindManyArgs>
    ): CheckSelect<T, Promise<Array<ReportPost>>, Promise<Array<ReportPostGetPayload<T>>>>

    /**
     * Create a ReportPost.
     * @param {ReportPostCreateArgs} args - Arguments to create a ReportPost.
     * @example
     * // Create one ReportPost
     * const ReportPost = await prisma.reportPost.create({
     *   data: {
     *     // ... data to create a ReportPost
     *   }
     * })
     * 
    **/
    create<T extends ReportPostCreateArgs>(
      args: SelectSubset<T, ReportPostCreateArgs>
    ): CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>>

    /**
     * Delete a ReportPost.
     * @param {ReportPostDeleteArgs} args - Arguments to delete one ReportPost.
     * @example
     * // Delete one ReportPost
     * const ReportPost = await prisma.reportPost.delete({
     *   where: {
     *     // ... filter to delete one ReportPost
     *   }
     * })
     * 
    **/
    delete<T extends ReportPostDeleteArgs>(
      args: SelectSubset<T, ReportPostDeleteArgs>
    ): CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>>

    /**
     * Update one ReportPost.
     * @param {ReportPostUpdateArgs} args - Arguments to update one ReportPost.
     * @example
     * // Update one ReportPost
     * const reportPost = await prisma.reportPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportPostUpdateArgs>(
      args: SelectSubset<T, ReportPostUpdateArgs>
    ): CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>>

    /**
     * Delete zero or more ReportPosts.
     * @param {ReportPostDeleteManyArgs} args - Arguments to filter ReportPosts to delete.
     * @example
     * // Delete a few ReportPosts
     * const { count } = await prisma.reportPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportPostDeleteManyArgs>(
      args?: SelectSubset<T, ReportPostDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more ReportPosts.
     * @param {ReportPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportPosts
     * const reportPost = await prisma.reportPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportPostUpdateManyArgs>(
      args: SelectSubset<T, ReportPostUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one ReportPost.
     * @param {ReportPostUpsertArgs} args - Arguments to update or create a ReportPost.
     * @example
     * // Update or create a ReportPost
     * const reportPost = await prisma.reportPost.upsert({
     *   create: {
     *     // ... data to create a ReportPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportPost we want to update
     *   }
     * })
    **/
    upsert<T extends ReportPostUpsertArgs>(
      args: SelectSubset<T, ReportPostUpsertArgs>
    ): CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>>

    /**
     * Count the number of ReportPosts.
     * @param {ReportPostCountArgs} args - Arguments to filter ReportPosts to count.
     * @example
     * // Count the number of ReportPosts
     * const count = await prisma.reportPost.count({
     *   where: {
     *     // ... the filter for the ReportPosts we want to count
     *   }
     * })
    **/
    count<T extends ReportPostCountArgs>(
      args?: Subset<T, ReportPostCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportPost.
     * @param {ReportPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportPostAggregateArgs>(args: Subset<T, ReportPostAggregateArgs>): Promise<GetReportPostAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportPostClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityPost<T extends CommunityPostArgs = {}>(args?: Subset<T, CommunityPostArgs>): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReportPost findUnique
   */
  export type ReportPostFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * Throw an Error if a ReportPost can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportPost to fetch.
    **/
    where: ReportPostWhereUniqueInput
  }


  /**
   * ReportPost findFirst
   */
  export type ReportPostFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * Throw an Error if a ReportPost can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportPost to fetch.
    **/
    where?: ReportPostWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ReportPosts to fetch.
    **/
    orderBy?: Enumerable<ReportPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportPosts.
    **/
    cursor?: ReportPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPosts.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of ReportPosts.
    **/
    distinct?: Enumerable<ReportPostScalarFieldEnum>
  }


  /**
   * ReportPost findMany
   */
  export type ReportPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * Filter, which ReportPosts to fetch.
    **/
    where?: ReportPostWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ReportPosts to fetch.
    **/
    orderBy?: Enumerable<ReportPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportPosts.
    **/
    cursor?: ReportPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPosts.
    **/
    skip?: number
    distinct?: Enumerable<ReportPostScalarFieldEnum>
  }


  /**
   * ReportPost create
   */
  export type ReportPostCreateArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * The data needed to create a ReportPost.
    **/
    data: XOR<ReportPostUncheckedCreateInput, ReportPostCreateInput>
  }


  /**
   * ReportPost update
   */
  export type ReportPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * The data needed to update a ReportPost.
    **/
    data: XOR<ReportPostUncheckedUpdateInput, ReportPostUpdateInput>
    /**
     * Choose, which ReportPost to update.
    **/
    where: ReportPostWhereUniqueInput
  }


  /**
   * ReportPost updateMany
   */
  export type ReportPostUpdateManyArgs = {
    data: XOR<ReportPostUncheckedUpdateManyInput, ReportPostUpdateManyMutationInput>
    where?: ReportPostWhereInput
  }


  /**
   * ReportPost upsert
   */
  export type ReportPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * The filter to search for the ReportPost to update in case it exists.
    **/
    where: ReportPostWhereUniqueInput
    /**
     * In case the ReportPost found by the `where` argument doesn't exist, create a new ReportPost with this data.
    **/
    create: XOR<ReportPostUncheckedCreateInput, ReportPostCreateInput>
    /**
     * In case the ReportPost was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ReportPostUncheckedUpdateInput, ReportPostUpdateInput>
  }


  /**
   * ReportPost delete
   */
  export type ReportPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * Filter which ReportPost to delete.
    **/
    where: ReportPostWhereUniqueInput
  }


  /**
   * ReportPost deleteMany
   */
  export type ReportPostDeleteManyArgs = {
    where?: ReportPostWhereInput
  }


  /**
   * ReportPost without action
   */
  export type ReportPostArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
  }



  /**
   * Model ReportSubcomment
   */


  export type AggregateReportSubcomment = {
    count: ReportSubcommentCountAggregateOutputType | null
    avg: ReportSubcommentAvgAggregateOutputType | null
    sum: ReportSubcommentSumAggregateOutputType | null
    min: ReportSubcommentMinAggregateOutputType | null
    max: ReportSubcommentMaxAggregateOutputType | null
  }

  export type ReportSubcommentAvgAggregateOutputType = {
    id: number
    subcommentId: number
    userId: number
  }

  export type ReportSubcommentSumAggregateOutputType = {
    id: number
    subcommentId: number
    userId: number
  }

  export type ReportSubcommentMinAggregateOutputType = {
    id: number
    subcommentId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportSubcommentMaxAggregateOutputType = {
    id: number
    subcommentId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportSubcommentCountAggregateOutputType = {
    id: number
    subcommentId: number
    userId: number
    title: number | null
    body: number | null
    reportedAt: number | null
    _all: number
  }


  export type ReportSubcommentAvgAggregateInputType = {
    id?: true
    subcommentId?: true
    userId?: true
  }

  export type ReportSubcommentSumAggregateInputType = {
    id?: true
    subcommentId?: true
    userId?: true
  }

  export type ReportSubcommentMinAggregateInputType = {
    id?: true
    subcommentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportSubcommentMaxAggregateInputType = {
    id?: true
    subcommentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportSubcommentCountAggregateInputType = {
    id?: true
    subcommentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
    _all?: true
  }

  export type ReportSubcommentAggregateArgs = {
    /**
     * Filter which ReportSubcomment to aggregate.
    **/
    where?: ReportSubcommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ReportSubcomments to fetch.
    **/
    orderBy?: Enumerable<ReportSubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ReportSubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSubcomments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportSubcomments
    **/
    count?: true | ReportSubcommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ReportSubcommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ReportSubcommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ReportSubcommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ReportSubcommentMaxAggregateInputType
  }

  export type GetReportSubcommentAggregateType<T extends ReportSubcommentAggregateArgs> = {
    [P in keyof T & keyof AggregateReportSubcomment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportSubcomment[P]>
      : GetScalarType<T[P], AggregateReportSubcomment[P]>
  }



  export type ReportSubcommentSelect = {
    id?: boolean
    subcommentId?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    reportedAt?: boolean
    communitySubcomment?: boolean | CommunitySubcommentArgs
    user?: boolean | UserArgs
  }

  export type ReportSubcommentInclude = {
    communitySubcomment?: boolean | CommunitySubcommentArgs
    user?: boolean | UserArgs
  }

  export type ReportSubcommentGetPayload<
    S extends boolean | null | undefined | ReportSubcommentArgs,
    U = keyof S
      > = S extends true
        ? ReportSubcomment
    : S extends undefined
    ? never
    : S extends ReportSubcommentArgs | ReportSubcommentFindManyArgs
    ?'include' extends U
    ? ReportSubcomment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communitySubcomment'
        ? CommunitySubcommentGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ReportSubcomment ?ReportSubcomment [P]
  : 
          P extends 'communitySubcomment'
        ? CommunitySubcommentGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ReportSubcomment
  : ReportSubcomment


  type ReportSubcommentCountArgs = Merge<
    Omit<ReportSubcommentFindManyArgs, 'select' | 'include'> & {
      select?: ReportSubcommentCountAggregateInputType | true
    }
  >

  export interface ReportSubcommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReportSubcomment that matches the filter.
     * @param {ReportSubcommentFindUniqueArgs} args - Arguments to find a ReportSubcomment
     * @example
     * // Get one ReportSubcomment
     * const reportSubcomment = await prisma.reportSubcomment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportSubcommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReportSubcommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReportSubcomment'> extends True ? CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>> : CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment | null >, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T> | null >>

    /**
     * Find the first ReportSubcomment that matches the filter.
     * @param {ReportSubcommentFindFirstArgs} args - Arguments to find a ReportSubcomment
     * @example
     * // Get one ReportSubcomment
     * const reportSubcomment = await prisma.reportSubcomment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportSubcommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReportSubcommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReportSubcomment'> extends True ? CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>> : CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment | null >, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T> | null >>

    /**
     * Find zero or more ReportSubcomments that matches the filter.
     * @param {ReportSubcommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportSubcomments
     * const reportSubcomments = await prisma.reportSubcomment.findMany()
     * 
     * // Get first 10 ReportSubcomments
     * const reportSubcomments = await prisma.reportSubcomment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportSubcommentWithIdOnly = await prisma.reportSubcomment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportSubcommentFindManyArgs>(
      args?: SelectSubset<T, ReportSubcommentFindManyArgs>
    ): CheckSelect<T, Promise<Array<ReportSubcomment>>, Promise<Array<ReportSubcommentGetPayload<T>>>>

    /**
     * Create a ReportSubcomment.
     * @param {ReportSubcommentCreateArgs} args - Arguments to create a ReportSubcomment.
     * @example
     * // Create one ReportSubcomment
     * const ReportSubcomment = await prisma.reportSubcomment.create({
     *   data: {
     *     // ... data to create a ReportSubcomment
     *   }
     * })
     * 
    **/
    create<T extends ReportSubcommentCreateArgs>(
      args: SelectSubset<T, ReportSubcommentCreateArgs>
    ): CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>>

    /**
     * Delete a ReportSubcomment.
     * @param {ReportSubcommentDeleteArgs} args - Arguments to delete one ReportSubcomment.
     * @example
     * // Delete one ReportSubcomment
     * const ReportSubcomment = await prisma.reportSubcomment.delete({
     *   where: {
     *     // ... filter to delete one ReportSubcomment
     *   }
     * })
     * 
    **/
    delete<T extends ReportSubcommentDeleteArgs>(
      args: SelectSubset<T, ReportSubcommentDeleteArgs>
    ): CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>>

    /**
     * Update one ReportSubcomment.
     * @param {ReportSubcommentUpdateArgs} args - Arguments to update one ReportSubcomment.
     * @example
     * // Update one ReportSubcomment
     * const reportSubcomment = await prisma.reportSubcomment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportSubcommentUpdateArgs>(
      args: SelectSubset<T, ReportSubcommentUpdateArgs>
    ): CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>>

    /**
     * Delete zero or more ReportSubcomments.
     * @param {ReportSubcommentDeleteManyArgs} args - Arguments to filter ReportSubcomments to delete.
     * @example
     * // Delete a few ReportSubcomments
     * const { count } = await prisma.reportSubcomment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportSubcommentDeleteManyArgs>(
      args?: SelectSubset<T, ReportSubcommentDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more ReportSubcomments.
     * @param {ReportSubcommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportSubcomments
     * const reportSubcomment = await prisma.reportSubcomment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportSubcommentUpdateManyArgs>(
      args: SelectSubset<T, ReportSubcommentUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one ReportSubcomment.
     * @param {ReportSubcommentUpsertArgs} args - Arguments to update or create a ReportSubcomment.
     * @example
     * // Update or create a ReportSubcomment
     * const reportSubcomment = await prisma.reportSubcomment.upsert({
     *   create: {
     *     // ... data to create a ReportSubcomment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportSubcomment we want to update
     *   }
     * })
    **/
    upsert<T extends ReportSubcommentUpsertArgs>(
      args: SelectSubset<T, ReportSubcommentUpsertArgs>
    ): CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>>

    /**
     * Count the number of ReportSubcomments.
     * @param {ReportSubcommentCountArgs} args - Arguments to filter ReportSubcomments to count.
     * @example
     * // Count the number of ReportSubcomments
     * const count = await prisma.reportSubcomment.count({
     *   where: {
     *     // ... the filter for the ReportSubcomments we want to count
     *   }
     * })
    **/
    count<T extends ReportSubcommentCountArgs>(
      args?: Subset<T, ReportSubcommentCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportSubcommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportSubcomment.
     * @param {ReportSubcommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportSubcommentAggregateArgs>(args: Subset<T, ReportSubcommentAggregateArgs>): Promise<GetReportSubcommentAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportSubcomment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportSubcommentClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communitySubcomment<T extends CommunitySubcommentArgs = {}>(args?: Subset<T, CommunitySubcommentArgs>): CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment | null >, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReportSubcomment findUnique
   */
  export type ReportSubcommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * Throw an Error if a ReportSubcomment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportSubcomment to fetch.
    **/
    where: ReportSubcommentWhereUniqueInput
  }


  /**
   * ReportSubcomment findFirst
   */
  export type ReportSubcommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * Throw an Error if a ReportSubcomment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportSubcomment to fetch.
    **/
    where?: ReportSubcommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ReportSubcomments to fetch.
    **/
    orderBy?: Enumerable<ReportSubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportSubcomments.
    **/
    cursor?: ReportSubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSubcomments.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of ReportSubcomments.
    **/
    distinct?: Enumerable<ReportSubcommentScalarFieldEnum>
  }


  /**
   * ReportSubcomment findMany
   */
  export type ReportSubcommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * Filter, which ReportSubcomments to fetch.
    **/
    where?: ReportSubcommentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of ReportSubcomments to fetch.
    **/
    orderBy?: Enumerable<ReportSubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportSubcomments.
    **/
    cursor?: ReportSubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSubcomments.
    **/
    skip?: number
    distinct?: Enumerable<ReportSubcommentScalarFieldEnum>
  }


  /**
   * ReportSubcomment create
   */
  export type ReportSubcommentCreateArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * The data needed to create a ReportSubcomment.
    **/
    data: XOR<ReportSubcommentUncheckedCreateInput, ReportSubcommentCreateInput>
  }


  /**
   * ReportSubcomment update
   */
  export type ReportSubcommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * The data needed to update a ReportSubcomment.
    **/
    data: XOR<ReportSubcommentUncheckedUpdateInput, ReportSubcommentUpdateInput>
    /**
     * Choose, which ReportSubcomment to update.
    **/
    where: ReportSubcommentWhereUniqueInput
  }


  /**
   * ReportSubcomment updateMany
   */
  export type ReportSubcommentUpdateManyArgs = {
    data: XOR<ReportSubcommentUncheckedUpdateManyInput, ReportSubcommentUpdateManyMutationInput>
    where?: ReportSubcommentWhereInput
  }


  /**
   * ReportSubcomment upsert
   */
  export type ReportSubcommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * The filter to search for the ReportSubcomment to update in case it exists.
    **/
    where: ReportSubcommentWhereUniqueInput
    /**
     * In case the ReportSubcomment found by the `where` argument doesn't exist, create a new ReportSubcomment with this data.
    **/
    create: XOR<ReportSubcommentUncheckedCreateInput, ReportSubcommentCreateInput>
    /**
     * In case the ReportSubcomment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ReportSubcommentUncheckedUpdateInput, ReportSubcommentUpdateInput>
  }


  /**
   * ReportSubcomment delete
   */
  export type ReportSubcommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * Filter which ReportSubcomment to delete.
    **/
    where: ReportSubcommentWhereUniqueInput
  }


  /**
   * ReportSubcomment deleteMany
   */
  export type ReportSubcommentDeleteManyArgs = {
    where?: ReportSubcommentWhereInput
  }


  /**
   * ReportSubcomment without action
   */
  export type ReportSubcommentArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AdminScalarFieldEnum: {
    userId: 'userId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const CafeteriaMenuScalarFieldEnum: {
    campus: 'campus',
    servedAt: 'servedAt',
    data: 'data'
  };

  export type CafeteriaMenuScalarFieldEnum = (typeof CafeteriaMenuScalarFieldEnum)[keyof typeof CafeteriaMenuScalarFieldEnum]


  export const ChangePasswordScalarFieldEnum: {
    userId: 'userId',
    token: 'token',
    requestedAt: 'requestedAt'
  };

  export type ChangePasswordScalarFieldEnum = (typeof ChangePasswordScalarFieldEnum)[keyof typeof ChangePasswordScalarFieldEnum]


  export const CommunityBoardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    priority: 'priority',
    isDeleted: 'isDeleted',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    activeAt: 'activeAt'
  };

  export type CommunityBoardScalarFieldEnum = (typeof CommunityBoardScalarFieldEnum)[keyof typeof CommunityBoardScalarFieldEnum]


  export const CommunityBoardCandidateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type CommunityBoardCandidateScalarFieldEnum = (typeof CommunityBoardCandidateScalarFieldEnum)[keyof typeof CommunityBoardCandidateScalarFieldEnum]


  export const CommunityBoardCandidateVoteScalarFieldEnum: {
    boardCandidateId: 'boardCandidateId',
    userId: 'userId'
  };

  export type CommunityBoardCandidateVoteScalarFieldEnum = (typeof CommunityBoardCandidateVoteScalarFieldEnum)[keyof typeof CommunityBoardCandidateVoteScalarFieldEnum]


  export const CommunityBoardPinScalarFieldEnum: {
    userId: 'userId',
    boardId: 'boardId'
  };

  export type CommunityBoardPinScalarFieldEnum = (typeof CommunityBoardPinScalarFieldEnum)[keyof typeof CommunityBoardPinScalarFieldEnum]


  export const CommunityCommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    randomNickname: 'randomNickname',
    body: 'body',
    commentedAt: 'commentedAt',
    isDeleted: 'isDeleted'
  };

  export type CommunityCommentScalarFieldEnum = (typeof CommunityCommentScalarFieldEnum)[keyof typeof CommunityCommentScalarFieldEnum]


  export const CommunityPostScalarFieldEnum: {
    id: 'id',
    boardId: 'boardId',
    userId: 'userId',
    title: 'title',
    body: 'body',
    randomNickname: 'randomNickname',
    likesCount: 'likesCount',
    commentsCount: 'commentsCount',
    bookmarksCount: 'bookmarksCount',
    postedAt: 'postedAt',
    editedAt: 'editedAt',
    isDeleted: 'isDeleted'
  };

  export type CommunityPostScalarFieldEnum = (typeof CommunityPostScalarFieldEnum)[keyof typeof CommunityPostScalarFieldEnum]


  export const CommunityPostBookmarkScalarFieldEnum: {
    userId: 'userId',
    postId: 'postId'
  };

  export type CommunityPostBookmarkScalarFieldEnum = (typeof CommunityPostBookmarkScalarFieldEnum)[keyof typeof CommunityPostBookmarkScalarFieldEnum]


  export const CommunityPostLikeScalarFieldEnum: {
    userId: 'userId',
    postId: 'postId'
  };

  export type CommunityPostLikeScalarFieldEnum = (typeof CommunityPostLikeScalarFieldEnum)[keyof typeof CommunityPostLikeScalarFieldEnum]


  export const CommunitySubcommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    postId: 'postId',
    commentId: 'commentId',
    randomNickname: 'randomNickname',
    body: 'body',
    subcommentedAt: 'subcommentedAt',
    isDeleted: 'isDeleted'
  };

  export type CommunitySubcommentScalarFieldEnum = (typeof CommunitySubcommentScalarFieldEnum)[keyof typeof CommunitySubcommentScalarFieldEnum]


  export const CoverageMajorScalarFieldEnum: {
    coverageCollege: 'coverageCollege',
    name: 'name',
    code: 'code'
  };

  export type CoverageMajorScalarFieldEnum = (typeof CoverageMajorScalarFieldEnum)[keyof typeof CoverageMajorScalarFieldEnum]


  export const CoverageMajorLectureScalarFieldEnum: {
    lectureId: 'lectureId',
    majorCode: 'majorCode'
  };

  export type CoverageMajorLectureScalarFieldEnum = (typeof CoverageMajorLectureScalarFieldEnum)[keyof typeof CoverageMajorLectureScalarFieldEnum]


  export const LectureScalarFieldEnum: {
    id: 'id',
    year: 'year',
    semester: 'semester',
    campus: 'campus',
    college: 'college',
    major: 'major',
    grade: 'grade',
    credit: 'credit',
    course: 'course',
    section: 'section',
    code: 'code',
    name: 'name',
    professor: 'professor',
    schedule: 'schedule',
    building: 'building',
    room: 'room',
    note: 'note'
  };

  export type LectureScalarFieldEnum = (typeof LectureScalarFieldEnum)[keyof typeof LectureScalarFieldEnum]


  export const LiveChatScalarFieldEnum: {
    id: 'id',
    message: 'message',
    createdAt: 'createdAt',
    userId: 'userId',
    randomNickname: 'randomNickname'
  };

  export type LiveChatScalarFieldEnum = (typeof LiveChatScalarFieldEnum)[keyof typeof LiveChatScalarFieldEnum]


  export const NoticeNotificationsSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    noticeKey: 'noticeKey',
    subscribedAt: 'subscribedAt'
  };

  export type NoticeNotificationsSubscriptionScalarFieldEnum = (typeof NoticeNotificationsSubscriptionScalarFieldEnum)[keyof typeof NoticeNotificationsSubscriptionScalarFieldEnum]


  export const PendingUserScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    password: 'password',
    nickname: 'nickname',
    randomNickname: 'randomNickname',
    joinedAt: 'joinedAt',
    token: 'token'
  };

  export type PendingUserScalarFieldEnum = (typeof PendingUserScalarFieldEnum)[keyof typeof PendingUserScalarFieldEnum]


  export const PeriodScalarFieldEnum: {
    lectureId: 'lectureId',
    day: 'day',
    startH: 'startH',
    startM: 'startM',
    endH: 'endH',
    endM: 'endM'
  };

  export type PeriodScalarFieldEnum = (typeof PeriodScalarFieldEnum)[keyof typeof PeriodScalarFieldEnum]


  export const PushScalarFieldEnum: {
    userId: 'userId',
    expoPushToken: 'expoPushToken',
    registeredAt: 'registeredAt',
    activeAt: 'activeAt'
  };

  export type PushScalarFieldEnum = (typeof PushScalarFieldEnum)[keyof typeof PushScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    password: 'password',
    nickname: 'nickname',
    randomNickname: 'randomNickname',
    joinedAt: 'joinedAt',
    refreshToken: 'refreshToken'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ReportCommentScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    userId: 'userId',
    title: 'title',
    body: 'body',
    reportedAt: 'reportedAt'
  };

  export type ReportCommentScalarFieldEnum = (typeof ReportCommentScalarFieldEnum)[keyof typeof ReportCommentScalarFieldEnum]


  export const ReportPostScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    title: 'title',
    body: 'body',
    reportedAt: 'reportedAt'
  };

  export type ReportPostScalarFieldEnum = (typeof ReportPostScalarFieldEnum)[keyof typeof ReportPostScalarFieldEnum]


  export const ReportSubcommentScalarFieldEnum: {
    id: 'id',
    subcommentId: 'subcommentId',
    userId: 'userId',
    title: 'title',
    body: 'body',
    reportedAt: 'reportedAt'
  };

  export type ReportSubcommentScalarFieldEnum = (typeof ReportSubcommentScalarFieldEnum)[keyof typeof ReportSubcommentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: Enumerable<AdminWhereInput>
    OR?: Enumerable<AdminWhereInput>
    NOT?: Enumerable<AdminWhereInput>
    userId?: IntFilter | number
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type AdminOrderByInput = {
    userId?: SortOrder
  }

  export type AdminWhereUniqueInput = {
    userId?: number
  }

  export type CafeteriaMenuWhereInput = {
    AND?: Enumerable<CafeteriaMenuWhereInput>
    OR?: Enumerable<CafeteriaMenuWhereInput>
    NOT?: Enumerable<CafeteriaMenuWhereInput>
    campus?: StringFilter | string
    servedAt?: DateTimeFilter | Date | string
    data?: JsonNullableFilter
  }

  export type CafeteriaMenuOrderByInput = {
    campus?: SortOrder
    servedAt?: SortOrder
    data?: SortOrder
  }

  export type CafeteriaMenuWhereUniqueInput = {
    campus_servedAt?: CafeteriaMenuCampusServedAtCompoundUniqueInput
  }

  export type ChangePasswordWhereInput = {
    AND?: Enumerable<ChangePasswordWhereInput>
    OR?: Enumerable<ChangePasswordWhereInput>
    NOT?: Enumerable<ChangePasswordWhereInput>
    userId?: IntFilter | number
    token?: StringFilter | string
    requestedAt?: DateTimeFilter | Date | string
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type ChangePasswordOrderByInput = {
    userId?: SortOrder
    token?: SortOrder
    requestedAt?: SortOrder
  }

  export type ChangePasswordWhereUniqueInput = {
    userId?: number
    token?: string
  }

  export type CommunityBoardWhereInput = {
    AND?: Enumerable<CommunityBoardWhereInput>
    OR?: Enumerable<CommunityBoardWhereInput>
    NOT?: Enumerable<CommunityBoardWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    priority?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    createdBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    activeAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserWhereInput, UserRelationFilter>
    communityBoardPins?: CommunityBoardPinListRelationFilter
    communityPosts?: CommunityPostListRelationFilter
  }

  export type CommunityBoardOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    isDeleted?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    activeAt?: SortOrder
    user?: UserOrderByInput
  }

  export type CommunityBoardWhereUniqueInput = {
    id?: number
  }

  export type CommunityBoardCandidateWhereInput = {
    AND?: Enumerable<CommunityBoardCandidateWhereInput>
    OR?: Enumerable<CommunityBoardCandidateWhereInput>
    NOT?: Enumerable<CommunityBoardCandidateWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserWhereInput, UserRelationFilter>
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteListRelationFilter
  }

  export type CommunityBoardCandidateOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByInput
  }

  export type CommunityBoardCandidateWhereUniqueInput = {
    id?: number
  }

  export type CommunityBoardCandidateVoteWhereInput = {
    AND?: Enumerable<CommunityBoardCandidateVoteWhereInput>
    OR?: Enumerable<CommunityBoardCandidateVoteWhereInput>
    NOT?: Enumerable<CommunityBoardCandidateVoteWhereInput>
    boardCandidateId?: IntFilter | number
    userId?: IntFilter | number
    communityBoardCandidate?: XOR<CommunityBoardCandidateWhereInput, CommunityBoardCandidateRelationFilter>
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type CommunityBoardCandidateVoteOrderByInput = {
    boardCandidateId?: SortOrder
    userId?: SortOrder
    communityBoardCandidate?: CommunityBoardCandidateOrderByInput
    user?: UserOrderByInput
  }

  export type CommunityBoardCandidateVoteWhereUniqueInput = {
    boardCandidateId_userId?: CommunityBoardCandidateVoteBoardCandidateIdUserIdCompoundUniqueInput
  }

  export type CommunityBoardPinWhereInput = {
    AND?: Enumerable<CommunityBoardPinWhereInput>
    OR?: Enumerable<CommunityBoardPinWhereInput>
    NOT?: Enumerable<CommunityBoardPinWhereInput>
    userId?: IntFilter | number
    boardId?: IntFilter | number
    communityBoard?: XOR<CommunityBoardWhereInput, CommunityBoardRelationFilter>
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type CommunityBoardPinOrderByInput = {
    userId?: SortOrder
    boardId?: SortOrder
    communityBoard?: CommunityBoardOrderByInput
    user?: UserOrderByInput
  }

  export type CommunityBoardPinWhereUniqueInput = {
    userId_boardId?: CommunityBoardPinUserIdBoardIdCompoundUniqueInput
  }

  export type CommunityCommentWhereInput = {
    AND?: Enumerable<CommunityCommentWhereInput>
    OR?: Enumerable<CommunityCommentWhereInput>
    NOT?: Enumerable<CommunityCommentWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    userId?: IntFilter | number
    randomNickname?: StringFilter | string
    body?: StringFilter | string
    commentedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    communityPost?: XOR<CommunityPostWhereInput, CommunityPostRelationFilter>
    user?: XOR<UserWhereInput, UserRelationFilter>
    communitySubcomments?: CommunitySubcommentListRelationFilter
    reportComments?: ReportCommentListRelationFilter
  }

  export type CommunityCommentOrderByInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    randomNickname?: SortOrder
    body?: SortOrder
    commentedAt?: SortOrder
    isDeleted?: SortOrder
    communityPost?: CommunityPostOrderByInput
    user?: UserOrderByInput
  }

  export type CommunityCommentWhereUniqueInput = {
    id?: number
  }

  export type CommunityPostWhereInput = {
    AND?: Enumerable<CommunityPostWhereInput>
    OR?: Enumerable<CommunityPostWhereInput>
    NOT?: Enumerable<CommunityPostWhereInput>
    id?: IntFilter | number
    boardId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringFilter | string
    randomNickname?: StringFilter | string
    likesCount?: IntFilter | number
    commentsCount?: IntFilter | number
    bookmarksCount?: IntFilter | number
    postedAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeNullableFilter | Date | string | null
    isDeleted?: BoolFilter | boolean
    communityBoard?: XOR<CommunityBoardWhereInput, CommunityBoardRelationFilter>
    user?: XOR<UserWhereInput, UserRelationFilter>
    communityComments?: CommunityCommentListRelationFilter
    communityPostBookmarks?: CommunityPostBookmarkListRelationFilter
    communityPostLikes?: CommunityPostLikeListRelationFilter
    communitySubcomments?: CommunitySubcommentListRelationFilter
    reportPosts?: ReportPostListRelationFilter
  }

  export type CommunityPostOrderByInput = {
    id?: SortOrder
    boardId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    randomNickname?: SortOrder
    likesCount?: SortOrder
    commentsCount?: SortOrder
    bookmarksCount?: SortOrder
    postedAt?: SortOrder
    editedAt?: SortOrder
    isDeleted?: SortOrder
    communityBoard?: CommunityBoardOrderByInput
    user?: UserOrderByInput
  }

  export type CommunityPostWhereUniqueInput = {
    id?: number
  }

  export type CommunityPostBookmarkWhereInput = {
    AND?: Enumerable<CommunityPostBookmarkWhereInput>
    OR?: Enumerable<CommunityPostBookmarkWhereInput>
    NOT?: Enumerable<CommunityPostBookmarkWhereInput>
    userId?: IntFilter | number
    postId?: IntFilter | number
    communityPost?: XOR<CommunityPostWhereInput, CommunityPostRelationFilter>
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type CommunityPostBookmarkOrderByInput = {
    userId?: SortOrder
    postId?: SortOrder
    communityPost?: CommunityPostOrderByInput
    user?: UserOrderByInput
  }

  export type CommunityPostBookmarkWhereUniqueInput = {
    userId_postId?: CommunityPostBookmarkUserIdPostIdCompoundUniqueInput
  }

  export type CommunityPostLikeWhereInput = {
    AND?: Enumerable<CommunityPostLikeWhereInput>
    OR?: Enumerable<CommunityPostLikeWhereInput>
    NOT?: Enumerable<CommunityPostLikeWhereInput>
    userId?: IntFilter | number
    postId?: IntFilter | number
    communityPost?: XOR<CommunityPostWhereInput, CommunityPostRelationFilter>
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type CommunityPostLikeOrderByInput = {
    userId?: SortOrder
    postId?: SortOrder
    communityPost?: CommunityPostOrderByInput
    user?: UserOrderByInput
  }

  export type CommunityPostLikeWhereUniqueInput = {
    userId_postId?: CommunityPostLikeUserIdPostIdCompoundUniqueInput
  }

  export type CommunitySubcommentWhereInput = {
    AND?: Enumerable<CommunitySubcommentWhereInput>
    OR?: Enumerable<CommunitySubcommentWhereInput>
    NOT?: Enumerable<CommunitySubcommentWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    postId?: IntFilter | number
    commentId?: IntFilter | number
    randomNickname?: StringFilter | string
    body?: StringFilter | string
    subcommentedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    communityComment?: XOR<CommunityCommentWhereInput, CommunityCommentRelationFilter>
    communityPost?: XOR<CommunityPostWhereInput, CommunityPostRelationFilter>
    user?: XOR<UserWhereInput, UserRelationFilter>
    reportSubcomments?: ReportSubcommentListRelationFilter
  }

  export type CommunitySubcommentOrderByInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    randomNickname?: SortOrder
    body?: SortOrder
    subcommentedAt?: SortOrder
    isDeleted?: SortOrder
    communityComment?: CommunityCommentOrderByInput
    communityPost?: CommunityPostOrderByInput
    user?: UserOrderByInput
  }

  export type CommunitySubcommentWhereUniqueInput = {
    id?: number
  }

  export type CoverageMajorWhereInput = {
    AND?: Enumerable<CoverageMajorWhereInput>
    OR?: Enumerable<CoverageMajorWhereInput>
    NOT?: Enumerable<CoverageMajorWhereInput>
    coverageCollege?: StringNullableFilter | string | null
    name?: StringFilter | string
    code?: StringFilter | string
    coverageMajorLectures?: CoverageMajorLectureListRelationFilter
  }

  export type CoverageMajorOrderByInput = {
    coverageCollege?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type CoverageMajorWhereUniqueInput = {
    code?: string
  }

  export type CoverageMajorLectureWhereInput = {
    AND?: Enumerable<CoverageMajorLectureWhereInput>
    OR?: Enumerable<CoverageMajorLectureWhereInput>
    NOT?: Enumerable<CoverageMajorLectureWhereInput>
    lectureId?: StringFilter | string
    majorCode?: StringFilter | string
    lecture?: XOR<LectureWhereInput, LectureRelationFilter>
    coverageMajor?: XOR<CoverageMajorWhereInput, CoverageMajorRelationFilter>
  }

  export type CoverageMajorLectureOrderByInput = {
    lectureId?: SortOrder
    majorCode?: SortOrder
    lecture?: LectureOrderByInput
    coverageMajor?: CoverageMajorOrderByInput
  }

  export type CoverageMajorLectureWhereUniqueInput = {
    lectureId_majorCode?: CoverageMajorLectureLectureIdMajorCodeCompoundUniqueInput
  }

  export type LectureWhereInput = {
    AND?: Enumerable<LectureWhereInput>
    OR?: Enumerable<LectureWhereInput>
    NOT?: Enumerable<LectureWhereInput>
    id?: StringFilter | string
    year?: IntNullableFilter | number | null
    semester?: StringNullableFilter | string | null
    campus?: StringNullableFilter | string | null
    college?: StringNullableFilter | string | null
    major?: StringNullableFilter | string | null
    grade?: IntNullableFilter | number | null
    credit?: IntNullableFilter | number | null
    course?: StringNullableFilter | string | null
    section?: StringNullableFilter | string | null
    code?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    professor?: StringNullableFilter | string | null
    schedule?: StringNullableFilter | string | null
    building?: IntNullableFilter | number | null
    room?: StringNullableFilter | string | null
    note?: StringNullableFilter | string | null
    coverageMajorLectures?: CoverageMajorLectureListRelationFilter
    periods?: PeriodListRelationFilter
  }

  export type LectureOrderByInput = {
    id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    campus?: SortOrder
    college?: SortOrder
    major?: SortOrder
    grade?: SortOrder
    credit?: SortOrder
    course?: SortOrder
    section?: SortOrder
    code?: SortOrder
    name?: SortOrder
    professor?: SortOrder
    schedule?: SortOrder
    building?: SortOrder
    room?: SortOrder
    note?: SortOrder
  }

  export type LectureWhereUniqueInput = {
    id?: string
  }

  export type LiveChatWhereInput = {
    AND?: Enumerable<LiveChatWhereInput>
    OR?: Enumerable<LiveChatWhereInput>
    NOT?: Enumerable<LiveChatWhereInput>
    id?: IntFilter | number
    message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    randomNickname?: StringFilter | string
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type LiveChatOrderByInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    randomNickname?: SortOrder
    user?: UserOrderByInput
  }

  export type LiveChatWhereUniqueInput = {
    id_userId?: LiveChatIdUserIdCompoundUniqueInput
  }

  export type NoticeNotificationsSubscriptionWhereInput = {
    AND?: Enumerable<NoticeNotificationsSubscriptionWhereInput>
    OR?: Enumerable<NoticeNotificationsSubscriptionWhereInput>
    NOT?: Enumerable<NoticeNotificationsSubscriptionWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    noticeKey?: StringFilter | string
    subscribedAt?: DateTimeFilter | Date | string
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type NoticeNotificationsSubscriptionOrderByInput = {
    id?: SortOrder
    userId?: SortOrder
    noticeKey?: SortOrder
    subscribedAt?: SortOrder
    user?: UserOrderByInput
  }

  export type NoticeNotificationsSubscriptionWhereUniqueInput = {
    id?: number
  }

  export type PendingUserWhereInput = {
    AND?: Enumerable<PendingUserWhereInput>
    OR?: Enumerable<PendingUserWhereInput>
    NOT?: Enumerable<PendingUserWhereInput>
    id?: IntFilter | number
    portalId?: StringFilter | string
    password?: StringFilter | string
    nickname?: StringFilter | string
    randomNickname?: StringFilter | string
    joinedAt?: DateTimeFilter | Date | string
    token?: StringFilter | string
  }

  export type PendingUserOrderByInput = {
    id?: SortOrder
    portalId?: SortOrder
    password?: SortOrder
    nickname?: SortOrder
    randomNickname?: SortOrder
    joinedAt?: SortOrder
    token?: SortOrder
  }

  export type PendingUserWhereUniqueInput = {
    id?: number
    portalId?: string
    nickname?: string
    token?: string
  }

  export type PeriodWhereInput = {
    AND?: Enumerable<PeriodWhereInput>
    OR?: Enumerable<PeriodWhereInput>
    NOT?: Enumerable<PeriodWhereInput>
    lectureId?: StringFilter | string
    day?: StringFilter | string
    startH?: IntFilter | number
    startM?: IntFilter | number
    endH?: IntFilter | number
    endM?: IntFilter | number
    lecture?: XOR<LectureWhereInput, LectureRelationFilter>
  }

  export type PeriodOrderByInput = {
    lectureId?: SortOrder
    day?: SortOrder
    startH?: SortOrder
    startM?: SortOrder
    endH?: SortOrder
    endM?: SortOrder
    lecture?: LectureOrderByInput
  }

  export type PeriodWhereUniqueInput = {
    lectureId_day_startH_startM_endH_endM?: PeriodLectureIdDayStartHStartMEndHEndMCompoundUniqueInput
  }

  export type PushWhereInput = {
    AND?: Enumerable<PushWhereInput>
    OR?: Enumerable<PushWhereInput>
    NOT?: Enumerable<PushWhereInput>
    userId?: IntFilter | number
    expoPushToken?: StringFilter | string
    registeredAt?: DateTimeFilter | Date | string
    activeAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type PushOrderByInput = {
    userId?: SortOrder
    expoPushToken?: SortOrder
    registeredAt?: SortOrder
    activeAt?: SortOrder
    user?: UserOrderByInput
  }

  export type PushWhereUniqueInput = {
    expoPushToken?: string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    portalId?: StringFilter | string
    password?: StringFilter | string
    nickname?: StringFilter | string
    randomNickname?: StringFilter | string
    joinedAt?: DateTimeFilter | Date | string
    refreshToken?: StringNullableFilter | string | null
    admin?: XOR<AdminWhereInput, AdminRelationFilter> | null
    changePassword?: XOR<ChangePasswordWhereInput, ChangePasswordRelationFilter> | null
    communityBoards?: CommunityBoardListRelationFilter
    communityBoardCandidates?: CommunityBoardCandidateListRelationFilter
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteListRelationFilter
    communityBoardPins?: CommunityBoardPinListRelationFilter
    communityComments?: CommunityCommentListRelationFilter
    communityPosts?: CommunityPostListRelationFilter
    communityPostBookmarks?: CommunityPostBookmarkListRelationFilter
    communityPostLikes?: CommunityPostLikeListRelationFilter
    communitySubcomments?: CommunitySubcommentListRelationFilter
    liveChats?: LiveChatListRelationFilter
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionListRelationFilter
    pushes?: PushListRelationFilter
    reportComments?: ReportCommentListRelationFilter
    reportPosts?: ReportPostListRelationFilter
    reportSubcomments?: ReportSubcommentListRelationFilter
  }

  export type UserOrderByInput = {
    id?: SortOrder
    portalId?: SortOrder
    password?: SortOrder
    nickname?: SortOrder
    randomNickname?: SortOrder
    joinedAt?: SortOrder
    refreshToken?: SortOrder
    admin?: AdminOrderByInput
    changePassword?: ChangePasswordOrderByInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    portalId?: string
    nickname?: string
  }

  export type ReportCommentWhereInput = {
    AND?: Enumerable<ReportCommentWhereInput>
    OR?: Enumerable<ReportCommentWhereInput>
    NOT?: Enumerable<ReportCommentWhereInput>
    id?: IntFilter | number
    commentId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
    communityComment?: XOR<CommunityCommentWhereInput, CommunityCommentRelationFilter>
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type ReportCommentOrderByInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    reportedAt?: SortOrder
    communityComment?: CommunityCommentOrderByInput
    user?: UserOrderByInput
  }

  export type ReportCommentWhereUniqueInput = {
    id?: number
  }

  export type ReportPostWhereInput = {
    AND?: Enumerable<ReportPostWhereInput>
    OR?: Enumerable<ReportPostWhereInput>
    NOT?: Enumerable<ReportPostWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
    communityPost?: XOR<CommunityPostWhereInput, CommunityPostRelationFilter>
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type ReportPostOrderByInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    reportedAt?: SortOrder
    communityPost?: CommunityPostOrderByInput
    user?: UserOrderByInput
  }

  export type ReportPostWhereUniqueInput = {
    id?: number
  }

  export type ReportSubcommentWhereInput = {
    AND?: Enumerable<ReportSubcommentWhereInput>
    OR?: Enumerable<ReportSubcommentWhereInput>
    NOT?: Enumerable<ReportSubcommentWhereInput>
    id?: IntFilter | number
    subcommentId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
    communitySubcomment?: XOR<CommunitySubcommentWhereInput, CommunitySubcommentRelationFilter>
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type ReportSubcommentOrderByInput = {
    id?: SortOrder
    subcommentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    reportedAt?: SortOrder
    communitySubcomment?: CommunitySubcommentOrderByInput
    user?: UserOrderByInput
  }

  export type ReportSubcommentWhereUniqueInput = {
    id?: number
  }

  export type AdminCreateInput = {
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    userId: number
  }

  export type AdminUpdateInput = {
    user?: UserUpdateOneRequiredWithoutAdminInput
  }

  export type AdminUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AdminUpdateManyMutationInput = {

  }

  export type AdminUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeteriaMenuCreateInput = {
    campus: string
    servedAt: Date | string
    data?: InputJsonValue | null
  }

  export type CafeteriaMenuUncheckedCreateInput = {
    campus: string
    servedAt: Date | string
    data?: InputJsonValue | null
  }

  export type CafeteriaMenuUpdateInput = {
    campus?: StringFieldUpdateOperationsInput | string
    servedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: InputJsonValue | null
  }

  export type CafeteriaMenuUncheckedUpdateInput = {
    campus?: StringFieldUpdateOperationsInput | string
    servedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: InputJsonValue | null
  }

  export type CafeteriaMenuUpdateManyMutationInput = {
    campus?: StringFieldUpdateOperationsInput | string
    servedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: InputJsonValue | null
  }

  export type CafeteriaMenuUncheckedUpdateManyInput = {
    campus?: StringFieldUpdateOperationsInput | string
    servedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: InputJsonValue | null
  }

  export type ChangePasswordCreateInput = {
    token: string
    requestedAt: Date | string
    user: UserCreateNestedOneWithoutChangePasswordInput
  }

  export type ChangePasswordUncheckedCreateInput = {
    userId: number
    token: string
    requestedAt: Date | string
  }

  export type ChangePasswordUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChangePasswordInput
  }

  export type ChangePasswordUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangePasswordUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangePasswordUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBoardCreateInput = {
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdAt: Date | string
    activeAt?: Date | string | null
    user: UserCreateNestedOneWithoutCommunityBoardsInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedCreateInput = {
    id?: number
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdBy: number
    createdAt: Date | string
    activeAt?: Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCommunityBoardsInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityBoardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityBoardCandidateCreateInput = {
    name?: string
    description?: string | null
    createdAt: Date | string
    user: UserCreateNestedOneWithoutCommunityBoardCandidatesInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUncheckedCreateInput = {
    id?: number
    name?: string
    description?: string | null
    createdBy: number
    createdAt: Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommunityBoardCandidatesInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBoardCandidateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBoardCandidateVoteCreateInput = {
    communityBoardCandidate: CommunityBoardCandidateCreateNestedOneWithoutCommunityBoardCandidateVotesInput
    user: UserCreateNestedOneWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedCreateInput = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardCandidateVoteUpdateInput = {
    communityBoardCandidate?: CommunityBoardCandidateUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput
    user?: UserUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateInput = {
    boardCandidateId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardCandidateVoteUpdateManyMutationInput = {

  }

  export type CommunityBoardCandidateVoteUncheckedUpdateManyInput = {
    boardCandidateId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardPinCreateInput = {
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityBoardPinsInput
    user: UserCreateNestedOneWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedCreateInput = {
    userId: number
    boardId: number
  }

  export type CommunityBoardPinUpdateInput = {
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityBoardPinsInput
    user?: UserUpdateOneRequiredWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardPinUpdateManyMutationInput = {

  }

  export type CommunityBoardPinUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityCommentCreateInput = {
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communityPost: CommunityPostCreateNestedOneWithoutCommunityCommentsInput
    user: UserCreateNestedOneWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUpdateInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityCommentsInput
    user?: UserUpdateOneRequiredWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUpdateManyMutationInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityPostCreateInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityPostBookmarkCreateInput = {
    communityPost: CommunityPostCreateNestedOneWithoutCommunityPostBookmarksInput
    user: UserCreateNestedOneWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedCreateInput = {
    userId: number
    postId: number
  }

  export type CommunityPostBookmarkUpdateInput = {
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityPostBookmarksInput
    user?: UserUpdateOneRequiredWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostBookmarkUpdateManyMutationInput = {

  }

  export type CommunityPostBookmarkUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostLikeCreateInput = {
    communityPost: CommunityPostCreateNestedOneWithoutCommunityPostLikesInput
    user: UserCreateNestedOneWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedCreateInput = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeUpdateInput = {
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityPostLikesInput
    user?: UserUpdateOneRequiredWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostLikeUpdateManyMutationInput = {

  }

  export type CommunityPostLikeUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunitySubcommentCreateInput = {
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    communityComment: CommunityCommentCreateNestedOneWithoutCommunitySubcommentsInput
    communityPost: CommunityPostCreateNestedOneWithoutCommunitySubcommentsInput
    user: UserCreateNestedOneWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedCreateInput = {
    id?: number
    userId: number
    postId: number
    commentId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUpdateInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComment?: CommunityCommentUpdateOneRequiredWithoutCommunitySubcommentsInput
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunitySubcommentsInput
    user?: UserUpdateOneRequiredWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUpdateManyMutationInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunitySubcommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CoverageMajorCreateInput = {
    coverageCollege?: string | null
    name: string
    code: string
    coverageMajorLectures?: CoverageMajorLectureCreateNestedManyWithoutCoverageMajorInput
  }

  export type CoverageMajorUncheckedCreateInput = {
    coverageCollege?: string | null
    name: string
    code: string
    coverageMajorLectures?: CoverageMajorLectureUncheckedCreateNestedManyWithoutCoverageMajorInput
  }

  export type CoverageMajorUpdateInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    coverageMajorLectures?: CoverageMajorLectureUpdateManyWithoutCoverageMajorInput
  }

  export type CoverageMajorUncheckedUpdateInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    coverageMajorLectures?: CoverageMajorLectureUncheckedUpdateManyWithoutCoverageMajorInput
  }

  export type CoverageMajorUpdateManyMutationInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorUncheckedUpdateManyInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorLectureCreateInput = {
    lecture: LectureCreateNestedOneWithoutCoverageMajorLecturesInput
    coverageMajor: CoverageMajorCreateNestedOneWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedCreateInput = {
    lectureId: string
    majorCode: string
  }

  export type CoverageMajorLectureUpdateInput = {
    lecture?: LectureUpdateOneRequiredWithoutCoverageMajorLecturesInput
    coverageMajor?: CoverageMajorUpdateOneRequiredWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedUpdateInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
    majorCode?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorLectureUpdateManyMutationInput = {

  }

  export type CoverageMajorLectureUncheckedUpdateManyInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
    majorCode?: StringFieldUpdateOperationsInput | string
  }

  export type LectureCreateInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    coverageMajorLectures?: CoverageMajorLectureCreateNestedManyWithoutLectureInput
    periods?: PeriodCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    coverageMajorLectures?: CoverageMajorLectureUncheckedCreateNestedManyWithoutLectureInput
    periods?: PeriodUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    coverageMajorLectures?: CoverageMajorLectureUpdateManyWithoutLectureInput
    periods?: PeriodUpdateManyWithoutLectureInput
  }

  export type LectureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    coverageMajorLectures?: CoverageMajorLectureUncheckedUpdateManyWithoutLectureInput
    periods?: PeriodUncheckedUpdateManyWithoutLectureInput
  }

  export type LectureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LectureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiveChatCreateInput = {
    id?: number
    message: string
    createdAt: Date | string
    randomNickname: string
    user: UserCreateNestedOneWithoutLiveChatsInput
  }

  export type LiveChatUncheckedCreateInput = {
    id?: number
    message: string
    createdAt: Date | string
    userId: number
    randomNickname: string
  }

  export type LiveChatUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLiveChatsInput
  }

  export type LiveChatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type LiveChatUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type LiveChatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type NoticeNotificationsSubscriptionCreateInput = {
    noticeKey: string
    subscribedAt: Date | string
    user: UserCreateNestedOneWithoutNoticeNotificationsSubscriptionsInput
  }

  export type NoticeNotificationsSubscriptionUncheckedCreateInput = {
    id?: number
    userId: number
    noticeKey: string
    subscribedAt: Date | string
  }

  export type NoticeNotificationsSubscriptionUpdateInput = {
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNoticeNotificationsSubscriptionsInput
  }

  export type NoticeNotificationsSubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeNotificationsSubscriptionUpdateManyMutationInput = {
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeNotificationsSubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingUserCreateInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    token: string
  }

  export type PendingUserUncheckedCreateInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    token: string
  }

  export type PendingUserUpdateInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type PendingUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type PendingUserUpdateManyMutationInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type PendingUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type PeriodCreateInput = {
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
    lecture: LectureCreateNestedOneWithoutPeriodsInput
  }

  export type PeriodUncheckedCreateInput = {
    lectureId: string
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodUpdateInput = {
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
    lecture?: LectureUpdateOneRequiredWithoutPeriodsInput
  }

  export type PeriodUncheckedUpdateInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type PeriodUpdateManyMutationInput = {
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type PeriodUncheckedUpdateManyInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type PushCreateInput = {
    expoPushToken?: string
    registeredAt: Date | string
    activeAt?: Date | string | null
    user: UserCreateNestedOneWithoutPushesInput
  }

  export type PushUncheckedCreateInput = {
    userId: number
    expoPushToken?: string
    registeredAt: Date | string
    activeAt?: Date | string | null
  }

  export type PushUpdateInput = {
    expoPushToken?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPushesInput
  }

  export type PushUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    expoPushToken?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PushUpdateManyMutationInput = {
    expoPushToken?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PushUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    expoPushToken?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type UserUpdateManyMutationInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCommentCreateInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communityComment: CommunityCommentCreateNestedOneWithoutReportCommentsInput
    user: UserCreateNestedOneWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedCreateInput = {
    id?: number
    commentId: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportCommentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityComment?: CommunityCommentUpdateOneRequiredWithoutReportCommentsInput
    user?: UserUpdateOneRequiredWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCommentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPostCreateInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communityPost: CommunityPostCreateNestedOneWithoutReportPostsInput
    user: UserCreateNestedOneWithoutReportPostsInput
  }

  export type ReportPostUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportPostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityPost?: CommunityPostUpdateOneRequiredWithoutReportPostsInput
    user?: UserUpdateOneRequiredWithoutReportPostsInput
  }

  export type ReportPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentCreateInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communitySubcomment: CommunitySubcommentCreateNestedOneWithoutReportSubcommentsInput
    user: UserCreateNestedOneWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedCreateInput = {
    id?: number
    subcommentId: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportSubcommentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communitySubcomment?: CommunitySubcommentUpdateOneRequiredWithoutReportSubcommentsInput
    user?: UserUpdateOneRequiredWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subcommentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subcommentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type JsonNullableFilter = {
    equals?: InputJsonValue | null
    not?: InputJsonValue | null
  }

  export type CafeteriaMenuCampusServedAtCompoundUniqueInput = {
    campus: string
    servedAt: Date | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type CommunityBoardPinListRelationFilter = {
    every?: CommunityBoardPinWhereInput
    some?: CommunityBoardPinWhereInput
    none?: CommunityBoardPinWhereInput
  }

  export type CommunityPostListRelationFilter = {
    every?: CommunityPostWhereInput
    some?: CommunityPostWhereInput
    none?: CommunityPostWhereInput
  }

  export type CommunityBoardCandidateVoteListRelationFilter = {
    every?: CommunityBoardCandidateVoteWhereInput
    some?: CommunityBoardCandidateVoteWhereInput
    none?: CommunityBoardCandidateVoteWhereInput
  }

  export type CommunityBoardCandidateRelationFilter = {
    is?: CommunityBoardCandidateWhereInput
    isNot?: CommunityBoardCandidateWhereInput
  }

  export type CommunityBoardCandidateVoteBoardCandidateIdUserIdCompoundUniqueInput = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardRelationFilter = {
    is?: CommunityBoardWhereInput
    isNot?: CommunityBoardWhereInput
  }

  export type CommunityBoardPinUserIdBoardIdCompoundUniqueInput = {
    userId: number
    boardId: number
  }

  export type CommunityPostRelationFilter = {
    is?: CommunityPostWhereInput
    isNot?: CommunityPostWhereInput
  }

  export type CommunitySubcommentListRelationFilter = {
    every?: CommunitySubcommentWhereInput
    some?: CommunitySubcommentWhereInput
    none?: CommunitySubcommentWhereInput
  }

  export type ReportCommentListRelationFilter = {
    every?: ReportCommentWhereInput
    some?: ReportCommentWhereInput
    none?: ReportCommentWhereInput
  }

  export type CommunityCommentListRelationFilter = {
    every?: CommunityCommentWhereInput
    some?: CommunityCommentWhereInput
    none?: CommunityCommentWhereInput
  }

  export type CommunityPostBookmarkListRelationFilter = {
    every?: CommunityPostBookmarkWhereInput
    some?: CommunityPostBookmarkWhereInput
    none?: CommunityPostBookmarkWhereInput
  }

  export type CommunityPostLikeListRelationFilter = {
    every?: CommunityPostLikeWhereInput
    some?: CommunityPostLikeWhereInput
    none?: CommunityPostLikeWhereInput
  }

  export type ReportPostListRelationFilter = {
    every?: ReportPostWhereInput
    some?: ReportPostWhereInput
    none?: ReportPostWhereInput
  }

  export type CommunityPostBookmarkUserIdPostIdCompoundUniqueInput = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeUserIdPostIdCompoundUniqueInput = {
    userId: number
    postId: number
  }

  export type CommunityCommentRelationFilter = {
    is?: CommunityCommentWhereInput
    isNot?: CommunityCommentWhereInput
  }

  export type ReportSubcommentListRelationFilter = {
    every?: ReportSubcommentWhereInput
    some?: ReportSubcommentWhereInput
    none?: ReportSubcommentWhereInput
  }

  export type CoverageMajorLectureListRelationFilter = {
    every?: CoverageMajorLectureWhereInput
    some?: CoverageMajorLectureWhereInput
    none?: CoverageMajorLectureWhereInput
  }

  export type LectureRelationFilter = {
    is?: LectureWhereInput
    isNot?: LectureWhereInput
  }

  export type CoverageMajorRelationFilter = {
    is?: CoverageMajorWhereInput
    isNot?: CoverageMajorWhereInput
  }

  export type CoverageMajorLectureLectureIdMajorCodeCompoundUniqueInput = {
    lectureId: string
    majorCode: string
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type PeriodListRelationFilter = {
    every?: PeriodWhereInput
    some?: PeriodWhereInput
    none?: PeriodWhereInput
  }

  export type LiveChatIdUserIdCompoundUniqueInput = {
    id: number
    userId: number
  }

  export type PeriodLectureIdDayStartHStartMEndHEndMCompoundUniqueInput = {
    lectureId: string
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type AdminRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type ChangePasswordRelationFilter = {
    is?: ChangePasswordWhereInput | null
    isNot?: ChangePasswordWhereInput | null
  }

  export type CommunityBoardListRelationFilter = {
    every?: CommunityBoardWhereInput
    some?: CommunityBoardWhereInput
    none?: CommunityBoardWhereInput
  }

  export type CommunityBoardCandidateListRelationFilter = {
    every?: CommunityBoardCandidateWhereInput
    some?: CommunityBoardCandidateWhereInput
    none?: CommunityBoardCandidateWhereInput
  }

  export type LiveChatListRelationFilter = {
    every?: LiveChatWhereInput
    some?: LiveChatWhereInput
    none?: LiveChatWhereInput
  }

  export type NoticeNotificationsSubscriptionListRelationFilter = {
    every?: NoticeNotificationsSubscriptionWhereInput
    some?: NoticeNotificationsSubscriptionWhereInput
    none?: NoticeNotificationsSubscriptionWhereInput
  }

  export type PushListRelationFilter = {
    every?: PushWhereInput
    some?: PushWhereInput
    none?: PushWhereInput
  }

  export type CommunitySubcommentRelationFilter = {
    is?: CommunitySubcommentWhereInput
    isNot?: CommunitySubcommentWhereInput
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserUncheckedCreateWithoutAdminInput, UserCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutadminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminInput = {
    create?: XOR<UserUncheckedCreateWithoutAdminInput, UserCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutadminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutAdminInput, UserUpdateWithoutAdminInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserCreateNestedOneWithoutChangePasswordInput = {
    create?: XOR<UserUncheckedCreateWithoutChangePasswordInput, UserCreateWithoutChangePasswordInput>
    connectOrCreate?: UserCreateOrConnectWithoutchangePasswordInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChangePasswordInput = {
    create?: XOR<UserUncheckedCreateWithoutChangePasswordInput, UserCreateWithoutChangePasswordInput>
    connectOrCreate?: UserCreateOrConnectWithoutchangePasswordInput
    upsert?: UserUpsertWithoutChangePasswordInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutChangePasswordInput, UserUpdateWithoutChangePasswordInput>
  }

  export type UserCreateNestedOneWithoutCommunityBoardsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityBoardsInput, UserCreateWithoutCommunityBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityBoardsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityBoardPinCreateNestedManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput>, Enumerable<CommunityBoardPinCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutcommunityBoardInput>
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
  }

  export type CommunityPostCreateNestedManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityPostUncheckedCreateWithoutCommunityBoardInput>, Enumerable<CommunityPostCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutcommunityBoardInput>
    connect?: Enumerable<CommunityPostWhereUniqueInput>
  }

  export type CommunityBoardPinUncheckedCreateNestedManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput>, Enumerable<CommunityBoardPinCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutcommunityBoardInput>
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
  }

  export type CommunityPostUncheckedCreateNestedManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityPostUncheckedCreateWithoutCommunityBoardInput>, Enumerable<CommunityPostCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutcommunityBoardInput>
    connect?: Enumerable<CommunityPostWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutCommunityBoardsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityBoardsInput, UserCreateWithoutCommunityBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityBoardsInput
    upsert?: UserUpsertWithoutCommunityBoardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutCommunityBoardsInput, UserUpdateWithoutCommunityBoardsInput>
  }

  export type CommunityBoardPinUpdateManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput>, Enumerable<CommunityBoardPinCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutcommunityBoardInput>
    upsert?: Enumerable<CommunityBoardPinUpsertWithWhereUniqueWithoutCommunityBoardInput>
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    set?: Enumerable<CommunityBoardPinWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    delete?: Enumerable<CommunityBoardPinWhereUniqueInput>
    update?: Enumerable<CommunityBoardPinUpdateWithWhereUniqueWithoutCommunityBoardInput>
    updateMany?: Enumerable<CommunityBoardPinUpdateManyWithWhereWithoutCommunityBoardInput>
    deleteMany?: Enumerable<CommunityBoardPinScalarWhereInput>
  }

  export type CommunityPostUpdateManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityPostUncheckedCreateWithoutCommunityBoardInput>, Enumerable<CommunityPostCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutcommunityBoardInput>
    upsert?: Enumerable<CommunityPostUpsertWithWhereUniqueWithoutCommunityBoardInput>
    connect?: Enumerable<CommunityPostWhereUniqueInput>
    set?: Enumerable<CommunityPostWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostWhereUniqueInput>
    delete?: Enumerable<CommunityPostWhereUniqueInput>
    update?: Enumerable<CommunityPostUpdateWithWhereUniqueWithoutCommunityBoardInput>
    updateMany?: Enumerable<CommunityPostUpdateManyWithWhereWithoutCommunityBoardInput>
    deleteMany?: Enumerable<CommunityPostScalarWhereInput>
  }

  export type CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput>, Enumerable<CommunityBoardPinCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutcommunityBoardInput>
    upsert?: Enumerable<CommunityBoardPinUpsertWithWhereUniqueWithoutCommunityBoardInput>
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    set?: Enumerable<CommunityBoardPinWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    delete?: Enumerable<CommunityBoardPinWhereUniqueInput>
    update?: Enumerable<CommunityBoardPinUpdateWithWhereUniqueWithoutCommunityBoardInput>
    updateMany?: Enumerable<CommunityBoardPinUpdateManyWithWhereWithoutCommunityBoardInput>
    deleteMany?: Enumerable<CommunityBoardPinScalarWhereInput>
  }

  export type CommunityPostUncheckedUpdateManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityPostUncheckedCreateWithoutCommunityBoardInput>, Enumerable<CommunityPostCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutcommunityBoardInput>
    upsert?: Enumerable<CommunityPostUpsertWithWhereUniqueWithoutCommunityBoardInput>
    connect?: Enumerable<CommunityPostWhereUniqueInput>
    set?: Enumerable<CommunityPostWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostWhereUniqueInput>
    delete?: Enumerable<CommunityPostWhereUniqueInput>
    update?: Enumerable<CommunityPostUpdateWithWhereUniqueWithoutCommunityBoardInput>
    updateMany?: Enumerable<CommunityPostUpdateManyWithWhereWithoutCommunityBoardInput>
    deleteMany?: Enumerable<CommunityPostScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCommunityBoardCandidatesInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityBoardCandidatesInput, UserCreateWithoutCommunityBoardCandidatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityBoardCandidatesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityBoardCandidateVoteCreateNestedManyWithoutCommunityBoardCandidateInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput>, Enumerable<CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutcommunityBoardCandidateInput>
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
  }

  export type CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutCommunityBoardCandidateInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput>, Enumerable<CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutcommunityBoardCandidateInput>
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityBoardCandidatesInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityBoardCandidatesInput, UserCreateWithoutCommunityBoardCandidatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityBoardCandidatesInput
    upsert?: UserUpsertWithoutCommunityBoardCandidatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutCommunityBoardCandidatesInput, UserUpdateWithoutCommunityBoardCandidatesInput>
  }

  export type CommunityBoardCandidateVoteUpdateManyWithoutCommunityBoardCandidateInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput>, Enumerable<CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutcommunityBoardCandidateInput>
    upsert?: Enumerable<CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutCommunityBoardCandidateInput>
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutCommunityBoardCandidateInput>
    updateMany?: Enumerable<CommunityBoardCandidateVoteUpdateManyWithWhereWithoutCommunityBoardCandidateInput>
    deleteMany?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput>, Enumerable<CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutcommunityBoardCandidateInput>
    upsert?: Enumerable<CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutCommunityBoardCandidateInput>
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutCommunityBoardCandidateInput>
    updateMany?: Enumerable<CommunityBoardCandidateVoteUpdateManyWithWhereWithoutCommunityBoardCandidateInput>
    deleteMany?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
  }

  export type CommunityBoardCandidateCreateNestedOneWithoutCommunityBoardCandidateVotesInput = {
    create?: XOR<CommunityBoardCandidateUncheckedCreateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateCreateWithoutCommunityBoardCandidateVotesInput>
    connectOrCreate?: CommunityBoardCandidateCreateOrConnectWithoutcommunityBoardCandidateVotesInput
    connect?: CommunityBoardCandidateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityBoardCandidateVotesInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityBoardCandidateVotesInput, UserCreateWithoutCommunityBoardCandidateVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityBoardCandidateVotesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityBoardCandidateUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput = {
    create?: XOR<CommunityBoardCandidateUncheckedCreateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateCreateWithoutCommunityBoardCandidateVotesInput>
    connectOrCreate?: CommunityBoardCandidateCreateOrConnectWithoutcommunityBoardCandidateVotesInput
    upsert?: CommunityBoardCandidateUpsertWithoutCommunityBoardCandidateVotesInput
    connect?: CommunityBoardCandidateWhereUniqueInput
    update?: XOR<CommunityBoardCandidateUncheckedUpdateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateUpdateWithoutCommunityBoardCandidateVotesInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityBoardCandidateVotesInput, UserCreateWithoutCommunityBoardCandidateVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityBoardCandidateVotesInput
    upsert?: UserUpsertWithoutCommunityBoardCandidateVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutCommunityBoardCandidateVotesInput, UserUpdateWithoutCommunityBoardCandidateVotesInput>
  }

  export type CommunityBoardCreateNestedOneWithoutCommunityBoardPinsInput = {
    create?: XOR<CommunityBoardUncheckedCreateWithoutCommunityBoardPinsInput, CommunityBoardCreateWithoutCommunityBoardPinsInput>
    connectOrCreate?: CommunityBoardCreateOrConnectWithoutcommunityBoardPinsInput
    connect?: CommunityBoardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityBoardPinsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityBoardPinsInput, UserCreateWithoutCommunityBoardPinsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityBoardPinsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityBoardUpdateOneRequiredWithoutCommunityBoardPinsInput = {
    create?: XOR<CommunityBoardUncheckedCreateWithoutCommunityBoardPinsInput, CommunityBoardCreateWithoutCommunityBoardPinsInput>
    connectOrCreate?: CommunityBoardCreateOrConnectWithoutcommunityBoardPinsInput
    upsert?: CommunityBoardUpsertWithoutCommunityBoardPinsInput
    connect?: CommunityBoardWhereUniqueInput
    update?: XOR<CommunityBoardUncheckedUpdateWithoutCommunityBoardPinsInput, CommunityBoardUpdateWithoutCommunityBoardPinsInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityBoardPinsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityBoardPinsInput, UserCreateWithoutCommunityBoardPinsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityBoardPinsInput
    upsert?: UserUpsertWithoutCommunityBoardPinsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutCommunityBoardPinsInput, UserUpdateWithoutCommunityBoardPinsInput>
  }

  export type CommunityPostCreateNestedOneWithoutCommunityCommentsInput = {
    create?: XOR<CommunityPostUncheckedCreateWithoutCommunityCommentsInput, CommunityPostCreateWithoutCommunityCommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutcommunityCommentsInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityCommentsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityCommentsInput, UserCreateWithoutCommunityCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunitySubcommentCreateNestedManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput>, Enumerable<CommunitySubcommentCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutcommunityCommentInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type ReportCommentCreateNestedManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<ReportCommentUncheckedCreateWithoutCommunityCommentInput>, Enumerable<ReportCommentCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutcommunityCommentInput>
    connect?: Enumerable<ReportCommentWhereUniqueInput>
  }

  export type CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput>, Enumerable<CommunitySubcommentCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutcommunityCommentInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type ReportCommentUncheckedCreateNestedManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<ReportCommentUncheckedCreateWithoutCommunityCommentInput>, Enumerable<ReportCommentCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutcommunityCommentInput>
    connect?: Enumerable<ReportCommentWhereUniqueInput>
  }

  export type CommunityPostUpdateOneRequiredWithoutCommunityCommentsInput = {
    create?: XOR<CommunityPostUncheckedCreateWithoutCommunityCommentsInput, CommunityPostCreateWithoutCommunityCommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutcommunityCommentsInput
    upsert?: CommunityPostUpsertWithoutCommunityCommentsInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<CommunityPostUncheckedUpdateWithoutCommunityCommentsInput, CommunityPostUpdateWithoutCommunityCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityCommentsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityCommentsInput, UserCreateWithoutCommunityCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityCommentsInput
    upsert?: UserUpsertWithoutCommunityCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutCommunityCommentsInput, UserUpdateWithoutCommunityCommentsInput>
  }

  export type CommunitySubcommentUpdateManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput>, Enumerable<CommunitySubcommentCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutcommunityCommentInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityCommentInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityCommentInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutCommunityCommentInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type ReportCommentUpdateManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<ReportCommentUncheckedCreateWithoutCommunityCommentInput>, Enumerable<ReportCommentCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutcommunityCommentInput>
    upsert?: Enumerable<ReportCommentUpsertWithWhereUniqueWithoutCommunityCommentInput>
    connect?: Enumerable<ReportCommentWhereUniqueInput>
    set?: Enumerable<ReportCommentWhereUniqueInput>
    disconnect?: Enumerable<ReportCommentWhereUniqueInput>
    delete?: Enumerable<ReportCommentWhereUniqueInput>
    update?: Enumerable<ReportCommentUpdateWithWhereUniqueWithoutCommunityCommentInput>
    updateMany?: Enumerable<ReportCommentUpdateManyWithWhereWithoutCommunityCommentInput>
    deleteMany?: Enumerable<ReportCommentScalarWhereInput>
  }

  export type CommunitySubcommentUncheckedUpdateManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput>, Enumerable<CommunitySubcommentCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutcommunityCommentInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityCommentInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityCommentInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutCommunityCommentInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type ReportCommentUncheckedUpdateManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<ReportCommentUncheckedCreateWithoutCommunityCommentInput>, Enumerable<ReportCommentCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutcommunityCommentInput>
    upsert?: Enumerable<ReportCommentUpsertWithWhereUniqueWithoutCommunityCommentInput>
    connect?: Enumerable<ReportCommentWhereUniqueInput>
    set?: Enumerable<ReportCommentWhereUniqueInput>
    disconnect?: Enumerable<ReportCommentWhereUniqueInput>
    delete?: Enumerable<ReportCommentWhereUniqueInput>
    update?: Enumerable<ReportCommentUpdateWithWhereUniqueWithoutCommunityCommentInput>
    updateMany?: Enumerable<ReportCommentUpdateManyWithWhereWithoutCommunityCommentInput>
    deleteMany?: Enumerable<ReportCommentScalarWhereInput>
  }

  export type CommunityBoardCreateNestedOneWithoutCommunityPostsInput = {
    create?: XOR<CommunityBoardUncheckedCreateWithoutCommunityPostsInput, CommunityBoardCreateWithoutCommunityPostsInput>
    connectOrCreate?: CommunityBoardCreateOrConnectWithoutcommunityPostsInput
    connect?: CommunityBoardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityPostsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityPostsInput, UserCreateWithoutCommunityPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityPostsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityCommentCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityCommentUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityCommentCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutcommunityPostInput>
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
  }

  export type CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityPostBookmarkCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutcommunityPostInput>
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
  }

  export type CommunityPostLikeCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostLikeUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityPostLikeCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutcommunityPostInput>
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
  }

  export type CommunitySubcommentCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunitySubcommentCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutcommunityPostInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type ReportPostCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<ReportPostUncheckedCreateWithoutCommunityPostInput>, Enumerable<ReportPostCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutcommunityPostInput>
    connect?: Enumerable<ReportPostWhereUniqueInput>
  }

  export type CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityCommentUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityCommentCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutcommunityPostInput>
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
  }

  export type CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityPostBookmarkCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutcommunityPostInput>
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
  }

  export type CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostLikeUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityPostLikeCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutcommunityPostInput>
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
  }

  export type CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunitySubcommentCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutcommunityPostInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<ReportPostUncheckedCreateWithoutCommunityPostInput>, Enumerable<ReportPostCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutcommunityPostInput>
    connect?: Enumerable<ReportPostWhereUniqueInput>
  }

  export type CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput = {
    create?: XOR<CommunityBoardUncheckedCreateWithoutCommunityPostsInput, CommunityBoardCreateWithoutCommunityPostsInput>
    connectOrCreate?: CommunityBoardCreateOrConnectWithoutcommunityPostsInput
    upsert?: CommunityBoardUpsertWithoutCommunityPostsInput
    connect?: CommunityBoardWhereUniqueInput
    update?: XOR<CommunityBoardUncheckedUpdateWithoutCommunityPostsInput, CommunityBoardUpdateWithoutCommunityPostsInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityPostsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityPostsInput, UserCreateWithoutCommunityPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityPostsInput
    upsert?: UserUpsertWithoutCommunityPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutCommunityPostsInput, UserUpdateWithoutCommunityPostsInput>
  }

  export type CommunityCommentUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityCommentUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityCommentCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutcommunityPostInput>
    upsert?: Enumerable<CommunityCommentUpsertWithWhereUniqueWithoutCommunityPostInput>
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
    set?: Enumerable<CommunityCommentWhereUniqueInput>
    disconnect?: Enumerable<CommunityCommentWhereUniqueInput>
    delete?: Enumerable<CommunityCommentWhereUniqueInput>
    update?: Enumerable<CommunityCommentUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityCommentUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityCommentScalarWhereInput>
  }

  export type CommunityPostBookmarkUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityPostBookmarkCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutcommunityPostInput>
    upsert?: Enumerable<CommunityPostBookmarkUpsertWithWhereUniqueWithoutCommunityPostInput>
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    set?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    delete?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    update?: Enumerable<CommunityPostBookmarkUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityPostBookmarkUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityPostBookmarkScalarWhereInput>
  }

  export type CommunityPostLikeUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostLikeUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityPostLikeCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutcommunityPostInput>
    upsert?: Enumerable<CommunityPostLikeUpsertWithWhereUniqueWithoutCommunityPostInput>
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    set?: Enumerable<CommunityPostLikeWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    delete?: Enumerable<CommunityPostLikeWhereUniqueInput>
    update?: Enumerable<CommunityPostLikeUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityPostLikeUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityPostLikeScalarWhereInput>
  }

  export type CommunitySubcommentUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunitySubcommentCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutcommunityPostInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityPostInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type ReportPostUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<ReportPostUncheckedCreateWithoutCommunityPostInput>, Enumerable<ReportPostCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutcommunityPostInput>
    upsert?: Enumerable<ReportPostUpsertWithWhereUniqueWithoutCommunityPostInput>
    connect?: Enumerable<ReportPostWhereUniqueInput>
    set?: Enumerable<ReportPostWhereUniqueInput>
    disconnect?: Enumerable<ReportPostWhereUniqueInput>
    delete?: Enumerable<ReportPostWhereUniqueInput>
    update?: Enumerable<ReportPostUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<ReportPostUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<ReportPostScalarWhereInput>
  }

  export type CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityCommentUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityCommentCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutcommunityPostInput>
    upsert?: Enumerable<CommunityCommentUpsertWithWhereUniqueWithoutCommunityPostInput>
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
    set?: Enumerable<CommunityCommentWhereUniqueInput>
    disconnect?: Enumerable<CommunityCommentWhereUniqueInput>
    delete?: Enumerable<CommunityCommentWhereUniqueInput>
    update?: Enumerable<CommunityCommentUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityCommentUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityCommentScalarWhereInput>
  }

  export type CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityPostBookmarkCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutcommunityPostInput>
    upsert?: Enumerable<CommunityPostBookmarkUpsertWithWhereUniqueWithoutCommunityPostInput>
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    set?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    delete?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    update?: Enumerable<CommunityPostBookmarkUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityPostBookmarkUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityPostBookmarkScalarWhereInput>
  }

  export type CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostLikeUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunityPostLikeCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutcommunityPostInput>
    upsert?: Enumerable<CommunityPostLikeUpsertWithWhereUniqueWithoutCommunityPostInput>
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    set?: Enumerable<CommunityPostLikeWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    delete?: Enumerable<CommunityPostLikeWhereUniqueInput>
    update?: Enumerable<CommunityPostLikeUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityPostLikeUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityPostLikeScalarWhereInput>
  }

  export type CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityPostInput>, Enumerable<CommunitySubcommentCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutcommunityPostInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityPostInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type ReportPostUncheckedUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<ReportPostUncheckedCreateWithoutCommunityPostInput>, Enumerable<ReportPostCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutcommunityPostInput>
    upsert?: Enumerable<ReportPostUpsertWithWhereUniqueWithoutCommunityPostInput>
    connect?: Enumerable<ReportPostWhereUniqueInput>
    set?: Enumerable<ReportPostWhereUniqueInput>
    disconnect?: Enumerable<ReportPostWhereUniqueInput>
    delete?: Enumerable<ReportPostWhereUniqueInput>
    update?: Enumerable<ReportPostUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<ReportPostUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<ReportPostScalarWhereInput>
  }

  export type CommunityPostCreateNestedOneWithoutCommunityPostBookmarksInput = {
    create?: XOR<CommunityPostUncheckedCreateWithoutCommunityPostBookmarksInput, CommunityPostCreateWithoutCommunityPostBookmarksInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutcommunityPostBookmarksInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityPostBookmarksInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityPostBookmarksInput, UserCreateWithoutCommunityPostBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityPostBookmarksInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityPostUpdateOneRequiredWithoutCommunityPostBookmarksInput = {
    create?: XOR<CommunityPostUncheckedCreateWithoutCommunityPostBookmarksInput, CommunityPostCreateWithoutCommunityPostBookmarksInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutcommunityPostBookmarksInput
    upsert?: CommunityPostUpsertWithoutCommunityPostBookmarksInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<CommunityPostUncheckedUpdateWithoutCommunityPostBookmarksInput, CommunityPostUpdateWithoutCommunityPostBookmarksInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityPostBookmarksInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityPostBookmarksInput, UserCreateWithoutCommunityPostBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityPostBookmarksInput
    upsert?: UserUpsertWithoutCommunityPostBookmarksInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutCommunityPostBookmarksInput, UserUpdateWithoutCommunityPostBookmarksInput>
  }

  export type CommunityPostCreateNestedOneWithoutCommunityPostLikesInput = {
    create?: XOR<CommunityPostUncheckedCreateWithoutCommunityPostLikesInput, CommunityPostCreateWithoutCommunityPostLikesInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutcommunityPostLikesInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityPostLikesInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityPostLikesInput, UserCreateWithoutCommunityPostLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityPostLikesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityPostUpdateOneRequiredWithoutCommunityPostLikesInput = {
    create?: XOR<CommunityPostUncheckedCreateWithoutCommunityPostLikesInput, CommunityPostCreateWithoutCommunityPostLikesInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutcommunityPostLikesInput
    upsert?: CommunityPostUpsertWithoutCommunityPostLikesInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<CommunityPostUncheckedUpdateWithoutCommunityPostLikesInput, CommunityPostUpdateWithoutCommunityPostLikesInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityPostLikesInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunityPostLikesInput, UserCreateWithoutCommunityPostLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunityPostLikesInput
    upsert?: UserUpsertWithoutCommunityPostLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutCommunityPostLikesInput, UserUpdateWithoutCommunityPostLikesInput>
  }

  export type CommunityCommentCreateNestedOneWithoutCommunitySubcommentsInput = {
    create?: XOR<CommunityCommentUncheckedCreateWithoutCommunitySubcommentsInput, CommunityCommentCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutcommunitySubcommentsInput
    connect?: CommunityCommentWhereUniqueInput
  }

  export type CommunityPostCreateNestedOneWithoutCommunitySubcommentsInput = {
    create?: XOR<CommunityPostUncheckedCreateWithoutCommunitySubcommentsInput, CommunityPostCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutcommunitySubcommentsInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunitySubcommentsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunitySubcommentsInput, UserCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunitySubcommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ReportSubcommentCreateNestedManyWithoutCommunitySubcommentInput = {
    create?: XOR<Enumerable<ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput>, Enumerable<ReportSubcommentCreateWithoutCommunitySubcommentInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutcommunitySubcommentInput>
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
  }

  export type ReportSubcommentUncheckedCreateNestedManyWithoutCommunitySubcommentInput = {
    create?: XOR<Enumerable<ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput>, Enumerable<ReportSubcommentCreateWithoutCommunitySubcommentInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutcommunitySubcommentInput>
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
  }

  export type CommunityCommentUpdateOneRequiredWithoutCommunitySubcommentsInput = {
    create?: XOR<CommunityCommentUncheckedCreateWithoutCommunitySubcommentsInput, CommunityCommentCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutcommunitySubcommentsInput
    upsert?: CommunityCommentUpsertWithoutCommunitySubcommentsInput
    connect?: CommunityCommentWhereUniqueInput
    update?: XOR<CommunityCommentUncheckedUpdateWithoutCommunitySubcommentsInput, CommunityCommentUpdateWithoutCommunitySubcommentsInput>
  }

  export type CommunityPostUpdateOneRequiredWithoutCommunitySubcommentsInput = {
    create?: XOR<CommunityPostUncheckedCreateWithoutCommunitySubcommentsInput, CommunityPostCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutcommunitySubcommentsInput
    upsert?: CommunityPostUpsertWithoutCommunitySubcommentsInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<CommunityPostUncheckedUpdateWithoutCommunitySubcommentsInput, CommunityPostUpdateWithoutCommunitySubcommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommunitySubcommentsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommunitySubcommentsInput, UserCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommunitySubcommentsInput
    upsert?: UserUpsertWithoutCommunitySubcommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutCommunitySubcommentsInput, UserUpdateWithoutCommunitySubcommentsInput>
  }

  export type ReportSubcommentUpdateManyWithoutCommunitySubcommentInput = {
    create?: XOR<Enumerable<ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput>, Enumerable<ReportSubcommentCreateWithoutCommunitySubcommentInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutcommunitySubcommentInput>
    upsert?: Enumerable<ReportSubcommentUpsertWithWhereUniqueWithoutCommunitySubcommentInput>
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
    set?: Enumerable<ReportSubcommentWhereUniqueInput>
    disconnect?: Enumerable<ReportSubcommentWhereUniqueInput>
    delete?: Enumerable<ReportSubcommentWhereUniqueInput>
    update?: Enumerable<ReportSubcommentUpdateWithWhereUniqueWithoutCommunitySubcommentInput>
    updateMany?: Enumerable<ReportSubcommentUpdateManyWithWhereWithoutCommunitySubcommentInput>
    deleteMany?: Enumerable<ReportSubcommentScalarWhereInput>
  }

  export type ReportSubcommentUncheckedUpdateManyWithoutCommunitySubcommentInput = {
    create?: XOR<Enumerable<ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput>, Enumerable<ReportSubcommentCreateWithoutCommunitySubcommentInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutcommunitySubcommentInput>
    upsert?: Enumerable<ReportSubcommentUpsertWithWhereUniqueWithoutCommunitySubcommentInput>
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
    set?: Enumerable<ReportSubcommentWhereUniqueInput>
    disconnect?: Enumerable<ReportSubcommentWhereUniqueInput>
    delete?: Enumerable<ReportSubcommentWhereUniqueInput>
    update?: Enumerable<ReportSubcommentUpdateWithWhereUniqueWithoutCommunitySubcommentInput>
    updateMany?: Enumerable<ReportSubcommentUpdateManyWithWhereWithoutCommunitySubcommentInput>
    deleteMany?: Enumerable<ReportSubcommentScalarWhereInput>
  }

  export type CoverageMajorLectureCreateNestedManyWithoutCoverageMajorInput = {
    create?: XOR<Enumerable<CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput>, Enumerable<CoverageMajorLectureCreateWithoutCoverageMajorInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutcoverageMajorInput>
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
  }

  export type CoverageMajorLectureUncheckedCreateNestedManyWithoutCoverageMajorInput = {
    create?: XOR<Enumerable<CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput>, Enumerable<CoverageMajorLectureCreateWithoutCoverageMajorInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutcoverageMajorInput>
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
  }

  export type CoverageMajorLectureUpdateManyWithoutCoverageMajorInput = {
    create?: XOR<Enumerable<CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput>, Enumerable<CoverageMajorLectureCreateWithoutCoverageMajorInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutcoverageMajorInput>
    upsert?: Enumerable<CoverageMajorLectureUpsertWithWhereUniqueWithoutCoverageMajorInput>
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    set?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    disconnect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    delete?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    update?: Enumerable<CoverageMajorLectureUpdateWithWhereUniqueWithoutCoverageMajorInput>
    updateMany?: Enumerable<CoverageMajorLectureUpdateManyWithWhereWithoutCoverageMajorInput>
    deleteMany?: Enumerable<CoverageMajorLectureScalarWhereInput>
  }

  export type CoverageMajorLectureUncheckedUpdateManyWithoutCoverageMajorInput = {
    create?: XOR<Enumerable<CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput>, Enumerable<CoverageMajorLectureCreateWithoutCoverageMajorInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutcoverageMajorInput>
    upsert?: Enumerable<CoverageMajorLectureUpsertWithWhereUniqueWithoutCoverageMajorInput>
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    set?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    disconnect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    delete?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    update?: Enumerable<CoverageMajorLectureUpdateWithWhereUniqueWithoutCoverageMajorInput>
    updateMany?: Enumerable<CoverageMajorLectureUpdateManyWithWhereWithoutCoverageMajorInput>
    deleteMany?: Enumerable<CoverageMajorLectureScalarWhereInput>
  }

  export type LectureCreateNestedOneWithoutCoverageMajorLecturesInput = {
    create?: XOR<LectureUncheckedCreateWithoutCoverageMajorLecturesInput, LectureCreateWithoutCoverageMajorLecturesInput>
    connectOrCreate?: LectureCreateOrConnectWithoutcoverageMajorLecturesInput
    connect?: LectureWhereUniqueInput
  }

  export type CoverageMajorCreateNestedOneWithoutCoverageMajorLecturesInput = {
    create?: XOR<CoverageMajorUncheckedCreateWithoutCoverageMajorLecturesInput, CoverageMajorCreateWithoutCoverageMajorLecturesInput>
    connectOrCreate?: CoverageMajorCreateOrConnectWithoutcoverageMajorLecturesInput
    connect?: CoverageMajorWhereUniqueInput
  }

  export type LectureUpdateOneRequiredWithoutCoverageMajorLecturesInput = {
    create?: XOR<LectureUncheckedCreateWithoutCoverageMajorLecturesInput, LectureCreateWithoutCoverageMajorLecturesInput>
    connectOrCreate?: LectureCreateOrConnectWithoutcoverageMajorLecturesInput
    upsert?: LectureUpsertWithoutCoverageMajorLecturesInput
    connect?: LectureWhereUniqueInput
    update?: XOR<LectureUncheckedUpdateWithoutCoverageMajorLecturesInput, LectureUpdateWithoutCoverageMajorLecturesInput>
  }

  export type CoverageMajorUpdateOneRequiredWithoutCoverageMajorLecturesInput = {
    create?: XOR<CoverageMajorUncheckedCreateWithoutCoverageMajorLecturesInput, CoverageMajorCreateWithoutCoverageMajorLecturesInput>
    connectOrCreate?: CoverageMajorCreateOrConnectWithoutcoverageMajorLecturesInput
    upsert?: CoverageMajorUpsertWithoutCoverageMajorLecturesInput
    connect?: CoverageMajorWhereUniqueInput
    update?: XOR<CoverageMajorUncheckedUpdateWithoutCoverageMajorLecturesInput, CoverageMajorUpdateWithoutCoverageMajorLecturesInput>
  }

  export type CoverageMajorLectureCreateNestedManyWithoutLectureInput = {
    create?: XOR<Enumerable<CoverageMajorLectureUncheckedCreateWithoutLectureInput>, Enumerable<CoverageMajorLectureCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutlectureInput>
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
  }

  export type PeriodCreateNestedManyWithoutLectureInput = {
    create?: XOR<Enumerable<PeriodUncheckedCreateWithoutLectureInput>, Enumerable<PeriodCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<PeriodCreateOrConnectWithoutlectureInput>
    connect?: Enumerable<PeriodWhereUniqueInput>
  }

  export type CoverageMajorLectureUncheckedCreateNestedManyWithoutLectureInput = {
    create?: XOR<Enumerable<CoverageMajorLectureUncheckedCreateWithoutLectureInput>, Enumerable<CoverageMajorLectureCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutlectureInput>
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
  }

  export type PeriodUncheckedCreateNestedManyWithoutLectureInput = {
    create?: XOR<Enumerable<PeriodUncheckedCreateWithoutLectureInput>, Enumerable<PeriodCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<PeriodCreateOrConnectWithoutlectureInput>
    connect?: Enumerable<PeriodWhereUniqueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CoverageMajorLectureUpdateManyWithoutLectureInput = {
    create?: XOR<Enumerable<CoverageMajorLectureUncheckedCreateWithoutLectureInput>, Enumerable<CoverageMajorLectureCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutlectureInput>
    upsert?: Enumerable<CoverageMajorLectureUpsertWithWhereUniqueWithoutLectureInput>
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    set?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    disconnect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    delete?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    update?: Enumerable<CoverageMajorLectureUpdateWithWhereUniqueWithoutLectureInput>
    updateMany?: Enumerable<CoverageMajorLectureUpdateManyWithWhereWithoutLectureInput>
    deleteMany?: Enumerable<CoverageMajorLectureScalarWhereInput>
  }

  export type PeriodUpdateManyWithoutLectureInput = {
    create?: XOR<Enumerable<PeriodUncheckedCreateWithoutLectureInput>, Enumerable<PeriodCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<PeriodCreateOrConnectWithoutlectureInput>
    upsert?: Enumerable<PeriodUpsertWithWhereUniqueWithoutLectureInput>
    connect?: Enumerable<PeriodWhereUniqueInput>
    set?: Enumerable<PeriodWhereUniqueInput>
    disconnect?: Enumerable<PeriodWhereUniqueInput>
    delete?: Enumerable<PeriodWhereUniqueInput>
    update?: Enumerable<PeriodUpdateWithWhereUniqueWithoutLectureInput>
    updateMany?: Enumerable<PeriodUpdateManyWithWhereWithoutLectureInput>
    deleteMany?: Enumerable<PeriodScalarWhereInput>
  }

  export type CoverageMajorLectureUncheckedUpdateManyWithoutLectureInput = {
    create?: XOR<Enumerable<CoverageMajorLectureUncheckedCreateWithoutLectureInput>, Enumerable<CoverageMajorLectureCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutlectureInput>
    upsert?: Enumerable<CoverageMajorLectureUpsertWithWhereUniqueWithoutLectureInput>
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    set?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    disconnect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    delete?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    update?: Enumerable<CoverageMajorLectureUpdateWithWhereUniqueWithoutLectureInput>
    updateMany?: Enumerable<CoverageMajorLectureUpdateManyWithWhereWithoutLectureInput>
    deleteMany?: Enumerable<CoverageMajorLectureScalarWhereInput>
  }

  export type PeriodUncheckedUpdateManyWithoutLectureInput = {
    create?: XOR<Enumerable<PeriodUncheckedCreateWithoutLectureInput>, Enumerable<PeriodCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<PeriodCreateOrConnectWithoutlectureInput>
    upsert?: Enumerable<PeriodUpsertWithWhereUniqueWithoutLectureInput>
    connect?: Enumerable<PeriodWhereUniqueInput>
    set?: Enumerable<PeriodWhereUniqueInput>
    disconnect?: Enumerable<PeriodWhereUniqueInput>
    delete?: Enumerable<PeriodWhereUniqueInput>
    update?: Enumerable<PeriodUpdateWithWhereUniqueWithoutLectureInput>
    updateMany?: Enumerable<PeriodUpdateManyWithWhereWithoutLectureInput>
    deleteMany?: Enumerable<PeriodScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutLiveChatsInput = {
    create?: XOR<UserUncheckedCreateWithoutLiveChatsInput, UserCreateWithoutLiveChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutliveChatsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLiveChatsInput = {
    create?: XOR<UserUncheckedCreateWithoutLiveChatsInput, UserCreateWithoutLiveChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutliveChatsInput
    upsert?: UserUpsertWithoutLiveChatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutLiveChatsInput, UserUpdateWithoutLiveChatsInput>
  }

  export type UserCreateNestedOneWithoutNoticeNotificationsSubscriptionsInput = {
    create?: XOR<UserUncheckedCreateWithoutNoticeNotificationsSubscriptionsInput, UserCreateWithoutNoticeNotificationsSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutnoticeNotificationsSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNoticeNotificationsSubscriptionsInput = {
    create?: XOR<UserUncheckedCreateWithoutNoticeNotificationsSubscriptionsInput, UserCreateWithoutNoticeNotificationsSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutnoticeNotificationsSubscriptionsInput
    upsert?: UserUpsertWithoutNoticeNotificationsSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutNoticeNotificationsSubscriptionsInput, UserUpdateWithoutNoticeNotificationsSubscriptionsInput>
  }

  export type LectureCreateNestedOneWithoutPeriodsInput = {
    create?: XOR<LectureUncheckedCreateWithoutPeriodsInput, LectureCreateWithoutPeriodsInput>
    connectOrCreate?: LectureCreateOrConnectWithoutperiodsInput
    connect?: LectureWhereUniqueInput
  }

  export type LectureUpdateOneRequiredWithoutPeriodsInput = {
    create?: XOR<LectureUncheckedCreateWithoutPeriodsInput, LectureCreateWithoutPeriodsInput>
    connectOrCreate?: LectureCreateOrConnectWithoutperiodsInput
    upsert?: LectureUpsertWithoutPeriodsInput
    connect?: LectureWhereUniqueInput
    update?: XOR<LectureUncheckedUpdateWithoutPeriodsInput, LectureUpdateWithoutPeriodsInput>
  }

  export type UserCreateNestedOneWithoutPushesInput = {
    create?: XOR<UserUncheckedCreateWithoutPushesInput, UserCreateWithoutPushesInput>
    connectOrCreate?: UserCreateOrConnectWithoutpushesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPushesInput = {
    create?: XOR<UserUncheckedCreateWithoutPushesInput, UserCreateWithoutPushesInput>
    connectOrCreate?: UserCreateOrConnectWithoutpushesInput
    upsert?: UserUpsertWithoutPushesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutPushesInput, UserUpdateWithoutPushesInput>
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminUncheckedCreateWithoutUserInput, AdminCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutuserInput
    connect?: AdminWhereUniqueInput
  }

  export type ChangePasswordCreateNestedOneWithoutUserInput = {
    create?: XOR<ChangePasswordUncheckedCreateWithoutUserInput, ChangePasswordCreateWithoutUserInput>
    connectOrCreate?: ChangePasswordCreateOrConnectWithoutuserInput
    connect?: ChangePasswordWhereUniqueInput
  }

  export type CommunityBoardCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityBoardWhereUniqueInput>
  }

  export type CommunityBoardCandidateCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
  }

  export type CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateVoteCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
  }

  export type CommunityBoardPinCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardPinUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardPinCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
  }

  export type CommunityCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityCommentUncheckedCreateWithoutUserInput>, Enumerable<CommunityCommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
  }

  export type CommunityPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityPostWhereUniqueInput>
  }

  export type CommunityPostBookmarkCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostBookmarkCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
  }

  export type CommunityPostLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostLikeUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostLikeCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
  }

  export type CommunitySubcommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutUserInput>, Enumerable<CommunitySubcommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type LiveChatCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LiveChatUncheckedCreateWithoutUserInput>, Enumerable<LiveChatCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LiveChatCreateOrConnectWithoutuserInput>
    connect?: Enumerable<LiveChatWhereUniqueInput>
  }

  export type NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput>, Enumerable<NoticeNotificationsSubscriptionCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeNotificationsSubscriptionCreateOrConnectWithoutuserInput>
    connect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
  }

  export type PushCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PushUncheckedCreateWithoutUserInput>, Enumerable<PushCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PushCreateOrConnectWithoutuserInput>
    connect?: Enumerable<PushWhereUniqueInput>
  }

  export type ReportCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportCommentUncheckedCreateWithoutUserInput>, Enumerable<ReportCommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutuserInput>
    connect?: Enumerable<ReportCommentWhereUniqueInput>
  }

  export type ReportPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportPostUncheckedCreateWithoutUserInput>, Enumerable<ReportPostCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutuserInput>
    connect?: Enumerable<ReportPostWhereUniqueInput>
  }

  export type ReportSubcommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportSubcommentUncheckedCreateWithoutUserInput>, Enumerable<ReportSubcommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutuserInput>
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminUncheckedCreateWithoutUserInput, AdminCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutuserInput
    connect?: AdminWhereUniqueInput
  }

  export type ChangePasswordUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ChangePasswordUncheckedCreateWithoutUserInput, ChangePasswordCreateWithoutUserInput>
    connectOrCreate?: ChangePasswordCreateOrConnectWithoutuserInput
    connect?: ChangePasswordWhereUniqueInput
  }

  export type CommunityBoardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityBoardWhereUniqueInput>
  }

  export type CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
  }

  export type CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateVoteCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
  }

  export type CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardPinUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardPinCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
  }

  export type CommunityCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityCommentUncheckedCreateWithoutUserInput>, Enumerable<CommunityCommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
  }

  export type CommunityPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityPostWhereUniqueInput>
  }

  export type CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostBookmarkCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
  }

  export type CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostLikeUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostLikeCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
  }

  export type CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutUserInput>, Enumerable<CommunitySubcommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutuserInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type LiveChatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LiveChatUncheckedCreateWithoutUserInput>, Enumerable<LiveChatCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LiveChatCreateOrConnectWithoutuserInput>
    connect?: Enumerable<LiveChatWhereUniqueInput>
  }

  export type NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput>, Enumerable<NoticeNotificationsSubscriptionCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeNotificationsSubscriptionCreateOrConnectWithoutuserInput>
    connect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
  }

  export type PushUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PushUncheckedCreateWithoutUserInput>, Enumerable<PushCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PushCreateOrConnectWithoutuserInput>
    connect?: Enumerable<PushWhereUniqueInput>
  }

  export type ReportCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportCommentUncheckedCreateWithoutUserInput>, Enumerable<ReportCommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutuserInput>
    connect?: Enumerable<ReportCommentWhereUniqueInput>
  }

  export type ReportPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportPostUncheckedCreateWithoutUserInput>, Enumerable<ReportPostCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutuserInput>
    connect?: Enumerable<ReportPostWhereUniqueInput>
  }

  export type ReportSubcommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportSubcommentUncheckedCreateWithoutUserInput>, Enumerable<ReportSubcommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutuserInput>
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
  }

  export type AdminUpdateOneWithoutUserInput = {
    create?: XOR<AdminUncheckedCreateWithoutUserInput, AdminCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutuserInput
    connect?: AdminWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AdminUncheckedUpdateWithoutUserInput, AdminUpdateWithoutUserInput>
  }

  export type ChangePasswordUpdateOneWithoutUserInput = {
    create?: XOR<ChangePasswordUncheckedCreateWithoutUserInput, ChangePasswordCreateWithoutUserInput>
    connectOrCreate?: ChangePasswordCreateOrConnectWithoutuserInput
    upsert?: ChangePasswordUpsertWithoutUserInput
    connect?: ChangePasswordWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ChangePasswordUncheckedUpdateWithoutUserInput, ChangePasswordUpdateWithoutUserInput>
  }

  export type CommunityBoardUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityBoardUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityBoardWhereUniqueInput>
    set?: Enumerable<CommunityBoardWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardWhereUniqueInput>
    delete?: Enumerable<CommunityBoardWhereUniqueInput>
    update?: Enumerable<CommunityBoardUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardScalarWhereInput>
  }

  export type CommunityBoardCandidateUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityBoardCandidateUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardCandidateUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardCandidateScalarWhereInput>
  }

  export type CommunityBoardCandidateVoteUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateVoteCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardCandidateVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
  }

  export type CommunityBoardPinUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardPinUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardPinCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityBoardPinUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    set?: Enumerable<CommunityBoardPinWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    delete?: Enumerable<CommunityBoardPinWhereUniqueInput>
    update?: Enumerable<CommunityBoardPinUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardPinUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardPinScalarWhereInput>
  }

  export type CommunityCommentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityCommentUncheckedCreateWithoutUserInput>, Enumerable<CommunityCommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityCommentUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
    set?: Enumerable<CommunityCommentWhereUniqueInput>
    disconnect?: Enumerable<CommunityCommentWhereUniqueInput>
    delete?: Enumerable<CommunityCommentWhereUniqueInput>
    update?: Enumerable<CommunityCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityCommentScalarWhereInput>
  }

  export type CommunityPostUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityPostUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityPostWhereUniqueInput>
    set?: Enumerable<CommunityPostWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostWhereUniqueInput>
    delete?: Enumerable<CommunityPostWhereUniqueInput>
    update?: Enumerable<CommunityPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostScalarWhereInput>
  }

  export type CommunityPostBookmarkUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostBookmarkCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityPostBookmarkUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    set?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    delete?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    update?: Enumerable<CommunityPostBookmarkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostBookmarkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostBookmarkScalarWhereInput>
  }

  export type CommunityPostLikeUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostLikeUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostLikeCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityPostLikeUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    set?: Enumerable<CommunityPostLikeWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    delete?: Enumerable<CommunityPostLikeWhereUniqueInput>
    update?: Enumerable<CommunityPostLikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostLikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostLikeScalarWhereInput>
  }

  export type CommunitySubcommentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutUserInput>, Enumerable<CommunitySubcommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type LiveChatUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<LiveChatUncheckedCreateWithoutUserInput>, Enumerable<LiveChatCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LiveChatCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<LiveChatUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<LiveChatWhereUniqueInput>
    set?: Enumerable<LiveChatWhereUniqueInput>
    disconnect?: Enumerable<LiveChatWhereUniqueInput>
    delete?: Enumerable<LiveChatWhereUniqueInput>
    update?: Enumerable<LiveChatUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LiveChatUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LiveChatScalarWhereInput>
  }

  export type NoticeNotificationsSubscriptionUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput>, Enumerable<NoticeNotificationsSubscriptionCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeNotificationsSubscriptionCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<NoticeNotificationsSubscriptionUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    set?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    disconnect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    delete?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    update?: Enumerable<NoticeNotificationsSubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NoticeNotificationsSubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NoticeNotificationsSubscriptionScalarWhereInput>
  }

  export type PushUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PushUncheckedCreateWithoutUserInput>, Enumerable<PushCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PushCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<PushUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<PushWhereUniqueInput>
    set?: Enumerable<PushWhereUniqueInput>
    disconnect?: Enumerable<PushWhereUniqueInput>
    delete?: Enumerable<PushWhereUniqueInput>
    update?: Enumerable<PushUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PushUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PushScalarWhereInput>
  }

  export type ReportCommentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportCommentUncheckedCreateWithoutUserInput>, Enumerable<ReportCommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<ReportCommentUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<ReportCommentWhereUniqueInput>
    set?: Enumerable<ReportCommentWhereUniqueInput>
    disconnect?: Enumerable<ReportCommentWhereUniqueInput>
    delete?: Enumerable<ReportCommentWhereUniqueInput>
    update?: Enumerable<ReportCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportCommentScalarWhereInput>
  }

  export type ReportPostUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportPostUncheckedCreateWithoutUserInput>, Enumerable<ReportPostCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<ReportPostUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<ReportPostWhereUniqueInput>
    set?: Enumerable<ReportPostWhereUniqueInput>
    disconnect?: Enumerable<ReportPostWhereUniqueInput>
    delete?: Enumerable<ReportPostWhereUniqueInput>
    update?: Enumerable<ReportPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportPostScalarWhereInput>
  }

  export type ReportSubcommentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportSubcommentUncheckedCreateWithoutUserInput>, Enumerable<ReportSubcommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<ReportSubcommentUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
    set?: Enumerable<ReportSubcommentWhereUniqueInput>
    disconnect?: Enumerable<ReportSubcommentWhereUniqueInput>
    delete?: Enumerable<ReportSubcommentWhereUniqueInput>
    update?: Enumerable<ReportSubcommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportSubcommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportSubcommentScalarWhereInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<AdminUncheckedCreateWithoutUserInput, AdminCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutuserInput
    connect?: AdminWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AdminUncheckedUpdateWithoutUserInput, AdminUpdateWithoutUserInput>
  }

  export type ChangePasswordUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<ChangePasswordUncheckedCreateWithoutUserInput, ChangePasswordCreateWithoutUserInput>
    connectOrCreate?: ChangePasswordCreateOrConnectWithoutuserInput
    upsert?: ChangePasswordUpsertWithoutUserInput
    connect?: ChangePasswordWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ChangePasswordUncheckedUpdateWithoutUserInput, ChangePasswordUpdateWithoutUserInput>
  }

  export type CommunityBoardUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityBoardUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityBoardWhereUniqueInput>
    set?: Enumerable<CommunityBoardWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardWhereUniqueInput>
    delete?: Enumerable<CommunityBoardWhereUniqueInput>
    update?: Enumerable<CommunityBoardUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardScalarWhereInput>
  }

  export type CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityBoardCandidateUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardCandidateUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardCandidateScalarWhereInput>
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateVoteCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardCandidateVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
  }

  export type CommunityBoardPinUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardPinUncheckedCreateWithoutUserInput>, Enumerable<CommunityBoardPinCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityBoardPinUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    set?: Enumerable<CommunityBoardPinWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    delete?: Enumerable<CommunityBoardPinWhereUniqueInput>
    update?: Enumerable<CommunityBoardPinUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardPinUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardPinScalarWhereInput>
  }

  export type CommunityCommentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityCommentUncheckedCreateWithoutUserInput>, Enumerable<CommunityCommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityCommentUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
    set?: Enumerable<CommunityCommentWhereUniqueInput>
    disconnect?: Enumerable<CommunityCommentWhereUniqueInput>
    delete?: Enumerable<CommunityCommentWhereUniqueInput>
    update?: Enumerable<CommunityCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityCommentScalarWhereInput>
  }

  export type CommunityPostUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityPostUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityPostWhereUniqueInput>
    set?: Enumerable<CommunityPostWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostWhereUniqueInput>
    delete?: Enumerable<CommunityPostWhereUniqueInput>
    update?: Enumerable<CommunityPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostScalarWhereInput>
  }

  export type CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostBookmarkCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityPostBookmarkUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    set?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    delete?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    update?: Enumerable<CommunityPostBookmarkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostBookmarkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostBookmarkScalarWhereInput>
  }

  export type CommunityPostLikeUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostLikeUncheckedCreateWithoutUserInput>, Enumerable<CommunityPostLikeCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunityPostLikeUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    set?: Enumerable<CommunityPostLikeWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    delete?: Enumerable<CommunityPostLikeWhereUniqueInput>
    update?: Enumerable<CommunityPostLikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostLikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostLikeScalarWhereInput>
  }

  export type CommunitySubcommentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunitySubcommentUncheckedCreateWithoutUserInput>, Enumerable<CommunitySubcommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type LiveChatUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<LiveChatUncheckedCreateWithoutUserInput>, Enumerable<LiveChatCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LiveChatCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<LiveChatUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<LiveChatWhereUniqueInput>
    set?: Enumerable<LiveChatWhereUniqueInput>
    disconnect?: Enumerable<LiveChatWhereUniqueInput>
    delete?: Enumerable<LiveChatWhereUniqueInput>
    update?: Enumerable<LiveChatUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LiveChatUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LiveChatScalarWhereInput>
  }

  export type NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput>, Enumerable<NoticeNotificationsSubscriptionCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeNotificationsSubscriptionCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<NoticeNotificationsSubscriptionUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    set?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    disconnect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    delete?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    update?: Enumerable<NoticeNotificationsSubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NoticeNotificationsSubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NoticeNotificationsSubscriptionScalarWhereInput>
  }

  export type PushUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PushUncheckedCreateWithoutUserInput>, Enumerable<PushCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PushCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<PushUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<PushWhereUniqueInput>
    set?: Enumerable<PushWhereUniqueInput>
    disconnect?: Enumerable<PushWhereUniqueInput>
    delete?: Enumerable<PushWhereUniqueInput>
    update?: Enumerable<PushUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PushUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PushScalarWhereInput>
  }

  export type ReportCommentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportCommentUncheckedCreateWithoutUserInput>, Enumerable<ReportCommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<ReportCommentUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<ReportCommentWhereUniqueInput>
    set?: Enumerable<ReportCommentWhereUniqueInput>
    disconnect?: Enumerable<ReportCommentWhereUniqueInput>
    delete?: Enumerable<ReportCommentWhereUniqueInput>
    update?: Enumerable<ReportCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportCommentScalarWhereInput>
  }

  export type ReportPostUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportPostUncheckedCreateWithoutUserInput>, Enumerable<ReportPostCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<ReportPostUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<ReportPostWhereUniqueInput>
    set?: Enumerable<ReportPostWhereUniqueInput>
    disconnect?: Enumerable<ReportPostWhereUniqueInput>
    delete?: Enumerable<ReportPostWhereUniqueInput>
    update?: Enumerable<ReportPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportPostScalarWhereInput>
  }

  export type ReportSubcommentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportSubcommentUncheckedCreateWithoutUserInput>, Enumerable<ReportSubcommentCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<ReportSubcommentUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
    set?: Enumerable<ReportSubcommentWhereUniqueInput>
    disconnect?: Enumerable<ReportSubcommentWhereUniqueInput>
    delete?: Enumerable<ReportSubcommentWhereUniqueInput>
    update?: Enumerable<ReportSubcommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportSubcommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportSubcommentScalarWhereInput>
  }

  export type CommunityCommentCreateNestedOneWithoutReportCommentsInput = {
    create?: XOR<CommunityCommentUncheckedCreateWithoutReportCommentsInput, CommunityCommentCreateWithoutReportCommentsInput>
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutreportCommentsInput
    connect?: CommunityCommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportCommentsInput = {
    create?: XOR<UserUncheckedCreateWithoutReportCommentsInput, UserCreateWithoutReportCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutreportCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityCommentUpdateOneRequiredWithoutReportCommentsInput = {
    create?: XOR<CommunityCommentUncheckedCreateWithoutReportCommentsInput, CommunityCommentCreateWithoutReportCommentsInput>
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutreportCommentsInput
    upsert?: CommunityCommentUpsertWithoutReportCommentsInput
    connect?: CommunityCommentWhereUniqueInput
    update?: XOR<CommunityCommentUncheckedUpdateWithoutReportCommentsInput, CommunityCommentUpdateWithoutReportCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutReportCommentsInput = {
    create?: XOR<UserUncheckedCreateWithoutReportCommentsInput, UserCreateWithoutReportCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutreportCommentsInput
    upsert?: UserUpsertWithoutReportCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutReportCommentsInput, UserUpdateWithoutReportCommentsInput>
  }

  export type CommunityPostCreateNestedOneWithoutReportPostsInput = {
    create?: XOR<CommunityPostUncheckedCreateWithoutReportPostsInput, CommunityPostCreateWithoutReportPostsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutreportPostsInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportPostsInput = {
    create?: XOR<UserUncheckedCreateWithoutReportPostsInput, UserCreateWithoutReportPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutreportPostsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityPostUpdateOneRequiredWithoutReportPostsInput = {
    create?: XOR<CommunityPostUncheckedCreateWithoutReportPostsInput, CommunityPostCreateWithoutReportPostsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutreportPostsInput
    upsert?: CommunityPostUpsertWithoutReportPostsInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<CommunityPostUncheckedUpdateWithoutReportPostsInput, CommunityPostUpdateWithoutReportPostsInput>
  }

  export type UserUpdateOneRequiredWithoutReportPostsInput = {
    create?: XOR<UserUncheckedCreateWithoutReportPostsInput, UserCreateWithoutReportPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutreportPostsInput
    upsert?: UserUpsertWithoutReportPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutReportPostsInput, UserUpdateWithoutReportPostsInput>
  }

  export type CommunitySubcommentCreateNestedOneWithoutReportSubcommentsInput = {
    create?: XOR<CommunitySubcommentUncheckedCreateWithoutReportSubcommentsInput, CommunitySubcommentCreateWithoutReportSubcommentsInput>
    connectOrCreate?: CommunitySubcommentCreateOrConnectWithoutreportSubcommentsInput
    connect?: CommunitySubcommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportSubcommentsInput = {
    create?: XOR<UserUncheckedCreateWithoutReportSubcommentsInput, UserCreateWithoutReportSubcommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutreportSubcommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunitySubcommentUpdateOneRequiredWithoutReportSubcommentsInput = {
    create?: XOR<CommunitySubcommentUncheckedCreateWithoutReportSubcommentsInput, CommunitySubcommentCreateWithoutReportSubcommentsInput>
    connectOrCreate?: CommunitySubcommentCreateOrConnectWithoutreportSubcommentsInput
    upsert?: CommunitySubcommentUpsertWithoutReportSubcommentsInput
    connect?: CommunitySubcommentWhereUniqueInput
    update?: XOR<CommunitySubcommentUncheckedUpdateWithoutReportSubcommentsInput, CommunitySubcommentUpdateWithoutReportSubcommentsInput>
  }

  export type UserUpdateOneRequiredWithoutReportSubcommentsInput = {
    create?: XOR<UserUncheckedCreateWithoutReportSubcommentsInput, UserCreateWithoutReportSubcommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutreportSubcommentsInput
    upsert?: UserUpsertWithoutReportSubcommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutReportSubcommentsInput, UserUpdateWithoutReportSubcommentsInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserCreateWithoutAdminInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutadminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutAdminInput, UserCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUncheckedUpdateWithoutAdminInput, UserUpdateWithoutAdminInput>
    create: XOR<UserUncheckedCreateWithoutAdminInput, UserCreateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutChangePasswordInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChangePasswordInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutchangePasswordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutChangePasswordInput, UserCreateWithoutChangePasswordInput>
  }

  export type UserUpsertWithoutChangePasswordInput = {
    update: XOR<UserUncheckedUpdateWithoutChangePasswordInput, UserUpdateWithoutChangePasswordInput>
    create: XOR<UserUncheckedCreateWithoutChangePasswordInput, UserCreateWithoutChangePasswordInput>
  }

  export type UserUpdateWithoutChangePasswordInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutChangePasswordInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutCommunityBoardsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityBoardsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutcommunityBoardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutCommunityBoardsInput, UserCreateWithoutCommunityBoardsInput>
  }

  export type CommunityBoardPinCreateWithoutCommunityBoardInput = {
    user: UserCreateNestedOneWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput = {
    userId: number
  }

  export type CommunityBoardPinCreateOrConnectWithoutcommunityBoardInput = {
    where: CommunityBoardPinWhereUniqueInput
    create: XOR<CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput, CommunityBoardPinCreateWithoutCommunityBoardInput>
  }

  export type CommunityPostCreateWithoutCommunityBoardInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommunityBoardInput = {
    id?: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutcommunityBoardInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostUncheckedCreateWithoutCommunityBoardInput, CommunityPostCreateWithoutCommunityBoardInput>
  }

  export type UserUpsertWithoutCommunityBoardsInput = {
    update: XOR<UserUncheckedUpdateWithoutCommunityBoardsInput, UserUpdateWithoutCommunityBoardsInput>
    create: XOR<UserUncheckedCreateWithoutCommunityBoardsInput, UserCreateWithoutCommunityBoardsInput>
  }

  export type UserUpdateWithoutCommunityBoardsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityBoardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityBoardPinUpsertWithWhereUniqueWithoutCommunityBoardInput = {
    where: CommunityBoardPinWhereUniqueInput
    update: XOR<CommunityBoardPinUncheckedUpdateWithoutCommunityBoardInput, CommunityBoardPinUpdateWithoutCommunityBoardInput>
    create: XOR<CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput, CommunityBoardPinCreateWithoutCommunityBoardInput>
  }

  export type CommunityBoardPinUpdateWithWhereUniqueWithoutCommunityBoardInput = {
    where: CommunityBoardPinWhereUniqueInput
    data: XOR<CommunityBoardPinUncheckedUpdateWithoutCommunityBoardInput, CommunityBoardPinUpdateWithoutCommunityBoardInput>
  }

  export type CommunityBoardPinUpdateManyWithWhereWithoutCommunityBoardInput = {
    where: CommunityBoardPinScalarWhereInput
    data: XOR<CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardPinsInput, CommunityBoardPinUpdateManyMutationInput>
  }

  export type CommunityBoardPinScalarWhereInput = {
    AND?: Enumerable<CommunityBoardPinScalarWhereInput>
    OR?: Enumerable<CommunityBoardPinScalarWhereInput>
    NOT?: Enumerable<CommunityBoardPinScalarWhereInput>
    userId?: IntFilter | number
    boardId?: IntFilter | number
  }

  export type CommunityPostUpsertWithWhereUniqueWithoutCommunityBoardInput = {
    where: CommunityPostWhereUniqueInput
    update: XOR<CommunityPostUncheckedUpdateWithoutCommunityBoardInput, CommunityPostUpdateWithoutCommunityBoardInput>
    create: XOR<CommunityPostUncheckedCreateWithoutCommunityBoardInput, CommunityPostCreateWithoutCommunityBoardInput>
  }

  export type CommunityPostUpdateWithWhereUniqueWithoutCommunityBoardInput = {
    where: CommunityPostWhereUniqueInput
    data: XOR<CommunityPostUncheckedUpdateWithoutCommunityBoardInput, CommunityPostUpdateWithoutCommunityBoardInput>
  }

  export type CommunityPostUpdateManyWithWhereWithoutCommunityBoardInput = {
    where: CommunityPostScalarWhereInput
    data: XOR<CommunityPostUncheckedUpdateManyWithoutCommunityPostsInput, CommunityPostUpdateManyMutationInput>
  }

  export type CommunityPostScalarWhereInput = {
    AND?: Enumerable<CommunityPostScalarWhereInput>
    OR?: Enumerable<CommunityPostScalarWhereInput>
    NOT?: Enumerable<CommunityPostScalarWhereInput>
    id?: IntFilter | number
    boardId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringFilter | string
    randomNickname?: StringFilter | string
    likesCount?: IntFilter | number
    commentsCount?: IntFilter | number
    bookmarksCount?: IntFilter | number
    postedAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeNullableFilter | Date | string | null
    isDeleted?: BoolFilter | boolean
  }

  export type UserCreateWithoutCommunityBoardCandidatesInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityBoardCandidatesInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutcommunityBoardCandidatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutCommunityBoardCandidatesInput, UserCreateWithoutCommunityBoardCandidatesInput>
  }

  export type CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput = {
    user: UserCreateNestedOneWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput = {
    userId: number
  }

  export type CommunityBoardCandidateVoteCreateOrConnectWithoutcommunityBoardCandidateInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    create: XOR<CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput, CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput>
  }

  export type UserUpsertWithoutCommunityBoardCandidatesInput = {
    update: XOR<UserUncheckedUpdateWithoutCommunityBoardCandidatesInput, UserUpdateWithoutCommunityBoardCandidatesInput>
    create: XOR<UserUncheckedCreateWithoutCommunityBoardCandidatesInput, UserCreateWithoutCommunityBoardCandidatesInput>
  }

  export type UserUpdateWithoutCommunityBoardCandidatesInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityBoardCandidatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutCommunityBoardCandidateInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    update: XOR<CommunityBoardCandidateVoteUncheckedUpdateWithoutCommunityBoardCandidateInput, CommunityBoardCandidateVoteUpdateWithoutCommunityBoardCandidateInput>
    create: XOR<CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput, CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput>
  }

  export type CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutCommunityBoardCandidateInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    data: XOR<CommunityBoardCandidateVoteUncheckedUpdateWithoutCommunityBoardCandidateInput, CommunityBoardCandidateVoteUpdateWithoutCommunityBoardCandidateInput>
  }

  export type CommunityBoardCandidateVoteUpdateManyWithWhereWithoutCommunityBoardCandidateInput = {
    where: CommunityBoardCandidateVoteScalarWhereInput
    data: XOR<CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateVoteUpdateManyMutationInput>
  }

  export type CommunityBoardCandidateVoteScalarWhereInput = {
    AND?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
    OR?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
    NOT?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
    boardCandidateId?: IntFilter | number
    userId?: IntFilter | number
  }

  export type CommunityBoardCandidateCreateWithoutCommunityBoardCandidateVotesInput = {
    name?: string
    description?: string | null
    createdAt: Date | string
    user: UserCreateNestedOneWithoutCommunityBoardCandidatesInput
  }

  export type CommunityBoardCandidateUncheckedCreateWithoutCommunityBoardCandidateVotesInput = {
    id?: number
    name?: string
    description?: string | null
    createdBy: number
    createdAt: Date | string
  }

  export type CommunityBoardCandidateCreateOrConnectWithoutcommunityBoardCandidateVotesInput = {
    where: CommunityBoardCandidateWhereUniqueInput
    create: XOR<CommunityBoardCandidateUncheckedCreateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateCreateWithoutCommunityBoardCandidateVotesInput>
  }

  export type UserCreateWithoutCommunityBoardCandidateVotesInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityBoardCandidateVotesInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutcommunityBoardCandidateVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutCommunityBoardCandidateVotesInput, UserCreateWithoutCommunityBoardCandidateVotesInput>
  }

  export type CommunityBoardCandidateUpsertWithoutCommunityBoardCandidateVotesInput = {
    update: XOR<CommunityBoardCandidateUncheckedUpdateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateUpdateWithoutCommunityBoardCandidateVotesInput>
    create: XOR<CommunityBoardCandidateUncheckedCreateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateCreateWithoutCommunityBoardCandidateVotesInput>
  }

  export type CommunityBoardCandidateUpdateWithoutCommunityBoardCandidateVotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommunityBoardCandidatesInput
  }

  export type CommunityBoardCandidateUncheckedUpdateWithoutCommunityBoardCandidateVotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCommunityBoardCandidateVotesInput = {
    update: XOR<UserUncheckedUpdateWithoutCommunityBoardCandidateVotesInput, UserUpdateWithoutCommunityBoardCandidateVotesInput>
    create: XOR<UserUncheckedCreateWithoutCommunityBoardCandidateVotesInput, UserCreateWithoutCommunityBoardCandidateVotesInput>
  }

  export type UserUpdateWithoutCommunityBoardCandidateVotesInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityBoardCandidateVotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityBoardCreateWithoutCommunityBoardPinsInput = {
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdAt: Date | string
    activeAt?: Date | string | null
    user: UserCreateNestedOneWithoutCommunityBoardsInput
    communityPosts?: CommunityPostCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedCreateWithoutCommunityBoardPinsInput = {
    id?: number
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdBy: number
    createdAt: Date | string
    activeAt?: Date | string | null
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardCreateOrConnectWithoutcommunityBoardPinsInput = {
    where: CommunityBoardWhereUniqueInput
    create: XOR<CommunityBoardUncheckedCreateWithoutCommunityBoardPinsInput, CommunityBoardCreateWithoutCommunityBoardPinsInput>
  }

  export type UserCreateWithoutCommunityBoardPinsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityBoardPinsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutcommunityBoardPinsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutCommunityBoardPinsInput, UserCreateWithoutCommunityBoardPinsInput>
  }

  export type CommunityBoardUpsertWithoutCommunityBoardPinsInput = {
    update: XOR<CommunityBoardUncheckedUpdateWithoutCommunityBoardPinsInput, CommunityBoardUpdateWithoutCommunityBoardPinsInput>
    create: XOR<CommunityBoardUncheckedCreateWithoutCommunityBoardPinsInput, CommunityBoardCreateWithoutCommunityBoardPinsInput>
  }

  export type CommunityBoardUpdateWithoutCommunityBoardPinsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCommunityBoardsInput
    communityPosts?: CommunityPostUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedUpdateWithoutCommunityBoardPinsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutCommunityBoardInput
  }

  export type UserUpsertWithoutCommunityBoardPinsInput = {
    update: XOR<UserUncheckedUpdateWithoutCommunityBoardPinsInput, UserUpdateWithoutCommunityBoardPinsInput>
    create: XOR<UserUncheckedCreateWithoutCommunityBoardPinsInput, UserCreateWithoutCommunityBoardPinsInput>
  }

  export type UserUpdateWithoutCommunityBoardPinsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityBoardPinsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityPostCreateWithoutCommunityCommentsInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommunityCommentsInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutcommunityCommentsInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostUncheckedCreateWithoutCommunityCommentsInput, CommunityPostCreateWithoutCommunityCommentsInput>
  }

  export type UserCreateWithoutCommunityCommentsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityCommentsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutcommunityCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutCommunityCommentsInput, UserCreateWithoutCommunityCommentsInput>
  }

  export type CommunitySubcommentCreateWithoutCommunityCommentInput = {
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    communityPost: CommunityPostCreateNestedOneWithoutCommunitySubcommentsInput
    user: UserCreateNestedOneWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput = {
    id?: number
    userId: number
    postId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentCreateOrConnectWithoutcommunityCommentInput = {
    where: CommunitySubcommentWhereUniqueInput
    create: XOR<CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput, CommunitySubcommentCreateWithoutCommunityCommentInput>
  }

  export type ReportCommentCreateWithoutCommunityCommentInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    user: UserCreateNestedOneWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedCreateWithoutCommunityCommentInput = {
    id?: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportCommentCreateOrConnectWithoutcommunityCommentInput = {
    where: ReportCommentWhereUniqueInput
    create: XOR<ReportCommentUncheckedCreateWithoutCommunityCommentInput, ReportCommentCreateWithoutCommunityCommentInput>
  }

  export type CommunityPostUpsertWithoutCommunityCommentsInput = {
    update: XOR<CommunityPostUncheckedUpdateWithoutCommunityCommentsInput, CommunityPostUpdateWithoutCommunityCommentsInput>
    create: XOR<CommunityPostUncheckedCreateWithoutCommunityCommentsInput, CommunityPostCreateWithoutCommunityCommentsInput>
  }

  export type CommunityPostUpdateWithoutCommunityCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommunityCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type UserUpsertWithoutCommunityCommentsInput = {
    update: XOR<UserUncheckedUpdateWithoutCommunityCommentsInput, UserUpdateWithoutCommunityCommentsInput>
    create: XOR<UserUncheckedCreateWithoutCommunityCommentsInput, UserCreateWithoutCommunityCommentsInput>
  }

  export type UserUpdateWithoutCommunityCommentsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityCommentInput = {
    where: CommunitySubcommentWhereUniqueInput
    update: XOR<CommunitySubcommentUncheckedUpdateWithoutCommunityCommentInput, CommunitySubcommentUpdateWithoutCommunityCommentInput>
    create: XOR<CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput, CommunitySubcommentCreateWithoutCommunityCommentInput>
  }

  export type CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityCommentInput = {
    where: CommunitySubcommentWhereUniqueInput
    data: XOR<CommunitySubcommentUncheckedUpdateWithoutCommunityCommentInput, CommunitySubcommentUpdateWithoutCommunityCommentInput>
  }

  export type CommunitySubcommentUpdateManyWithWhereWithoutCommunityCommentInput = {
    where: CommunitySubcommentScalarWhereInput
    data: XOR<CommunitySubcommentUncheckedUpdateManyWithoutCommunitySubcommentsInput, CommunitySubcommentUpdateManyMutationInput>
  }

  export type CommunitySubcommentScalarWhereInput = {
    AND?: Enumerable<CommunitySubcommentScalarWhereInput>
    OR?: Enumerable<CommunitySubcommentScalarWhereInput>
    NOT?: Enumerable<CommunitySubcommentScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    postId?: IntFilter | number
    commentId?: IntFilter | number
    randomNickname?: StringFilter | string
    body?: StringFilter | string
    subcommentedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
  }

  export type ReportCommentUpsertWithWhereUniqueWithoutCommunityCommentInput = {
    where: ReportCommentWhereUniqueInput
    update: XOR<ReportCommentUncheckedUpdateWithoutCommunityCommentInput, ReportCommentUpdateWithoutCommunityCommentInput>
    create: XOR<ReportCommentUncheckedCreateWithoutCommunityCommentInput, ReportCommentCreateWithoutCommunityCommentInput>
  }

  export type ReportCommentUpdateWithWhereUniqueWithoutCommunityCommentInput = {
    where: ReportCommentWhereUniqueInput
    data: XOR<ReportCommentUncheckedUpdateWithoutCommunityCommentInput, ReportCommentUpdateWithoutCommunityCommentInput>
  }

  export type ReportCommentUpdateManyWithWhereWithoutCommunityCommentInput = {
    where: ReportCommentScalarWhereInput
    data: XOR<ReportCommentUncheckedUpdateManyWithoutReportCommentsInput, ReportCommentUpdateManyMutationInput>
  }

  export type ReportCommentScalarWhereInput = {
    AND?: Enumerable<ReportCommentScalarWhereInput>
    OR?: Enumerable<ReportCommentScalarWhereInput>
    NOT?: Enumerable<ReportCommentScalarWhereInput>
    id?: IntFilter | number
    commentId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
  }

  export type CommunityBoardCreateWithoutCommunityPostsInput = {
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdAt: Date | string
    activeAt?: Date | string | null
    user: UserCreateNestedOneWithoutCommunityBoardsInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedCreateWithoutCommunityPostsInput = {
    id?: number
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdBy: number
    createdAt: Date | string
    activeAt?: Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardCreateOrConnectWithoutcommunityPostsInput = {
    where: CommunityBoardWhereUniqueInput
    create: XOR<CommunityBoardUncheckedCreateWithoutCommunityPostsInput, CommunityBoardCreateWithoutCommunityPostsInput>
  }

  export type UserCreateWithoutCommunityPostsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityPostsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutcommunityPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutCommunityPostsInput, UserCreateWithoutCommunityPostsInput>
  }

  export type CommunityCommentCreateWithoutCommunityPostInput = {
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    user: UserCreateNestedOneWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedCreateWithoutCommunityPostInput = {
    id?: number
    userId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentCreateOrConnectWithoutcommunityPostInput = {
    where: CommunityCommentWhereUniqueInput
    create: XOR<CommunityCommentUncheckedCreateWithoutCommunityPostInput, CommunityCommentCreateWithoutCommunityPostInput>
  }

  export type CommunityPostBookmarkCreateWithoutCommunityPostInput = {
    user: UserCreateNestedOneWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput = {
    userId: number
  }

  export type CommunityPostBookmarkCreateOrConnectWithoutcommunityPostInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    create: XOR<CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput, CommunityPostBookmarkCreateWithoutCommunityPostInput>
  }

  export type CommunityPostLikeCreateWithoutCommunityPostInput = {
    user: UserCreateNestedOneWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedCreateWithoutCommunityPostInput = {
    userId: number
  }

  export type CommunityPostLikeCreateOrConnectWithoutcommunityPostInput = {
    where: CommunityPostLikeWhereUniqueInput
    create: XOR<CommunityPostLikeUncheckedCreateWithoutCommunityPostInput, CommunityPostLikeCreateWithoutCommunityPostInput>
  }

  export type CommunitySubcommentCreateWithoutCommunityPostInput = {
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    communityComment: CommunityCommentCreateNestedOneWithoutCommunitySubcommentsInput
    user: UserCreateNestedOneWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedCreateWithoutCommunityPostInput = {
    id?: number
    userId: number
    commentId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentCreateOrConnectWithoutcommunityPostInput = {
    where: CommunitySubcommentWhereUniqueInput
    create: XOR<CommunitySubcommentUncheckedCreateWithoutCommunityPostInput, CommunitySubcommentCreateWithoutCommunityPostInput>
  }

  export type ReportPostCreateWithoutCommunityPostInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    user: UserCreateNestedOneWithoutReportPostsInput
  }

  export type ReportPostUncheckedCreateWithoutCommunityPostInput = {
    id?: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportPostCreateOrConnectWithoutcommunityPostInput = {
    where: ReportPostWhereUniqueInput
    create: XOR<ReportPostUncheckedCreateWithoutCommunityPostInput, ReportPostCreateWithoutCommunityPostInput>
  }

  export type CommunityBoardUpsertWithoutCommunityPostsInput = {
    update: XOR<CommunityBoardUncheckedUpdateWithoutCommunityPostsInput, CommunityBoardUpdateWithoutCommunityPostsInput>
    create: XOR<CommunityBoardUncheckedCreateWithoutCommunityPostsInput, CommunityBoardCreateWithoutCommunityPostsInput>
  }

  export type CommunityBoardUpdateWithoutCommunityPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCommunityBoardsInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedUpdateWithoutCommunityPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardInput
  }

  export type UserUpsertWithoutCommunityPostsInput = {
    update: XOR<UserUncheckedUpdateWithoutCommunityPostsInput, UserUpdateWithoutCommunityPostsInput>
    create: XOR<UserUncheckedCreateWithoutCommunityPostsInput, UserCreateWithoutCommunityPostsInput>
  }

  export type UserUpdateWithoutCommunityPostsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityCommentUpsertWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityCommentWhereUniqueInput
    update: XOR<CommunityCommentUncheckedUpdateWithoutCommunityPostInput, CommunityCommentUpdateWithoutCommunityPostInput>
    create: XOR<CommunityCommentUncheckedCreateWithoutCommunityPostInput, CommunityCommentCreateWithoutCommunityPostInput>
  }

  export type CommunityCommentUpdateWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityCommentWhereUniqueInput
    data: XOR<CommunityCommentUncheckedUpdateWithoutCommunityPostInput, CommunityCommentUpdateWithoutCommunityPostInput>
  }

  export type CommunityCommentUpdateManyWithWhereWithoutCommunityPostInput = {
    where: CommunityCommentScalarWhereInput
    data: XOR<CommunityCommentUncheckedUpdateManyWithoutCommunityCommentsInput, CommunityCommentUpdateManyMutationInput>
  }

  export type CommunityCommentScalarWhereInput = {
    AND?: Enumerable<CommunityCommentScalarWhereInput>
    OR?: Enumerable<CommunityCommentScalarWhereInput>
    NOT?: Enumerable<CommunityCommentScalarWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    userId?: IntFilter | number
    randomNickname?: StringFilter | string
    body?: StringFilter | string
    commentedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
  }

  export type CommunityPostBookmarkUpsertWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    update: XOR<CommunityPostBookmarkUncheckedUpdateWithoutCommunityPostInput, CommunityPostBookmarkUpdateWithoutCommunityPostInput>
    create: XOR<CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput, CommunityPostBookmarkCreateWithoutCommunityPostInput>
  }

  export type CommunityPostBookmarkUpdateWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    data: XOR<CommunityPostBookmarkUncheckedUpdateWithoutCommunityPostInput, CommunityPostBookmarkUpdateWithoutCommunityPostInput>
  }

  export type CommunityPostBookmarkUpdateManyWithWhereWithoutCommunityPostInput = {
    where: CommunityPostBookmarkScalarWhereInput
    data: XOR<CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostBookmarksInput, CommunityPostBookmarkUpdateManyMutationInput>
  }

  export type CommunityPostBookmarkScalarWhereInput = {
    AND?: Enumerable<CommunityPostBookmarkScalarWhereInput>
    OR?: Enumerable<CommunityPostBookmarkScalarWhereInput>
    NOT?: Enumerable<CommunityPostBookmarkScalarWhereInput>
    userId?: IntFilter | number
    postId?: IntFilter | number
  }

  export type CommunityPostLikeUpsertWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityPostLikeWhereUniqueInput
    update: XOR<CommunityPostLikeUncheckedUpdateWithoutCommunityPostInput, CommunityPostLikeUpdateWithoutCommunityPostInput>
    create: XOR<CommunityPostLikeUncheckedCreateWithoutCommunityPostInput, CommunityPostLikeCreateWithoutCommunityPostInput>
  }

  export type CommunityPostLikeUpdateWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityPostLikeWhereUniqueInput
    data: XOR<CommunityPostLikeUncheckedUpdateWithoutCommunityPostInput, CommunityPostLikeUpdateWithoutCommunityPostInput>
  }

  export type CommunityPostLikeUpdateManyWithWhereWithoutCommunityPostInput = {
    where: CommunityPostLikeScalarWhereInput
    data: XOR<CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostLikesInput, CommunityPostLikeUpdateManyMutationInput>
  }

  export type CommunityPostLikeScalarWhereInput = {
    AND?: Enumerable<CommunityPostLikeScalarWhereInput>
    OR?: Enumerable<CommunityPostLikeScalarWhereInput>
    NOT?: Enumerable<CommunityPostLikeScalarWhereInput>
    userId?: IntFilter | number
    postId?: IntFilter | number
  }

  export type CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunitySubcommentWhereUniqueInput
    update: XOR<CommunitySubcommentUncheckedUpdateWithoutCommunityPostInput, CommunitySubcommentUpdateWithoutCommunityPostInput>
    create: XOR<CommunitySubcommentUncheckedCreateWithoutCommunityPostInput, CommunitySubcommentCreateWithoutCommunityPostInput>
  }

  export type CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunitySubcommentWhereUniqueInput
    data: XOR<CommunitySubcommentUncheckedUpdateWithoutCommunityPostInput, CommunitySubcommentUpdateWithoutCommunityPostInput>
  }

  export type CommunitySubcommentUpdateManyWithWhereWithoutCommunityPostInput = {
    where: CommunitySubcommentScalarWhereInput
    data: XOR<CommunitySubcommentUncheckedUpdateManyWithoutCommunitySubcommentsInput, CommunitySubcommentUpdateManyMutationInput>
  }

  export type ReportPostUpsertWithWhereUniqueWithoutCommunityPostInput = {
    where: ReportPostWhereUniqueInput
    update: XOR<ReportPostUncheckedUpdateWithoutCommunityPostInput, ReportPostUpdateWithoutCommunityPostInput>
    create: XOR<ReportPostUncheckedCreateWithoutCommunityPostInput, ReportPostCreateWithoutCommunityPostInput>
  }

  export type ReportPostUpdateWithWhereUniqueWithoutCommunityPostInput = {
    where: ReportPostWhereUniqueInput
    data: XOR<ReportPostUncheckedUpdateWithoutCommunityPostInput, ReportPostUpdateWithoutCommunityPostInput>
  }

  export type ReportPostUpdateManyWithWhereWithoutCommunityPostInput = {
    where: ReportPostScalarWhereInput
    data: XOR<ReportPostUncheckedUpdateManyWithoutReportPostsInput, ReportPostUpdateManyMutationInput>
  }

  export type ReportPostScalarWhereInput = {
    AND?: Enumerable<ReportPostScalarWhereInput>
    OR?: Enumerable<ReportPostScalarWhereInput>
    NOT?: Enumerable<ReportPostScalarWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
  }

  export type CommunityPostCreateWithoutCommunityPostBookmarksInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommunityPostBookmarksInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutcommunityPostBookmarksInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostUncheckedCreateWithoutCommunityPostBookmarksInput, CommunityPostCreateWithoutCommunityPostBookmarksInput>
  }

  export type UserCreateWithoutCommunityPostBookmarksInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityPostBookmarksInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutcommunityPostBookmarksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutCommunityPostBookmarksInput, UserCreateWithoutCommunityPostBookmarksInput>
  }

  export type CommunityPostUpsertWithoutCommunityPostBookmarksInput = {
    update: XOR<CommunityPostUncheckedUpdateWithoutCommunityPostBookmarksInput, CommunityPostUpdateWithoutCommunityPostBookmarksInput>
    create: XOR<CommunityPostUncheckedCreateWithoutCommunityPostBookmarksInput, CommunityPostCreateWithoutCommunityPostBookmarksInput>
  }

  export type CommunityPostUpdateWithoutCommunityPostBookmarksInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommunityPostBookmarksInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type UserUpsertWithoutCommunityPostBookmarksInput = {
    update: XOR<UserUncheckedUpdateWithoutCommunityPostBookmarksInput, UserUpdateWithoutCommunityPostBookmarksInput>
    create: XOR<UserUncheckedCreateWithoutCommunityPostBookmarksInput, UserCreateWithoutCommunityPostBookmarksInput>
  }

  export type UserUpdateWithoutCommunityPostBookmarksInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityPostBookmarksInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityPostCreateWithoutCommunityPostLikesInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommunityPostLikesInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutcommunityPostLikesInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostUncheckedCreateWithoutCommunityPostLikesInput, CommunityPostCreateWithoutCommunityPostLikesInput>
  }

  export type UserCreateWithoutCommunityPostLikesInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityPostLikesInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutcommunityPostLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutCommunityPostLikesInput, UserCreateWithoutCommunityPostLikesInput>
  }

  export type CommunityPostUpsertWithoutCommunityPostLikesInput = {
    update: XOR<CommunityPostUncheckedUpdateWithoutCommunityPostLikesInput, CommunityPostUpdateWithoutCommunityPostLikesInput>
    create: XOR<CommunityPostUncheckedCreateWithoutCommunityPostLikesInput, CommunityPostCreateWithoutCommunityPostLikesInput>
  }

  export type CommunityPostUpdateWithoutCommunityPostLikesInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommunityPostLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type UserUpsertWithoutCommunityPostLikesInput = {
    update: XOR<UserUncheckedUpdateWithoutCommunityPostLikesInput, UserUpdateWithoutCommunityPostLikesInput>
    create: XOR<UserUncheckedCreateWithoutCommunityPostLikesInput, UserCreateWithoutCommunityPostLikesInput>
  }

  export type UserUpdateWithoutCommunityPostLikesInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityPostLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityCommentCreateWithoutCommunitySubcommentsInput = {
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communityPost: CommunityPostCreateNestedOneWithoutCommunityCommentsInput
    user: UserCreateNestedOneWithoutCommunityCommentsInput
    reportComments?: ReportCommentCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedCreateWithoutCommunitySubcommentsInput = {
    id?: number
    postId: number
    userId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentCreateOrConnectWithoutcommunitySubcommentsInput = {
    where: CommunityCommentWhereUniqueInput
    create: XOR<CommunityCommentUncheckedCreateWithoutCommunitySubcommentsInput, CommunityCommentCreateWithoutCommunitySubcommentsInput>
  }

  export type CommunityPostCreateWithoutCommunitySubcommentsInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommunitySubcommentsInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutcommunitySubcommentsInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostUncheckedCreateWithoutCommunitySubcommentsInput, CommunityPostCreateWithoutCommunitySubcommentsInput>
  }

  export type UserCreateWithoutCommunitySubcommentsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunitySubcommentsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutcommunitySubcommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutCommunitySubcommentsInput, UserCreateWithoutCommunitySubcommentsInput>
  }

  export type ReportSubcommentCreateWithoutCommunitySubcommentInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    user: UserCreateNestedOneWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput = {
    id?: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportSubcommentCreateOrConnectWithoutcommunitySubcommentInput = {
    where: ReportSubcommentWhereUniqueInput
    create: XOR<ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput, ReportSubcommentCreateWithoutCommunitySubcommentInput>
  }

  export type CommunityCommentUpsertWithoutCommunitySubcommentsInput = {
    update: XOR<CommunityCommentUncheckedUpdateWithoutCommunitySubcommentsInput, CommunityCommentUpdateWithoutCommunitySubcommentsInput>
    create: XOR<CommunityCommentUncheckedCreateWithoutCommunitySubcommentsInput, CommunityCommentCreateWithoutCommunitySubcommentsInput>
  }

  export type CommunityCommentUpdateWithoutCommunitySubcommentsInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityCommentsInput
    user?: UserUpdateOneRequiredWithoutCommunityCommentsInput
    reportComments?: ReportCommentUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateWithoutCommunitySubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reportComments?: ReportCommentUncheckedUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityPostUpsertWithoutCommunitySubcommentsInput = {
    update: XOR<CommunityPostUncheckedUpdateWithoutCommunitySubcommentsInput, CommunityPostUpdateWithoutCommunitySubcommentsInput>
    create: XOR<CommunityPostUncheckedCreateWithoutCommunitySubcommentsInput, CommunityPostCreateWithoutCommunitySubcommentsInput>
  }

  export type CommunityPostUpdateWithoutCommunitySubcommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommunitySubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type UserUpsertWithoutCommunitySubcommentsInput = {
    update: XOR<UserUncheckedUpdateWithoutCommunitySubcommentsInput, UserUpdateWithoutCommunitySubcommentsInput>
    create: XOR<UserUncheckedCreateWithoutCommunitySubcommentsInput, UserCreateWithoutCommunitySubcommentsInput>
  }

  export type UserUpdateWithoutCommunitySubcommentsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunitySubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type ReportSubcommentUpsertWithWhereUniqueWithoutCommunitySubcommentInput = {
    where: ReportSubcommentWhereUniqueInput
    update: XOR<ReportSubcommentUncheckedUpdateWithoutCommunitySubcommentInput, ReportSubcommentUpdateWithoutCommunitySubcommentInput>
    create: XOR<ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput, ReportSubcommentCreateWithoutCommunitySubcommentInput>
  }

  export type ReportSubcommentUpdateWithWhereUniqueWithoutCommunitySubcommentInput = {
    where: ReportSubcommentWhereUniqueInput
    data: XOR<ReportSubcommentUncheckedUpdateWithoutCommunitySubcommentInput, ReportSubcommentUpdateWithoutCommunitySubcommentInput>
  }

  export type ReportSubcommentUpdateManyWithWhereWithoutCommunitySubcommentInput = {
    where: ReportSubcommentScalarWhereInput
    data: XOR<ReportSubcommentUncheckedUpdateManyWithoutReportSubcommentsInput, ReportSubcommentUpdateManyMutationInput>
  }

  export type ReportSubcommentScalarWhereInput = {
    AND?: Enumerable<ReportSubcommentScalarWhereInput>
    OR?: Enumerable<ReportSubcommentScalarWhereInput>
    NOT?: Enumerable<ReportSubcommentScalarWhereInput>
    id?: IntFilter | number
    subcommentId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
  }

  export type CoverageMajorLectureCreateWithoutCoverageMajorInput = {
    lecture: LectureCreateNestedOneWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput = {
    lectureId: string
  }

  export type CoverageMajorLectureCreateOrConnectWithoutcoverageMajorInput = {
    where: CoverageMajorLectureWhereUniqueInput
    create: XOR<CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput, CoverageMajorLectureCreateWithoutCoverageMajorInput>
  }

  export type CoverageMajorLectureUpsertWithWhereUniqueWithoutCoverageMajorInput = {
    where: CoverageMajorLectureWhereUniqueInput
    update: XOR<CoverageMajorLectureUncheckedUpdateWithoutCoverageMajorInput, CoverageMajorLectureUpdateWithoutCoverageMajorInput>
    create: XOR<CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput, CoverageMajorLectureCreateWithoutCoverageMajorInput>
  }

  export type CoverageMajorLectureUpdateWithWhereUniqueWithoutCoverageMajorInput = {
    where: CoverageMajorLectureWhereUniqueInput
    data: XOR<CoverageMajorLectureUncheckedUpdateWithoutCoverageMajorInput, CoverageMajorLectureUpdateWithoutCoverageMajorInput>
  }

  export type CoverageMajorLectureUpdateManyWithWhereWithoutCoverageMajorInput = {
    where: CoverageMajorLectureScalarWhereInput
    data: XOR<CoverageMajorLectureUncheckedUpdateManyWithoutCoverageMajorLecturesInput, CoverageMajorLectureUpdateManyMutationInput>
  }

  export type CoverageMajorLectureScalarWhereInput = {
    AND?: Enumerable<CoverageMajorLectureScalarWhereInput>
    OR?: Enumerable<CoverageMajorLectureScalarWhereInput>
    NOT?: Enumerable<CoverageMajorLectureScalarWhereInput>
    lectureId?: StringFilter | string
    majorCode?: StringFilter | string
  }

  export type LectureCreateWithoutCoverageMajorLecturesInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    periods?: PeriodCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutCoverageMajorLecturesInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    periods?: PeriodUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutcoverageMajorLecturesInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureUncheckedCreateWithoutCoverageMajorLecturesInput, LectureCreateWithoutCoverageMajorLecturesInput>
  }

  export type CoverageMajorCreateWithoutCoverageMajorLecturesInput = {
    coverageCollege?: string | null
    name: string
    code: string
  }

  export type CoverageMajorUncheckedCreateWithoutCoverageMajorLecturesInput = {
    coverageCollege?: string | null
    name: string
    code: string
  }

  export type CoverageMajorCreateOrConnectWithoutcoverageMajorLecturesInput = {
    where: CoverageMajorWhereUniqueInput
    create: XOR<CoverageMajorUncheckedCreateWithoutCoverageMajorLecturesInput, CoverageMajorCreateWithoutCoverageMajorLecturesInput>
  }

  export type LectureUpsertWithoutCoverageMajorLecturesInput = {
    update: XOR<LectureUncheckedUpdateWithoutCoverageMajorLecturesInput, LectureUpdateWithoutCoverageMajorLecturesInput>
    create: XOR<LectureUncheckedCreateWithoutCoverageMajorLecturesInput, LectureCreateWithoutCoverageMajorLecturesInput>
  }

  export type LectureUpdateWithoutCoverageMajorLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    periods?: PeriodUpdateManyWithoutLectureInput
  }

  export type LectureUncheckedUpdateWithoutCoverageMajorLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    periods?: PeriodUncheckedUpdateManyWithoutLectureInput
  }

  export type CoverageMajorUpsertWithoutCoverageMajorLecturesInput = {
    update: XOR<CoverageMajorUncheckedUpdateWithoutCoverageMajorLecturesInput, CoverageMajorUpdateWithoutCoverageMajorLecturesInput>
    create: XOR<CoverageMajorUncheckedCreateWithoutCoverageMajorLecturesInput, CoverageMajorCreateWithoutCoverageMajorLecturesInput>
  }

  export type CoverageMajorUpdateWithoutCoverageMajorLecturesInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorUncheckedUpdateWithoutCoverageMajorLecturesInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorLectureCreateWithoutLectureInput = {
    coverageMajor: CoverageMajorCreateNestedOneWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedCreateWithoutLectureInput = {
    majorCode: string
  }

  export type CoverageMajorLectureCreateOrConnectWithoutlectureInput = {
    where: CoverageMajorLectureWhereUniqueInput
    create: XOR<CoverageMajorLectureUncheckedCreateWithoutLectureInput, CoverageMajorLectureCreateWithoutLectureInput>
  }

  export type PeriodCreateWithoutLectureInput = {
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodUncheckedCreateWithoutLectureInput = {
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodCreateOrConnectWithoutlectureInput = {
    where: PeriodWhereUniqueInput
    create: XOR<PeriodUncheckedCreateWithoutLectureInput, PeriodCreateWithoutLectureInput>
  }

  export type CoverageMajorLectureUpsertWithWhereUniqueWithoutLectureInput = {
    where: CoverageMajorLectureWhereUniqueInput
    update: XOR<CoverageMajorLectureUncheckedUpdateWithoutLectureInput, CoverageMajorLectureUpdateWithoutLectureInput>
    create: XOR<CoverageMajorLectureUncheckedCreateWithoutLectureInput, CoverageMajorLectureCreateWithoutLectureInput>
  }

  export type CoverageMajorLectureUpdateWithWhereUniqueWithoutLectureInput = {
    where: CoverageMajorLectureWhereUniqueInput
    data: XOR<CoverageMajorLectureUncheckedUpdateWithoutLectureInput, CoverageMajorLectureUpdateWithoutLectureInput>
  }

  export type CoverageMajorLectureUpdateManyWithWhereWithoutLectureInput = {
    where: CoverageMajorLectureScalarWhereInput
    data: XOR<CoverageMajorLectureUncheckedUpdateManyWithoutCoverageMajorLecturesInput, CoverageMajorLectureUpdateManyMutationInput>
  }

  export type PeriodUpsertWithWhereUniqueWithoutLectureInput = {
    where: PeriodWhereUniqueInput
    update: XOR<PeriodUncheckedUpdateWithoutLectureInput, PeriodUpdateWithoutLectureInput>
    create: XOR<PeriodUncheckedCreateWithoutLectureInput, PeriodCreateWithoutLectureInput>
  }

  export type PeriodUpdateWithWhereUniqueWithoutLectureInput = {
    where: PeriodWhereUniqueInput
    data: XOR<PeriodUncheckedUpdateWithoutLectureInput, PeriodUpdateWithoutLectureInput>
  }

  export type PeriodUpdateManyWithWhereWithoutLectureInput = {
    where: PeriodScalarWhereInput
    data: XOR<PeriodUncheckedUpdateManyWithoutPeriodsInput, PeriodUpdateManyMutationInput>
  }

  export type PeriodScalarWhereInput = {
    AND?: Enumerable<PeriodScalarWhereInput>
    OR?: Enumerable<PeriodScalarWhereInput>
    NOT?: Enumerable<PeriodScalarWhereInput>
    lectureId?: StringFilter | string
    day?: StringFilter | string
    startH?: IntFilter | number
    startM?: IntFilter | number
    endH?: IntFilter | number
    endM?: IntFilter | number
  }

  export type UserCreateWithoutLiveChatsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLiveChatsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutliveChatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutLiveChatsInput, UserCreateWithoutLiveChatsInput>
  }

  export type UserUpsertWithoutLiveChatsInput = {
    update: XOR<UserUncheckedUpdateWithoutLiveChatsInput, UserUpdateWithoutLiveChatsInput>
    create: XOR<UserUncheckedCreateWithoutLiveChatsInput, UserCreateWithoutLiveChatsInput>
  }

  export type UserUpdateWithoutLiveChatsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutLiveChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutNoticeNotificationsSubscriptionsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNoticeNotificationsSubscriptionsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutnoticeNotificationsSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutNoticeNotificationsSubscriptionsInput, UserCreateWithoutNoticeNotificationsSubscriptionsInput>
  }

  export type UserUpsertWithoutNoticeNotificationsSubscriptionsInput = {
    update: XOR<UserUncheckedUpdateWithoutNoticeNotificationsSubscriptionsInput, UserUpdateWithoutNoticeNotificationsSubscriptionsInput>
    create: XOR<UserUncheckedCreateWithoutNoticeNotificationsSubscriptionsInput, UserCreateWithoutNoticeNotificationsSubscriptionsInput>
  }

  export type UserUpdateWithoutNoticeNotificationsSubscriptionsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutNoticeNotificationsSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type LectureCreateWithoutPeriodsInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    coverageMajorLectures?: CoverageMajorLectureCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutPeriodsInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    coverageMajorLectures?: CoverageMajorLectureUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutperiodsInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureUncheckedCreateWithoutPeriodsInput, LectureCreateWithoutPeriodsInput>
  }

  export type LectureUpsertWithoutPeriodsInput = {
    update: XOR<LectureUncheckedUpdateWithoutPeriodsInput, LectureUpdateWithoutPeriodsInput>
    create: XOR<LectureUncheckedCreateWithoutPeriodsInput, LectureCreateWithoutPeriodsInput>
  }

  export type LectureUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    coverageMajorLectures?: CoverageMajorLectureUpdateManyWithoutLectureInput
  }

  export type LectureUncheckedUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    coverageMajorLectures?: CoverageMajorLectureUncheckedUpdateManyWithoutLectureInput
  }

  export type UserCreateWithoutPushesInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPushesInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutpushesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutPushesInput, UserCreateWithoutPushesInput>
  }

  export type UserUpsertWithoutPushesInput = {
    update: XOR<UserUncheckedUpdateWithoutPushesInput, UserUpdateWithoutPushesInput>
    create: XOR<UserUncheckedCreateWithoutPushesInput, UserCreateWithoutPushesInput>
  }

  export type UserUpdateWithoutPushesInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutPushesInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type AdminCreateWithoutUserInput = {

  }

  export type AdminUncheckedCreateWithoutUserInput = {

  }

  export type AdminCreateOrConnectWithoutuserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminUncheckedCreateWithoutUserInput, AdminCreateWithoutUserInput>
  }

  export type ChangePasswordCreateWithoutUserInput = {
    token: string
    requestedAt: Date | string
  }

  export type ChangePasswordUncheckedCreateWithoutUserInput = {
    token: string
    requestedAt: Date | string
  }

  export type ChangePasswordCreateOrConnectWithoutuserInput = {
    where: ChangePasswordWhereUniqueInput
    create: XOR<ChangePasswordUncheckedCreateWithoutUserInput, ChangePasswordCreateWithoutUserInput>
  }

  export type CommunityBoardCreateWithoutUserInput = {
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdAt: Date | string
    activeAt?: Date | string | null
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdAt: Date | string
    activeAt?: Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardCreateOrConnectWithoutuserInput = {
    where: CommunityBoardWhereUniqueInput
    create: XOR<CommunityBoardUncheckedCreateWithoutUserInput, CommunityBoardCreateWithoutUserInput>
  }

  export type CommunityBoardCandidateCreateWithoutUserInput = {
    name?: string
    description?: string | null
    createdAt: Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string
    description?: string | null
    createdAt: Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateCreateOrConnectWithoutuserInput = {
    where: CommunityBoardCandidateWhereUniqueInput
    create: XOR<CommunityBoardCandidateUncheckedCreateWithoutUserInput, CommunityBoardCandidateCreateWithoutUserInput>
  }

  export type CommunityBoardCandidateVoteCreateWithoutUserInput = {
    communityBoardCandidate: CommunityBoardCandidateCreateNestedOneWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput = {
    boardCandidateId: number
  }

  export type CommunityBoardCandidateVoteCreateOrConnectWithoutuserInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    create: XOR<CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput, CommunityBoardCandidateVoteCreateWithoutUserInput>
  }

  export type CommunityBoardPinCreateWithoutUserInput = {
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedCreateWithoutUserInput = {
    boardId: number
  }

  export type CommunityBoardPinCreateOrConnectWithoutuserInput = {
    where: CommunityBoardPinWhereUniqueInput
    create: XOR<CommunityBoardPinUncheckedCreateWithoutUserInput, CommunityBoardPinCreateWithoutUserInput>
  }

  export type CommunityCommentCreateWithoutUserInput = {
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communityPost: CommunityPostCreateNestedOneWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentCreateOrConnectWithoutuserInput = {
    where: CommunityCommentWhereUniqueInput
    create: XOR<CommunityCommentUncheckedCreateWithoutUserInput, CommunityCommentCreateWithoutUserInput>
  }

  export type CommunityPostCreateWithoutUserInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutUserInput = {
    id?: number
    boardId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutuserInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostUncheckedCreateWithoutUserInput, CommunityPostCreateWithoutUserInput>
  }

  export type CommunityPostBookmarkCreateWithoutUserInput = {
    communityPost: CommunityPostCreateNestedOneWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedCreateWithoutUserInput = {
    postId: number
  }

  export type CommunityPostBookmarkCreateOrConnectWithoutuserInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    create: XOR<CommunityPostBookmarkUncheckedCreateWithoutUserInput, CommunityPostBookmarkCreateWithoutUserInput>
  }

  export type CommunityPostLikeCreateWithoutUserInput = {
    communityPost: CommunityPostCreateNestedOneWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedCreateWithoutUserInput = {
    postId: number
  }

  export type CommunityPostLikeCreateOrConnectWithoutuserInput = {
    where: CommunityPostLikeWhereUniqueInput
    create: XOR<CommunityPostLikeUncheckedCreateWithoutUserInput, CommunityPostLikeCreateWithoutUserInput>
  }

  export type CommunitySubcommentCreateWithoutUserInput = {
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    communityComment: CommunityCommentCreateNestedOneWithoutCommunitySubcommentsInput
    communityPost: CommunityPostCreateNestedOneWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    commentId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentCreateOrConnectWithoutuserInput = {
    where: CommunitySubcommentWhereUniqueInput
    create: XOR<CommunitySubcommentUncheckedCreateWithoutUserInput, CommunitySubcommentCreateWithoutUserInput>
  }

  export type LiveChatCreateWithoutUserInput = {
    id?: number
    message: string
    createdAt: Date | string
    randomNickname: string
  }

  export type LiveChatUncheckedCreateWithoutUserInput = {
    id?: number
    message: string
    createdAt: Date | string
    randomNickname: string
  }

  export type LiveChatCreateOrConnectWithoutuserInput = {
    where: LiveChatWhereUniqueInput
    create: XOR<LiveChatUncheckedCreateWithoutUserInput, LiveChatCreateWithoutUserInput>
  }

  export type NoticeNotificationsSubscriptionCreateWithoutUserInput = {
    noticeKey: string
    subscribedAt: Date | string
  }

  export type NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput = {
    id?: number
    noticeKey: string
    subscribedAt: Date | string
  }

  export type NoticeNotificationsSubscriptionCreateOrConnectWithoutuserInput = {
    where: NoticeNotificationsSubscriptionWhereUniqueInput
    create: XOR<NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput, NoticeNotificationsSubscriptionCreateWithoutUserInput>
  }

  export type PushCreateWithoutUserInput = {
    expoPushToken?: string
    registeredAt: Date | string
    activeAt?: Date | string | null
  }

  export type PushUncheckedCreateWithoutUserInput = {
    expoPushToken?: string
    registeredAt: Date | string
    activeAt?: Date | string | null
  }

  export type PushCreateOrConnectWithoutuserInput = {
    where: PushWhereUniqueInput
    create: XOR<PushUncheckedCreateWithoutUserInput, PushCreateWithoutUserInput>
  }

  export type ReportCommentCreateWithoutUserInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communityComment: CommunityCommentCreateNestedOneWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedCreateWithoutUserInput = {
    id?: number
    commentId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportCommentCreateOrConnectWithoutuserInput = {
    where: ReportCommentWhereUniqueInput
    create: XOR<ReportCommentUncheckedCreateWithoutUserInput, ReportCommentCreateWithoutUserInput>
  }

  export type ReportPostCreateWithoutUserInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communityPost: CommunityPostCreateNestedOneWithoutReportPostsInput
  }

  export type ReportPostUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportPostCreateOrConnectWithoutuserInput = {
    where: ReportPostWhereUniqueInput
    create: XOR<ReportPostUncheckedCreateWithoutUserInput, ReportPostCreateWithoutUserInput>
  }

  export type ReportSubcommentCreateWithoutUserInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communitySubcomment: CommunitySubcommentCreateNestedOneWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedCreateWithoutUserInput = {
    id?: number
    subcommentId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportSubcommentCreateOrConnectWithoutuserInput = {
    where: ReportSubcommentWhereUniqueInput
    create: XOR<ReportSubcommentUncheckedCreateWithoutUserInput, ReportSubcommentCreateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {

  }

  export type AdminUncheckedUpdateWithoutUserInput = {

  }

  export type ChangePasswordUpsertWithoutUserInput = {
    update: XOR<ChangePasswordUncheckedUpdateWithoutUserInput, ChangePasswordUpdateWithoutUserInput>
    create: XOR<ChangePasswordUncheckedCreateWithoutUserInput, ChangePasswordCreateWithoutUserInput>
  }

  export type ChangePasswordUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangePasswordUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBoardUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardWhereUniqueInput
    update: XOR<CommunityBoardUncheckedUpdateWithoutUserInput, CommunityBoardUpdateWithoutUserInput>
    create: XOR<CommunityBoardUncheckedCreateWithoutUserInput, CommunityBoardCreateWithoutUserInput>
  }

  export type CommunityBoardUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardWhereUniqueInput
    data: XOR<CommunityBoardUncheckedUpdateWithoutUserInput, CommunityBoardUpdateWithoutUserInput>
  }

  export type CommunityBoardUpdateManyWithWhereWithoutUserInput = {
    where: CommunityBoardScalarWhereInput
    data: XOR<CommunityBoardUncheckedUpdateManyWithoutCommunityBoardsInput, CommunityBoardUpdateManyMutationInput>
  }

  export type CommunityBoardScalarWhereInput = {
    AND?: Enumerable<CommunityBoardScalarWhereInput>
    OR?: Enumerable<CommunityBoardScalarWhereInput>
    NOT?: Enumerable<CommunityBoardScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    priority?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    createdBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    activeAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CommunityBoardCandidateUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardCandidateWhereUniqueInput
    update: XOR<CommunityBoardCandidateUncheckedUpdateWithoutUserInput, CommunityBoardCandidateUpdateWithoutUserInput>
    create: XOR<CommunityBoardCandidateUncheckedCreateWithoutUserInput, CommunityBoardCandidateCreateWithoutUserInput>
  }

  export type CommunityBoardCandidateUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardCandidateWhereUniqueInput
    data: XOR<CommunityBoardCandidateUncheckedUpdateWithoutUserInput, CommunityBoardCandidateUpdateWithoutUserInput>
  }

  export type CommunityBoardCandidateUpdateManyWithWhereWithoutUserInput = {
    where: CommunityBoardCandidateScalarWhereInput
    data: XOR<CommunityBoardCandidateUncheckedUpdateManyWithoutCommunityBoardCandidatesInput, CommunityBoardCandidateUpdateManyMutationInput>
  }

  export type CommunityBoardCandidateScalarWhereInput = {
    AND?: Enumerable<CommunityBoardCandidateScalarWhereInput>
    OR?: Enumerable<CommunityBoardCandidateScalarWhereInput>
    NOT?: Enumerable<CommunityBoardCandidateScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    update: XOR<CommunityBoardCandidateVoteUncheckedUpdateWithoutUserInput, CommunityBoardCandidateVoteUpdateWithoutUserInput>
    create: XOR<CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput, CommunityBoardCandidateVoteCreateWithoutUserInput>
  }

  export type CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    data: XOR<CommunityBoardCandidateVoteUncheckedUpdateWithoutUserInput, CommunityBoardCandidateVoteUpdateWithoutUserInput>
  }

  export type CommunityBoardCandidateVoteUpdateManyWithWhereWithoutUserInput = {
    where: CommunityBoardCandidateVoteScalarWhereInput
    data: XOR<CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateVoteUpdateManyMutationInput>
  }

  export type CommunityBoardPinUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardPinWhereUniqueInput
    update: XOR<CommunityBoardPinUncheckedUpdateWithoutUserInput, CommunityBoardPinUpdateWithoutUserInput>
    create: XOR<CommunityBoardPinUncheckedCreateWithoutUserInput, CommunityBoardPinCreateWithoutUserInput>
  }

  export type CommunityBoardPinUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardPinWhereUniqueInput
    data: XOR<CommunityBoardPinUncheckedUpdateWithoutUserInput, CommunityBoardPinUpdateWithoutUserInput>
  }

  export type CommunityBoardPinUpdateManyWithWhereWithoutUserInput = {
    where: CommunityBoardPinScalarWhereInput
    data: XOR<CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardPinsInput, CommunityBoardPinUpdateManyMutationInput>
  }

  export type CommunityCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityCommentWhereUniqueInput
    update: XOR<CommunityCommentUncheckedUpdateWithoutUserInput, CommunityCommentUpdateWithoutUserInput>
    create: XOR<CommunityCommentUncheckedCreateWithoutUserInput, CommunityCommentCreateWithoutUserInput>
  }

  export type CommunityCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityCommentWhereUniqueInput
    data: XOR<CommunityCommentUncheckedUpdateWithoutUserInput, CommunityCommentUpdateWithoutUserInput>
  }

  export type CommunityCommentUpdateManyWithWhereWithoutUserInput = {
    where: CommunityCommentScalarWhereInput
    data: XOR<CommunityCommentUncheckedUpdateManyWithoutCommunityCommentsInput, CommunityCommentUpdateManyMutationInput>
  }

  export type CommunityPostUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityPostWhereUniqueInput
    update: XOR<CommunityPostUncheckedUpdateWithoutUserInput, CommunityPostUpdateWithoutUserInput>
    create: XOR<CommunityPostUncheckedCreateWithoutUserInput, CommunityPostCreateWithoutUserInput>
  }

  export type CommunityPostUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityPostWhereUniqueInput
    data: XOR<CommunityPostUncheckedUpdateWithoutUserInput, CommunityPostUpdateWithoutUserInput>
  }

  export type CommunityPostUpdateManyWithWhereWithoutUserInput = {
    where: CommunityPostScalarWhereInput
    data: XOR<CommunityPostUncheckedUpdateManyWithoutCommunityPostsInput, CommunityPostUpdateManyMutationInput>
  }

  export type CommunityPostBookmarkUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    update: XOR<CommunityPostBookmarkUncheckedUpdateWithoutUserInput, CommunityPostBookmarkUpdateWithoutUserInput>
    create: XOR<CommunityPostBookmarkUncheckedCreateWithoutUserInput, CommunityPostBookmarkCreateWithoutUserInput>
  }

  export type CommunityPostBookmarkUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    data: XOR<CommunityPostBookmarkUncheckedUpdateWithoutUserInput, CommunityPostBookmarkUpdateWithoutUserInput>
  }

  export type CommunityPostBookmarkUpdateManyWithWhereWithoutUserInput = {
    where: CommunityPostBookmarkScalarWhereInput
    data: XOR<CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostBookmarksInput, CommunityPostBookmarkUpdateManyMutationInput>
  }

  export type CommunityPostLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityPostLikeWhereUniqueInput
    update: XOR<CommunityPostLikeUncheckedUpdateWithoutUserInput, CommunityPostLikeUpdateWithoutUserInput>
    create: XOR<CommunityPostLikeUncheckedCreateWithoutUserInput, CommunityPostLikeCreateWithoutUserInput>
  }

  export type CommunityPostLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityPostLikeWhereUniqueInput
    data: XOR<CommunityPostLikeUncheckedUpdateWithoutUserInput, CommunityPostLikeUpdateWithoutUserInput>
  }

  export type CommunityPostLikeUpdateManyWithWhereWithoutUserInput = {
    where: CommunityPostLikeScalarWhereInput
    data: XOR<CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostLikesInput, CommunityPostLikeUpdateManyMutationInput>
  }

  export type CommunitySubcommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunitySubcommentWhereUniqueInput
    update: XOR<CommunitySubcommentUncheckedUpdateWithoutUserInput, CommunitySubcommentUpdateWithoutUserInput>
    create: XOR<CommunitySubcommentUncheckedCreateWithoutUserInput, CommunitySubcommentCreateWithoutUserInput>
  }

  export type CommunitySubcommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunitySubcommentWhereUniqueInput
    data: XOR<CommunitySubcommentUncheckedUpdateWithoutUserInput, CommunitySubcommentUpdateWithoutUserInput>
  }

  export type CommunitySubcommentUpdateManyWithWhereWithoutUserInput = {
    where: CommunitySubcommentScalarWhereInput
    data: XOR<CommunitySubcommentUncheckedUpdateManyWithoutCommunitySubcommentsInput, CommunitySubcommentUpdateManyMutationInput>
  }

  export type LiveChatUpsertWithWhereUniqueWithoutUserInput = {
    where: LiveChatWhereUniqueInput
    update: XOR<LiveChatUncheckedUpdateWithoutUserInput, LiveChatUpdateWithoutUserInput>
    create: XOR<LiveChatUncheckedCreateWithoutUserInput, LiveChatCreateWithoutUserInput>
  }

  export type LiveChatUpdateWithWhereUniqueWithoutUserInput = {
    where: LiveChatWhereUniqueInput
    data: XOR<LiveChatUncheckedUpdateWithoutUserInput, LiveChatUpdateWithoutUserInput>
  }

  export type LiveChatUpdateManyWithWhereWithoutUserInput = {
    where: LiveChatScalarWhereInput
    data: XOR<LiveChatUncheckedUpdateManyWithoutLiveChatsInput, LiveChatUpdateManyMutationInput>
  }

  export type LiveChatScalarWhereInput = {
    AND?: Enumerable<LiveChatScalarWhereInput>
    OR?: Enumerable<LiveChatScalarWhereInput>
    NOT?: Enumerable<LiveChatScalarWhereInput>
    id?: IntFilter | number
    message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    randomNickname?: StringFilter | string
  }

  export type NoticeNotificationsSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: NoticeNotificationsSubscriptionWhereUniqueInput
    update: XOR<NoticeNotificationsSubscriptionUncheckedUpdateWithoutUserInput, NoticeNotificationsSubscriptionUpdateWithoutUserInput>
    create: XOR<NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput, NoticeNotificationsSubscriptionCreateWithoutUserInput>
  }

  export type NoticeNotificationsSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: NoticeNotificationsSubscriptionWhereUniqueInput
    data: XOR<NoticeNotificationsSubscriptionUncheckedUpdateWithoutUserInput, NoticeNotificationsSubscriptionUpdateWithoutUserInput>
  }

  export type NoticeNotificationsSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: NoticeNotificationsSubscriptionScalarWhereInput
    data: XOR<NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutNoticeNotificationsSubscriptionsInput, NoticeNotificationsSubscriptionUpdateManyMutationInput>
  }

  export type NoticeNotificationsSubscriptionScalarWhereInput = {
    AND?: Enumerable<NoticeNotificationsSubscriptionScalarWhereInput>
    OR?: Enumerable<NoticeNotificationsSubscriptionScalarWhereInput>
    NOT?: Enumerable<NoticeNotificationsSubscriptionScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    noticeKey?: StringFilter | string
    subscribedAt?: DateTimeFilter | Date | string
  }

  export type PushUpsertWithWhereUniqueWithoutUserInput = {
    where: PushWhereUniqueInput
    update: XOR<PushUncheckedUpdateWithoutUserInput, PushUpdateWithoutUserInput>
    create: XOR<PushUncheckedCreateWithoutUserInput, PushCreateWithoutUserInput>
  }

  export type PushUpdateWithWhereUniqueWithoutUserInput = {
    where: PushWhereUniqueInput
    data: XOR<PushUncheckedUpdateWithoutUserInput, PushUpdateWithoutUserInput>
  }

  export type PushUpdateManyWithWhereWithoutUserInput = {
    where: PushScalarWhereInput
    data: XOR<PushUncheckedUpdateManyWithoutPushesInput, PushUpdateManyMutationInput>
  }

  export type PushScalarWhereInput = {
    AND?: Enumerable<PushScalarWhereInput>
    OR?: Enumerable<PushScalarWhereInput>
    NOT?: Enumerable<PushScalarWhereInput>
    userId?: IntFilter | number
    expoPushToken?: StringFilter | string
    registeredAt?: DateTimeFilter | Date | string
    activeAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ReportCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportCommentWhereUniqueInput
    update: XOR<ReportCommentUncheckedUpdateWithoutUserInput, ReportCommentUpdateWithoutUserInput>
    create: XOR<ReportCommentUncheckedCreateWithoutUserInput, ReportCommentCreateWithoutUserInput>
  }

  export type ReportCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportCommentWhereUniqueInput
    data: XOR<ReportCommentUncheckedUpdateWithoutUserInput, ReportCommentUpdateWithoutUserInput>
  }

  export type ReportCommentUpdateManyWithWhereWithoutUserInput = {
    where: ReportCommentScalarWhereInput
    data: XOR<ReportCommentUncheckedUpdateManyWithoutReportCommentsInput, ReportCommentUpdateManyMutationInput>
  }

  export type ReportPostUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportPostWhereUniqueInput
    update: XOR<ReportPostUncheckedUpdateWithoutUserInput, ReportPostUpdateWithoutUserInput>
    create: XOR<ReportPostUncheckedCreateWithoutUserInput, ReportPostCreateWithoutUserInput>
  }

  export type ReportPostUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportPostWhereUniqueInput
    data: XOR<ReportPostUncheckedUpdateWithoutUserInput, ReportPostUpdateWithoutUserInput>
  }

  export type ReportPostUpdateManyWithWhereWithoutUserInput = {
    where: ReportPostScalarWhereInput
    data: XOR<ReportPostUncheckedUpdateManyWithoutReportPostsInput, ReportPostUpdateManyMutationInput>
  }

  export type ReportSubcommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportSubcommentWhereUniqueInput
    update: XOR<ReportSubcommentUncheckedUpdateWithoutUserInput, ReportSubcommentUpdateWithoutUserInput>
    create: XOR<ReportSubcommentUncheckedCreateWithoutUserInput, ReportSubcommentCreateWithoutUserInput>
  }

  export type ReportSubcommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportSubcommentWhereUniqueInput
    data: XOR<ReportSubcommentUncheckedUpdateWithoutUserInput, ReportSubcommentUpdateWithoutUserInput>
  }

  export type ReportSubcommentUpdateManyWithWhereWithoutUserInput = {
    where: ReportSubcommentScalarWhereInput
    data: XOR<ReportSubcommentUncheckedUpdateManyWithoutReportSubcommentsInput, ReportSubcommentUpdateManyMutationInput>
  }

  export type CommunityCommentCreateWithoutReportCommentsInput = {
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communityPost: CommunityPostCreateNestedOneWithoutCommunityCommentsInput
    user: UserCreateNestedOneWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedCreateWithoutReportCommentsInput = {
    id?: number
    postId: number
    userId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentCreateOrConnectWithoutreportCommentsInput = {
    where: CommunityCommentWhereUniqueInput
    create: XOR<CommunityCommentUncheckedCreateWithoutReportCommentsInput, CommunityCommentCreateWithoutReportCommentsInput>
  }

  export type UserCreateWithoutReportCommentsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportCommentsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutreportCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutReportCommentsInput, UserCreateWithoutReportCommentsInput>
  }

  export type CommunityCommentUpsertWithoutReportCommentsInput = {
    update: XOR<CommunityCommentUncheckedUpdateWithoutReportCommentsInput, CommunityCommentUpdateWithoutReportCommentsInput>
    create: XOR<CommunityCommentUncheckedCreateWithoutReportCommentsInput, CommunityCommentCreateWithoutReportCommentsInput>
  }

  export type CommunityCommentUpdateWithoutReportCommentsInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityCommentsInput
    user?: UserUpdateOneRequiredWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateWithoutReportCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityCommentInput
  }

  export type UserUpsertWithoutReportCommentsInput = {
    update: XOR<UserUncheckedUpdateWithoutReportCommentsInput, UserUpdateWithoutReportCommentsInput>
    create: XOR<UserUncheckedCreateWithoutReportCommentsInput, UserCreateWithoutReportCommentsInput>
  }

  export type UserUpdateWithoutReportCommentsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutReportCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityPostCreateWithoutReportPostsInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutReportPostsInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutreportPostsInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostUncheckedCreateWithoutReportPostsInput, CommunityPostCreateWithoutReportPostsInput>
  }

  export type UserCreateWithoutReportPostsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportPostsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutreportPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutReportPostsInput, UserCreateWithoutReportPostsInput>
  }

  export type CommunityPostUpsertWithoutReportPostsInput = {
    update: XOR<CommunityPostUncheckedUpdateWithoutReportPostsInput, CommunityPostUpdateWithoutReportPostsInput>
    create: XOR<CommunityPostUncheckedCreateWithoutReportPostsInput, CommunityPostCreateWithoutReportPostsInput>
  }

  export type CommunityPostUpdateWithoutReportPostsInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutReportPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type UserUpsertWithoutReportPostsInput = {
    update: XOR<UserUncheckedUpdateWithoutReportPostsInput, UserUpdateWithoutReportPostsInput>
    create: XOR<UserUncheckedCreateWithoutReportPostsInput, UserCreateWithoutReportPostsInput>
  }

  export type UserUpdateWithoutReportPostsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutReportPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type CommunitySubcommentCreateWithoutReportSubcommentsInput = {
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    communityComment: CommunityCommentCreateNestedOneWithoutCommunitySubcommentsInput
    communityPost: CommunityPostCreateNestedOneWithoutCommunitySubcommentsInput
    user: UserCreateNestedOneWithoutCommunitySubcommentsInput
  }

  export type CommunitySubcommentUncheckedCreateWithoutReportSubcommentsInput = {
    id?: number
    userId: number
    postId: number
    commentId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
  }

  export type CommunitySubcommentCreateOrConnectWithoutreportSubcommentsInput = {
    where: CommunitySubcommentWhereUniqueInput
    create: XOR<CommunitySubcommentUncheckedCreateWithoutReportSubcommentsInput, CommunitySubcommentCreateWithoutReportSubcommentsInput>
  }

  export type UserCreateWithoutReportSubcommentsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    pushes?: PushCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportSubcommentsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    pushes?: PushUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutreportSubcommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutReportSubcommentsInput, UserCreateWithoutReportSubcommentsInput>
  }

  export type CommunitySubcommentUpsertWithoutReportSubcommentsInput = {
    update: XOR<CommunitySubcommentUncheckedUpdateWithoutReportSubcommentsInput, CommunitySubcommentUpdateWithoutReportSubcommentsInput>
    create: XOR<CommunitySubcommentUncheckedCreateWithoutReportSubcommentsInput, CommunitySubcommentCreateWithoutReportSubcommentsInput>
  }

  export type CommunitySubcommentUpdateWithoutReportSubcommentsInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComment?: CommunityCommentUpdateOneRequiredWithoutCommunitySubcommentsInput
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunitySubcommentsInput
    user?: UserUpdateOneRequiredWithoutCommunitySubcommentsInput
  }

  export type CommunitySubcommentUncheckedUpdateWithoutReportSubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutReportSubcommentsInput = {
    update: XOR<UserUncheckedUpdateWithoutReportSubcommentsInput, UserUpdateWithoutReportSubcommentsInput>
    create: XOR<UserUncheckedCreateWithoutReportSubcommentsInput, UserCreateWithoutReportSubcommentsInput>
  }

  export type UserUpdateWithoutReportSubcommentsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    pushes?: PushUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutReportSubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    pushes?: PushUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityBoardPinUpdateWithoutCommunityBoardInput = {
    user?: UserUpdateOneRequiredWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedUpdateWithoutCommunityBoardInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardPinsInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostUpdateWithoutCommunityBoardInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommunityBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateManyWithoutCommunityPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityBoardCandidateVoteUpdateWithoutCommunityBoardCandidateInput = {
    user?: UserUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateWithoutCommunityBoardCandidateInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateVotesInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunitySubcommentUpdateWithoutCommunityCommentInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunitySubcommentsInput
    user?: UserUpdateOneRequiredWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedUpdateWithoutCommunityCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedUpdateManyWithoutCommunitySubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReportCommentUpdateWithoutCommunityCommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedUpdateWithoutCommunityCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCommentUncheckedUpdateManyWithoutReportCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCommentUpdateWithoutCommunityPostInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateWithoutCommunityPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateManyWithoutCommunityCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityPostBookmarkUpdateWithoutCommunityPostInput = {
    user?: UserUpdateOneRequiredWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedUpdateWithoutCommunityPostInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostBookmarksInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostLikeUpdateWithoutCommunityPostInput = {
    user?: UserUpdateOneRequiredWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedUpdateWithoutCommunityPostInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostLikesInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunitySubcommentUpdateWithoutCommunityPostInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComment?: CommunityCommentUpdateOneRequiredWithoutCommunitySubcommentsInput
    user?: UserUpdateOneRequiredWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedUpdateWithoutCommunityPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutCommunitySubcommentInput
  }

  export type ReportPostUpdateWithoutCommunityPostInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportPostsInput
  }

  export type ReportPostUncheckedUpdateWithoutCommunityPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPostUncheckedUpdateManyWithoutReportPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentUpdateWithoutCommunitySubcommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedUpdateWithoutCommunitySubcommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentUncheckedUpdateManyWithoutReportSubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoverageMajorLectureUpdateWithoutCoverageMajorInput = {
    lecture?: LectureUpdateOneRequiredWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedUpdateWithoutCoverageMajorInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorLectureUncheckedUpdateManyWithoutCoverageMajorLecturesInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorLectureUpdateWithoutLectureInput = {
    coverageMajor?: CoverageMajorUpdateOneRequiredWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedUpdateWithoutLectureInput = {
    majorCode?: StringFieldUpdateOperationsInput | string
  }

  export type PeriodUpdateWithoutLectureInput = {
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type PeriodUncheckedUpdateWithoutLectureInput = {
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type PeriodUncheckedUpdateManyWithoutPeriodsInput = {
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedUpdateManyWithoutCommunityBoardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityBoardCandidateUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUncheckedUpdateManyWithoutCommunityBoardCandidatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBoardCandidateVoteUpdateWithoutUserInput = {
    communityBoardCandidate?: CommunityBoardCandidateUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateWithoutUserInput = {
    boardCandidateId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardPinUpdateWithoutUserInput = {
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedUpdateWithoutUserInput = {
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityCommentUpdateWithoutUserInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityPostUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostBookmarkUpdateWithoutUserInput = {
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedUpdateWithoutUserInput = {
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostLikeUpdateWithoutUserInput = {
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedUpdateWithoutUserInput = {
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunitySubcommentUpdateWithoutUserInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComment?: CommunityCommentUpdateOneRequiredWithoutCommunitySubcommentsInput
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutCommunitySubcommentInput
  }

  export type LiveChatUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type LiveChatUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type LiveChatUncheckedUpdateManyWithoutLiveChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type NoticeNotificationsSubscriptionUpdateWithoutUserInput = {
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeNotificationsSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutNoticeNotificationsSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushUpdateWithoutUserInput = {
    expoPushToken?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PushUncheckedUpdateWithoutUserInput = {
    expoPushToken?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PushUncheckedUpdateManyWithoutPushesInput = {
    expoPushToken?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCommentUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityComment?: CommunityCommentUpdateOneRequiredWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPostUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityPost?: CommunityPostUpdateOneRequiredWithoutReportPostsInput
  }

  export type ReportPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communitySubcomment?: CommunitySubcommentUpdateOneRequiredWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    subcommentId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}