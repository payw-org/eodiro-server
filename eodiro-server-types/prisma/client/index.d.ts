
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Admin
 */

export type Admin = {
  userId: number
}

/**
 * Model CafeteriaMenu
 */

export type CafeteriaMenu = {
  campus: string
  servedAt: Date
  data: Prisma.JsonValue | null
}

/**
 * Model ChangePassword
 */

export type ChangePassword = {
  userId: number
  token: string
  requestedAt: Date
}

/**
 * Model CommunityBoard
 */

export type CommunityBoard = {
  id: number
  name: string
  description: string | null
  priority: number
  isDeleted: boolean
  createdBy: number
  createdAt: Date
  activeAt: Date | null
}

/**
 * Model CommunityBoardCandidate
 */

export type CommunityBoardCandidate = {
  id: number
  name: string
  description: string | null
  createdBy: number
  createdAt: Date
}

/**
 * Model CommunityBoardCandidateVote
 */

export type CommunityBoardCandidateVote = {
  boardCandidateId: number
  userId: number
}

/**
 * Model CommunityBoardPin
 */

export type CommunityBoardPin = {
  userId: number
  boardId: number
}

/**
 * Model CommunityComment
 */

export type CommunityComment = {
  id: number
  postId: number
  userId: number
  randomNickname: string
  body: string
  commentedAt: Date
  isDeleted: boolean
}

/**
 * Model CommunityPost
 */

export type CommunityPost = {
  id: number
  boardId: number
  userId: number
  title: string
  body: string
  randomNickname: string
  likesCount: number
  commentsCount: number
  bookmarksCount: number
  postedAt: Date
  editedAt: Date | null
  isDeleted: boolean
}

/**
 * Model CommunityPostBookmark
 */

export type CommunityPostBookmark = {
  userId: number
  postId: number
}

/**
 * Model CommunityPostLike
 */

export type CommunityPostLike = {
  userId: number
  postId: number
}

/**
 * Model CommunitySubcomment
 */

export type CommunitySubcomment = {
  id: number
  userId: number
  postId: number
  commentId: number
  randomNickname: string
  body: string
  subcommentedAt: Date
  isDeleted: boolean
}

/**
 * Model CoverageMajor
 */

export type CoverageMajor = {
  coverageCollege: string | null
  name: string
  code: string
}

/**
 * Model CoverageMajorLecture
 */

export type CoverageMajorLecture = {
  lectureId: string
  majorCode: string
}

/**
 * Model Lecture
 */

export type Lecture = {
  id: string
  year: number | null
  semester: string | null
  campus: string | null
  college: string | null
  major: string | null
  grade: number | null
  credit: number | null
  course: string | null
  section: string | null
  code: string | null
  name: string | null
  professor: string | null
  schedule: string | null
  building: number | null
  room: string | null
  note: string | null
}

/**
 * Model LiveChat
 */

export type LiveChat = {
  id: number
  message: string
  createdAt: Date
  userId: number
  randomNickname: string
}

/**
 * Model NoticeNotificationsSubscription
 */

export type NoticeNotificationsSubscription = {
  id: number
  userId: number
  noticeKey: string
  subscribedAt: Date
}

/**
 * Model PendingUser
 */

export type PendingUser = {
  id: number
  portalId: string
  password: string
  nickname: string
  randomNickname: string
  joinedAt: Date
  token: string
}

/**
 * Model Period
 */

export type Period = {
  lectureId: string
  day: string
  startH: number
  startM: number
  endH: number
  endM: number
}

/**
 * Model User
 */

export type User = {
  id: number
  portalId: string
  password: string
  nickname: string
  randomNickname: string
  point: number | null
  joinedAt: Date
  refreshToken: string | null
}

/**
 * Model ReportComment
 */

export type ReportComment = {
  id: number
  commentId: number
  userId: number
  title: string
  body: string | null
  reportedAt: Date
}

/**
 * Model ReportPost
 */

export type ReportPost = {
  id: number
  postId: number
  userId: number
  title: string
  body: string | null
  reportedAt: Date
}

/**
 * Model ReportSubcomment
 */

export type ReportSubcomment = {
  id: number
  subcommentId: number
  userId: number
  title: string
  body: string | null
  reportedAt: Date
}

/**
 * Model Telegram
 */

export type Telegram = {
  userId: number
  chatId: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<GlobalReject>;

  /**
   * `prisma.cafeteriaMenu`: Exposes CRUD operations for the **CafeteriaMenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeteriaMenus
    * const cafeteriaMenus = await prisma.cafeteriaMenu.findMany()
    * ```
    */
  get cafeteriaMenu(): Prisma.CafeteriaMenuDelegate<GlobalReject>;

  /**
   * `prisma.changePassword`: Exposes CRUD operations for the **ChangePassword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangePasswords
    * const changePasswords = await prisma.changePassword.findMany()
    * ```
    */
  get changePassword(): Prisma.ChangePasswordDelegate<GlobalReject>;

  /**
   * `prisma.communityBoard`: Exposes CRUD operations for the **CommunityBoard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityBoards
    * const communityBoards = await prisma.communityBoard.findMany()
    * ```
    */
  get communityBoard(): Prisma.CommunityBoardDelegate<GlobalReject>;

  /**
   * `prisma.communityBoardCandidate`: Exposes CRUD operations for the **CommunityBoardCandidate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityBoardCandidates
    * const communityBoardCandidates = await prisma.communityBoardCandidate.findMany()
    * ```
    */
  get communityBoardCandidate(): Prisma.CommunityBoardCandidateDelegate<GlobalReject>;

  /**
   * `prisma.communityBoardCandidateVote`: Exposes CRUD operations for the **CommunityBoardCandidateVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityBoardCandidateVotes
    * const communityBoardCandidateVotes = await prisma.communityBoardCandidateVote.findMany()
    * ```
    */
  get communityBoardCandidateVote(): Prisma.CommunityBoardCandidateVoteDelegate<GlobalReject>;

  /**
   * `prisma.communityBoardPin`: Exposes CRUD operations for the **CommunityBoardPin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityBoardPins
    * const communityBoardPins = await prisma.communityBoardPin.findMany()
    * ```
    */
  get communityBoardPin(): Prisma.CommunityBoardPinDelegate<GlobalReject>;

  /**
   * `prisma.communityComment`: Exposes CRUD operations for the **CommunityComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityComments
    * const communityComments = await prisma.communityComment.findMany()
    * ```
    */
  get communityComment(): Prisma.CommunityCommentDelegate<GlobalReject>;

  /**
   * `prisma.communityPost`: Exposes CRUD operations for the **CommunityPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityPosts
    * const communityPosts = await prisma.communityPost.findMany()
    * ```
    */
  get communityPost(): Prisma.CommunityPostDelegate<GlobalReject>;

  /**
   * `prisma.communityPostBookmark`: Exposes CRUD operations for the **CommunityPostBookmark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityPostBookmarks
    * const communityPostBookmarks = await prisma.communityPostBookmark.findMany()
    * ```
    */
  get communityPostBookmark(): Prisma.CommunityPostBookmarkDelegate<GlobalReject>;

  /**
   * `prisma.communityPostLike`: Exposes CRUD operations for the **CommunityPostLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityPostLikes
    * const communityPostLikes = await prisma.communityPostLike.findMany()
    * ```
    */
  get communityPostLike(): Prisma.CommunityPostLikeDelegate<GlobalReject>;

  /**
   * `prisma.communitySubcomment`: Exposes CRUD operations for the **CommunitySubcomment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunitySubcomments
    * const communitySubcomments = await prisma.communitySubcomment.findMany()
    * ```
    */
  get communitySubcomment(): Prisma.CommunitySubcommentDelegate<GlobalReject>;

  /**
   * `prisma.coverageMajor`: Exposes CRUD operations for the **CoverageMajor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoverageMajors
    * const coverageMajors = await prisma.coverageMajor.findMany()
    * ```
    */
  get coverageMajor(): Prisma.CoverageMajorDelegate<GlobalReject>;

  /**
   * `prisma.coverageMajorLecture`: Exposes CRUD operations for the **CoverageMajorLecture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoverageMajorLectures
    * const coverageMajorLectures = await prisma.coverageMajorLecture.findMany()
    * ```
    */
  get coverageMajorLecture(): Prisma.CoverageMajorLectureDelegate<GlobalReject>;

  /**
   * `prisma.lecture`: Exposes CRUD operations for the **Lecture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lectures
    * const lectures = await prisma.lecture.findMany()
    * ```
    */
  get lecture(): Prisma.LectureDelegate<GlobalReject>;

  /**
   * `prisma.liveChat`: Exposes CRUD operations for the **LiveChat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiveChats
    * const liveChats = await prisma.liveChat.findMany()
    * ```
    */
  get liveChat(): Prisma.LiveChatDelegate<GlobalReject>;

  /**
   * `prisma.noticeNotificationsSubscription`: Exposes CRUD operations for the **NoticeNotificationsSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoticeNotificationsSubscriptions
    * const noticeNotificationsSubscriptions = await prisma.noticeNotificationsSubscription.findMany()
    * ```
    */
  get noticeNotificationsSubscription(): Prisma.NoticeNotificationsSubscriptionDelegate<GlobalReject>;

  /**
   * `prisma.pendingUser`: Exposes CRUD operations for the **PendingUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingUsers
    * const pendingUsers = await prisma.pendingUser.findMany()
    * ```
    */
  get pendingUser(): Prisma.PendingUserDelegate<GlobalReject>;

  /**
   * `prisma.period`: Exposes CRUD operations for the **Period** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Periods
    * const periods = await prisma.period.findMany()
    * ```
    */
  get period(): Prisma.PeriodDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.reportComment`: Exposes CRUD operations for the **ReportComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportComments
    * const reportComments = await prisma.reportComment.findMany()
    * ```
    */
  get reportComment(): Prisma.ReportCommentDelegate<GlobalReject>;

  /**
   * `prisma.reportPost`: Exposes CRUD operations for the **ReportPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportPosts
    * const reportPosts = await prisma.reportPost.findMany()
    * ```
    */
  get reportPost(): Prisma.ReportPostDelegate<GlobalReject>;

  /**
   * `prisma.reportSubcomment`: Exposes CRUD operations for the **ReportSubcomment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportSubcomments
    * const reportSubcomments = await prisma.reportSubcomment.findMany()
    * ```
    */
  get reportSubcomment(): Prisma.ReportSubcommentDelegate<GlobalReject>;

  /**
   * `prisma.telegram`: Exposes CRUD operations for the **Telegram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Telegrams
    * const telegrams = await prisma.telegram.findMany()
    * ```
    */
  get telegram(): Prisma.TelegramDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.20.1
   * Query Engine version: 60ba6551f29b17d7d6ce479e5733c70d9c00860e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Admin: 'Admin',
    CafeteriaMenu: 'CafeteriaMenu',
    ChangePassword: 'ChangePassword',
    CommunityBoard: 'CommunityBoard',
    CommunityBoardCandidate: 'CommunityBoardCandidate',
    CommunityBoardCandidateVote: 'CommunityBoardCandidateVote',
    CommunityBoardPin: 'CommunityBoardPin',
    CommunityComment: 'CommunityComment',
    CommunityPost: 'CommunityPost',
    CommunityPostBookmark: 'CommunityPostBookmark',
    CommunityPostLike: 'CommunityPostLike',
    CommunitySubcomment: 'CommunitySubcomment',
    CoverageMajor: 'CoverageMajor',
    CoverageMajorLecture: 'CoverageMajorLecture',
    Lecture: 'Lecture',
    LiveChat: 'LiveChat',
    NoticeNotificationsSubscription: 'NoticeNotificationsSubscription',
    PendingUser: 'PendingUser',
    Period: 'Period',
    User: 'User',
    ReportComment: 'ReportComment',
    ReportPost: 'ReportPost',
    ReportSubcomment: 'ReportSubcomment',
    Telegram: 'Telegram'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Admin
   */


  export type AggregateAdmin = {
    count: AdminCountAggregateOutputType | null
    avg: AdminAvgAggregateOutputType | null
    sum: AdminSumAggregateOutputType | null
    min: AdminMinAggregateOutputType | null
    max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    userId: number
  }

  export type AdminSumAggregateOutputType = {
    userId: number
  }

  export type AdminMinAggregateOutputType = {
    userId: number
  }

  export type AdminMaxAggregateOutputType = {
    userId: number
  }

  export type AdminCountAggregateOutputType = {
    userId: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    userId?: true
  }

  export type AdminSumAggregateInputType = {
    userId?: true
  }

  export type AdminMinAggregateInputType = {
    userId?: true
  }

  export type AdminMaxAggregateInputType = {
    userId?: true
  }

  export type AdminCountAggregateInputType = {
    userId?: true
    _all?: true
  }

  export type AdminAggregateArgs = {
    /**
     * Filter which Admin to aggregate.
    **/
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
    [P in keyof T & keyof AggregateAdmin]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }


    
    
  export type AdminGroupByArgs = {
    where?: AdminWhereInput
    orderBy?: Enumerable<AdminOrderByInput>
    by: Array<AdminScalarFieldEnum>
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: AdminCountAggregateInputType | true
    avg?: AdminAvgAggregateInputType
    sum?: AdminSumAggregateInputType
    min?: AdminMinAggregateInputType
    max?: AdminMaxAggregateInputType
  }


  export type AdminGroupByOutputType = {
    userId: number
    count: AdminCountAggregateOutputType | null
    avg: AdminAvgAggregateOutputType | null
    sum: AdminSumAggregateOutputType | null
    min: AdminMinAggregateOutputType | null
    max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Promise<Array<
    PickArray<AdminGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof AdminGroupByOutputType))]: GetScalarType<T[P], AdminGroupByOutputType[P]>
    }
  >>
    

  export type AdminSelect = {
    userId?: boolean
    user?: boolean | UserArgs
  }

  export type AdminInclude = {
    user?: boolean | UserArgs
  }

  export type AdminGetPayload<
    S extends boolean | null | undefined | AdminArgs,
    U = keyof S
      > = S extends true
        ? Admin
    : S extends undefined
    ? never
    : S extends AdminArgs | AdminFindManyArgs
    ?'include' extends U
    ? Admin  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Admin ?Admin [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Admin
  : Admin


  type AdminCountArgs = Merge<
    Omit<AdminFindManyArgs, 'select' | 'include'> & {
      select?: AdminCountAggregateInputType | true
    }
  >

  export interface AdminDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdminFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Admin'> extends True ? CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>> : CheckSelect<T, Prisma__AdminClient<Admin | null >, Prisma__AdminClient<AdminGetPayload<T> | null >>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdminFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Admin'> extends True ? CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>> : CheckSelect<T, Prisma__AdminClient<Admin | null >, Prisma__AdminClient<AdminGetPayload<T> | null >>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const adminWithUserIdOnly = await prisma.admin.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs>(
      args?: SelectSubset<T, AdminFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Admin>>, PrismaPromise<Array<AdminGetPayload<T>>>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs>(
      args: SelectSubset<T, AdminCreateArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs>(
      args?: SelectSubset<T, AdminCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs>(
      args: SelectSubset<T, AdminDeleteArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs>(
      args: SelectSubset<T, AdminUpdateArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs>(
      args?: SelectSubset<T, AdminDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs>(
      args: SelectSubset<T, AdminUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs>(
      args: SelectSubset<T, AdminUpsertArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Throw an Error if a Admin can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Admin to fetch.
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Throw an Error if a Admin can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Admin to fetch.
    **/
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
    **/
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Filter, which Admins to fetch.
    **/
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
    **/
    skip?: number
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * The data needed to create a Admin.
    **/
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs = {
    data: Enumerable<AdminCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * The data needed to update a Admin.
    **/
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs = {
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * The filter to search for the Admin to update in case it exists.
    **/
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
    **/
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Filter which Admin to delete.
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs = {
    where?: AdminWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
  }



  /**
   * Model CafeteriaMenu
   */


  export type AggregateCafeteriaMenu = {
    count: CafeteriaMenuCountAggregateOutputType | null
    min: CafeteriaMenuMinAggregateOutputType | null
    max: CafeteriaMenuMaxAggregateOutputType | null
  }

  export type CafeteriaMenuMinAggregateOutputType = {
    campus: string | null
    servedAt: Date | null
  }

  export type CafeteriaMenuMaxAggregateOutputType = {
    campus: string | null
    servedAt: Date | null
  }

  export type CafeteriaMenuCountAggregateOutputType = {
    campus: number | null
    servedAt: number | null
    data: number | null
    _all: number
  }


  export type CafeteriaMenuMinAggregateInputType = {
    campus?: true
    servedAt?: true
  }

  export type CafeteriaMenuMaxAggregateInputType = {
    campus?: true
    servedAt?: true
  }

  export type CafeteriaMenuCountAggregateInputType = {
    campus?: true
    servedAt?: true
    data?: true
    _all?: true
  }

  export type CafeteriaMenuAggregateArgs = {
    /**
     * Filter which CafeteriaMenu to aggregate.
    **/
    where?: CafeteriaMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeteriaMenus to fetch.
    **/
    orderBy?: Enumerable<CafeteriaMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CafeteriaMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeteriaMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeteriaMenus.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeteriaMenus
    **/
    count?: true | CafeteriaMenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CafeteriaMenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CafeteriaMenuMaxAggregateInputType
  }

  export type GetCafeteriaMenuAggregateType<T extends CafeteriaMenuAggregateArgs> = {
    [P in keyof T & keyof AggregateCafeteriaMenu]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeteriaMenu[P]>
      : GetScalarType<T[P], AggregateCafeteriaMenu[P]>
  }


    
    
  export type CafeteriaMenuGroupByArgs = {
    where?: CafeteriaMenuWhereInput
    orderBy?: Enumerable<CafeteriaMenuOrderByInput>
    by: Array<CafeteriaMenuScalarFieldEnum>
    having?: CafeteriaMenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CafeteriaMenuCountAggregateInputType | true
    min?: CafeteriaMenuMinAggregateInputType
    max?: CafeteriaMenuMaxAggregateInputType
  }


  export type CafeteriaMenuGroupByOutputType = {
    campus: string
    servedAt: Date
    data: JsonValue | null
    count: CafeteriaMenuCountAggregateOutputType | null
    min: CafeteriaMenuMinAggregateOutputType | null
    max: CafeteriaMenuMaxAggregateOutputType | null
  }

  type GetCafeteriaMenuGroupByPayload<T extends CafeteriaMenuGroupByArgs> = Promise<Array<
    PickArray<CafeteriaMenuGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CafeteriaMenuGroupByOutputType))]: GetScalarType<T[P], CafeteriaMenuGroupByOutputType[P]>
    }
  >>
    

  export type CafeteriaMenuSelect = {
    campus?: boolean
    servedAt?: boolean
    data?: boolean
  }

  export type CafeteriaMenuGetPayload<
    S extends boolean | null | undefined | CafeteriaMenuArgs,
    U = keyof S
      > = S extends true
        ? CafeteriaMenu
    : S extends undefined
    ? never
    : S extends CafeteriaMenuArgs | CafeteriaMenuFindManyArgs
    ?'include' extends U
    ? CafeteriaMenu 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CafeteriaMenu ?CafeteriaMenu [P]
  : 
     never
  } 
    : CafeteriaMenu
  : CafeteriaMenu


  type CafeteriaMenuCountArgs = Merge<
    Omit<CafeteriaMenuFindManyArgs, 'select' | 'include'> & {
      select?: CafeteriaMenuCountAggregateInputType | true
    }
  >

  export interface CafeteriaMenuDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CafeteriaMenu that matches the filter.
     * @param {CafeteriaMenuFindUniqueArgs} args - Arguments to find a CafeteriaMenu
     * @example
     * // Get one CafeteriaMenu
     * const cafeteriaMenu = await prisma.cafeteriaMenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeteriaMenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeteriaMenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeteriaMenu'> extends True ? CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>> : CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu | null >, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T> | null >>

    /**
     * Find the first CafeteriaMenu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeteriaMenuFindFirstArgs} args - Arguments to find a CafeteriaMenu
     * @example
     * // Get one CafeteriaMenu
     * const cafeteriaMenu = await prisma.cafeteriaMenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeteriaMenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeteriaMenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeteriaMenu'> extends True ? CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>> : CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu | null >, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T> | null >>

    /**
     * Find zero or more CafeteriaMenus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeteriaMenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeteriaMenus
     * const cafeteriaMenus = await prisma.cafeteriaMenu.findMany()
     * 
     * // Get first 10 CafeteriaMenus
     * const cafeteriaMenus = await prisma.cafeteriaMenu.findMany({ take: 10 })
     * 
     * // Only select the `campus`
     * const cafeteriaMenuWithCampusOnly = await prisma.cafeteriaMenu.findMany({ select: { campus: true } })
     * 
    **/
    findMany<T extends CafeteriaMenuFindManyArgs>(
      args?: SelectSubset<T, CafeteriaMenuFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CafeteriaMenu>>, PrismaPromise<Array<CafeteriaMenuGetPayload<T>>>>

    /**
     * Create a CafeteriaMenu.
     * @param {CafeteriaMenuCreateArgs} args - Arguments to create a CafeteriaMenu.
     * @example
     * // Create one CafeteriaMenu
     * const CafeteriaMenu = await prisma.cafeteriaMenu.create({
     *   data: {
     *     // ... data to create a CafeteriaMenu
     *   }
     * })
     * 
    **/
    create<T extends CafeteriaMenuCreateArgs>(
      args: SelectSubset<T, CafeteriaMenuCreateArgs>
    ): CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>>

    /**
     * Create many CafeteriaMenus.
     *     @param {CafeteriaMenuCreateManyArgs} args - Arguments to create many CafeteriaMenus.
     *     @example
     *     // Create many CafeteriaMenus
     *     const cafeteriaMenu = await prisma.cafeteriaMenu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeteriaMenuCreateManyArgs>(
      args?: SelectSubset<T, CafeteriaMenuCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeteriaMenu.
     * @param {CafeteriaMenuDeleteArgs} args - Arguments to delete one CafeteriaMenu.
     * @example
     * // Delete one CafeteriaMenu
     * const CafeteriaMenu = await prisma.cafeteriaMenu.delete({
     *   where: {
     *     // ... filter to delete one CafeteriaMenu
     *   }
     * })
     * 
    **/
    delete<T extends CafeteriaMenuDeleteArgs>(
      args: SelectSubset<T, CafeteriaMenuDeleteArgs>
    ): CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>>

    /**
     * Update one CafeteriaMenu.
     * @param {CafeteriaMenuUpdateArgs} args - Arguments to update one CafeteriaMenu.
     * @example
     * // Update one CafeteriaMenu
     * const cafeteriaMenu = await prisma.cafeteriaMenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeteriaMenuUpdateArgs>(
      args: SelectSubset<T, CafeteriaMenuUpdateArgs>
    ): CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>>

    /**
     * Delete zero or more CafeteriaMenus.
     * @param {CafeteriaMenuDeleteManyArgs} args - Arguments to filter CafeteriaMenus to delete.
     * @example
     * // Delete a few CafeteriaMenus
     * const { count } = await prisma.cafeteriaMenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeteriaMenuDeleteManyArgs>(
      args?: SelectSubset<T, CafeteriaMenuDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeteriaMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeteriaMenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeteriaMenus
     * const cafeteriaMenu = await prisma.cafeteriaMenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeteriaMenuUpdateManyArgs>(
      args: SelectSubset<T, CafeteriaMenuUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeteriaMenu.
     * @param {CafeteriaMenuUpsertArgs} args - Arguments to update or create a CafeteriaMenu.
     * @example
     * // Update or create a CafeteriaMenu
     * const cafeteriaMenu = await prisma.cafeteriaMenu.upsert({
     *   create: {
     *     // ... data to create a CafeteriaMenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeteriaMenu we want to update
     *   }
     * })
    **/
    upsert<T extends CafeteriaMenuUpsertArgs>(
      args: SelectSubset<T, CafeteriaMenuUpsertArgs>
    ): CheckSelect<T, Prisma__CafeteriaMenuClient<CafeteriaMenu>, Prisma__CafeteriaMenuClient<CafeteriaMenuGetPayload<T>>>

    /**
     * Count the number of CafeteriaMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeteriaMenuCountArgs} args - Arguments to filter CafeteriaMenus to count.
     * @example
     * // Count the number of CafeteriaMenus
     * const count = await prisma.cafeteriaMenu.count({
     *   where: {
     *     // ... the filter for the CafeteriaMenus we want to count
     *   }
     * })
    **/
    count<T extends CafeteriaMenuCountArgs>(
      args?: Subset<T, CafeteriaMenuCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeteriaMenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeteriaMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeteriaMenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeteriaMenuAggregateArgs>(args: Subset<T, CafeteriaMenuAggregateArgs>): PrismaPromise<GetCafeteriaMenuAggregateType<T>>

    /**
     * Group by CafeteriaMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeteriaMenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeteriaMenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeteriaMenuGroupByArgs['orderBy'] }
        : { orderBy?: CafeteriaMenuGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeteriaMenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeteriaMenuGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeteriaMenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeteriaMenuClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CafeteriaMenu findUnique
   */
  export type CafeteriaMenuFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * Throw an Error if a CafeteriaMenu can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CafeteriaMenu to fetch.
    **/
    where: CafeteriaMenuWhereUniqueInput
  }


  /**
   * CafeteriaMenu findFirst
   */
  export type CafeteriaMenuFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * Throw an Error if a CafeteriaMenu can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CafeteriaMenu to fetch.
    **/
    where?: CafeteriaMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeteriaMenus to fetch.
    **/
    orderBy?: Enumerable<CafeteriaMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeteriaMenus.
    **/
    cursor?: CafeteriaMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeteriaMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeteriaMenus.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeteriaMenus.
    **/
    distinct?: Enumerable<CafeteriaMenuScalarFieldEnum>
  }


  /**
   * CafeteriaMenu findMany
   */
  export type CafeteriaMenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * Filter, which CafeteriaMenus to fetch.
    **/
    where?: CafeteriaMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeteriaMenus to fetch.
    **/
    orderBy?: Enumerable<CafeteriaMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeteriaMenus.
    **/
    cursor?: CafeteriaMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeteriaMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeteriaMenus.
    **/
    skip?: number
    distinct?: Enumerable<CafeteriaMenuScalarFieldEnum>
  }


  /**
   * CafeteriaMenu create
   */
  export type CafeteriaMenuCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * The data needed to create a CafeteriaMenu.
    **/
    data: XOR<CafeteriaMenuCreateInput, CafeteriaMenuUncheckedCreateInput>
  }


  /**
   * CafeteriaMenu createMany
   */
  export type CafeteriaMenuCreateManyArgs = {
    data: Enumerable<CafeteriaMenuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeteriaMenu update
   */
  export type CafeteriaMenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * The data needed to update a CafeteriaMenu.
    **/
    data: XOR<CafeteriaMenuUpdateInput, CafeteriaMenuUncheckedUpdateInput>
    /**
     * Choose, which CafeteriaMenu to update.
    **/
    where: CafeteriaMenuWhereUniqueInput
  }


  /**
   * CafeteriaMenu updateMany
   */
  export type CafeteriaMenuUpdateManyArgs = {
    data: XOR<CafeteriaMenuUpdateManyMutationInput, CafeteriaMenuUncheckedUpdateManyInput>
    where?: CafeteriaMenuWhereInput
  }


  /**
   * CafeteriaMenu upsert
   */
  export type CafeteriaMenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * The filter to search for the CafeteriaMenu to update in case it exists.
    **/
    where: CafeteriaMenuWhereUniqueInput
    /**
     * In case the CafeteriaMenu found by the `where` argument doesn't exist, create a new CafeteriaMenu with this data.
    **/
    create: XOR<CafeteriaMenuCreateInput, CafeteriaMenuUncheckedCreateInput>
    /**
     * In case the CafeteriaMenu was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CafeteriaMenuUpdateInput, CafeteriaMenuUncheckedUpdateInput>
  }


  /**
   * CafeteriaMenu delete
   */
  export type CafeteriaMenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
    /**
     * Filter which CafeteriaMenu to delete.
    **/
    where: CafeteriaMenuWhereUniqueInput
  }


  /**
   * CafeteriaMenu deleteMany
   */
  export type CafeteriaMenuDeleteManyArgs = {
    where?: CafeteriaMenuWhereInput
  }


  /**
   * CafeteriaMenu without action
   */
  export type CafeteriaMenuArgs = {
    /**
     * Select specific fields to fetch from the CafeteriaMenu
    **/
    select?: CafeteriaMenuSelect | null
  }



  /**
   * Model ChangePassword
   */


  export type AggregateChangePassword = {
    count: ChangePasswordCountAggregateOutputType | null
    avg: ChangePasswordAvgAggregateOutputType | null
    sum: ChangePasswordSumAggregateOutputType | null
    min: ChangePasswordMinAggregateOutputType | null
    max: ChangePasswordMaxAggregateOutputType | null
  }

  export type ChangePasswordAvgAggregateOutputType = {
    userId: number
  }

  export type ChangePasswordSumAggregateOutputType = {
    userId: number
  }

  export type ChangePasswordMinAggregateOutputType = {
    userId: number
    token: string | null
    requestedAt: Date | null
  }

  export type ChangePasswordMaxAggregateOutputType = {
    userId: number
    token: string | null
    requestedAt: Date | null
  }

  export type ChangePasswordCountAggregateOutputType = {
    userId: number
    token: number | null
    requestedAt: number | null
    _all: number
  }


  export type ChangePasswordAvgAggregateInputType = {
    userId?: true
  }

  export type ChangePasswordSumAggregateInputType = {
    userId?: true
  }

  export type ChangePasswordMinAggregateInputType = {
    userId?: true
    token?: true
    requestedAt?: true
  }

  export type ChangePasswordMaxAggregateInputType = {
    userId?: true
    token?: true
    requestedAt?: true
  }

  export type ChangePasswordCountAggregateInputType = {
    userId?: true
    token?: true
    requestedAt?: true
    _all?: true
  }

  export type ChangePasswordAggregateArgs = {
    /**
     * Filter which ChangePassword to aggregate.
    **/
    where?: ChangePasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangePasswords to fetch.
    **/
    orderBy?: Enumerable<ChangePasswordOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ChangePasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangePasswords from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangePasswords.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangePasswords
    **/
    count?: true | ChangePasswordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ChangePasswordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ChangePasswordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ChangePasswordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ChangePasswordMaxAggregateInputType
  }

  export type GetChangePasswordAggregateType<T extends ChangePasswordAggregateArgs> = {
    [P in keyof T & keyof AggregateChangePassword]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangePassword[P]>
      : GetScalarType<T[P], AggregateChangePassword[P]>
  }


    
    
  export type ChangePasswordGroupByArgs = {
    where?: ChangePasswordWhereInput
    orderBy?: Enumerable<ChangePasswordOrderByInput>
    by: Array<ChangePasswordScalarFieldEnum>
    having?: ChangePasswordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: ChangePasswordCountAggregateInputType | true
    avg?: ChangePasswordAvgAggregateInputType
    sum?: ChangePasswordSumAggregateInputType
    min?: ChangePasswordMinAggregateInputType
    max?: ChangePasswordMaxAggregateInputType
  }


  export type ChangePasswordGroupByOutputType = {
    userId: number
    token: string
    requestedAt: Date
    count: ChangePasswordCountAggregateOutputType | null
    avg: ChangePasswordAvgAggregateOutputType | null
    sum: ChangePasswordSumAggregateOutputType | null
    min: ChangePasswordMinAggregateOutputType | null
    max: ChangePasswordMaxAggregateOutputType | null
  }

  type GetChangePasswordGroupByPayload<T extends ChangePasswordGroupByArgs> = Promise<Array<
    PickArray<ChangePasswordGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof ChangePasswordGroupByOutputType))]: GetScalarType<T[P], ChangePasswordGroupByOutputType[P]>
    }
  >>
    

  export type ChangePasswordSelect = {
    userId?: boolean
    token?: boolean
    requestedAt?: boolean
    user?: boolean | UserArgs
  }

  export type ChangePasswordInclude = {
    user?: boolean | UserArgs
  }

  export type ChangePasswordGetPayload<
    S extends boolean | null | undefined | ChangePasswordArgs,
    U = keyof S
      > = S extends true
        ? ChangePassword
    : S extends undefined
    ? never
    : S extends ChangePasswordArgs | ChangePasswordFindManyArgs
    ?'include' extends U
    ? ChangePassword  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ChangePassword ?ChangePassword [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ChangePassword
  : ChangePassword


  type ChangePasswordCountArgs = Merge<
    Omit<ChangePasswordFindManyArgs, 'select' | 'include'> & {
      select?: ChangePasswordCountAggregateInputType | true
    }
  >

  export interface ChangePasswordDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ChangePassword that matches the filter.
     * @param {ChangePasswordFindUniqueArgs} args - Arguments to find a ChangePassword
     * @example
     * // Get one ChangePassword
     * const changePassword = await prisma.changePassword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChangePasswordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChangePasswordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChangePassword'> extends True ? CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>> : CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword | null >, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T> | null >>

    /**
     * Find the first ChangePassword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangePasswordFindFirstArgs} args - Arguments to find a ChangePassword
     * @example
     * // Get one ChangePassword
     * const changePassword = await prisma.changePassword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChangePasswordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChangePasswordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChangePassword'> extends True ? CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>> : CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword | null >, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T> | null >>

    /**
     * Find zero or more ChangePasswords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangePasswordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangePasswords
     * const changePasswords = await prisma.changePassword.findMany()
     * 
     * // Get first 10 ChangePasswords
     * const changePasswords = await prisma.changePassword.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const changePasswordWithUserIdOnly = await prisma.changePassword.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends ChangePasswordFindManyArgs>(
      args?: SelectSubset<T, ChangePasswordFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ChangePassword>>, PrismaPromise<Array<ChangePasswordGetPayload<T>>>>

    /**
     * Create a ChangePassword.
     * @param {ChangePasswordCreateArgs} args - Arguments to create a ChangePassword.
     * @example
     * // Create one ChangePassword
     * const ChangePassword = await prisma.changePassword.create({
     *   data: {
     *     // ... data to create a ChangePassword
     *   }
     * })
     * 
    **/
    create<T extends ChangePasswordCreateArgs>(
      args: SelectSubset<T, ChangePasswordCreateArgs>
    ): CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>>

    /**
     * Create many ChangePasswords.
     *     @param {ChangePasswordCreateManyArgs} args - Arguments to create many ChangePasswords.
     *     @example
     *     // Create many ChangePasswords
     *     const changePassword = await prisma.changePassword.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChangePasswordCreateManyArgs>(
      args?: SelectSubset<T, ChangePasswordCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ChangePassword.
     * @param {ChangePasswordDeleteArgs} args - Arguments to delete one ChangePassword.
     * @example
     * // Delete one ChangePassword
     * const ChangePassword = await prisma.changePassword.delete({
     *   where: {
     *     // ... filter to delete one ChangePassword
     *   }
     * })
     * 
    **/
    delete<T extends ChangePasswordDeleteArgs>(
      args: SelectSubset<T, ChangePasswordDeleteArgs>
    ): CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>>

    /**
     * Update one ChangePassword.
     * @param {ChangePasswordUpdateArgs} args - Arguments to update one ChangePassword.
     * @example
     * // Update one ChangePassword
     * const changePassword = await prisma.changePassword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChangePasswordUpdateArgs>(
      args: SelectSubset<T, ChangePasswordUpdateArgs>
    ): CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>>

    /**
     * Delete zero or more ChangePasswords.
     * @param {ChangePasswordDeleteManyArgs} args - Arguments to filter ChangePasswords to delete.
     * @example
     * // Delete a few ChangePasswords
     * const { count } = await prisma.changePassword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChangePasswordDeleteManyArgs>(
      args?: SelectSubset<T, ChangePasswordDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangePasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangePasswordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangePasswords
     * const changePassword = await prisma.changePassword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChangePasswordUpdateManyArgs>(
      args: SelectSubset<T, ChangePasswordUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ChangePassword.
     * @param {ChangePasswordUpsertArgs} args - Arguments to update or create a ChangePassword.
     * @example
     * // Update or create a ChangePassword
     * const changePassword = await prisma.changePassword.upsert({
     *   create: {
     *     // ... data to create a ChangePassword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangePassword we want to update
     *   }
     * })
    **/
    upsert<T extends ChangePasswordUpsertArgs>(
      args: SelectSubset<T, ChangePasswordUpsertArgs>
    ): CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword>, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T>>>

    /**
     * Count the number of ChangePasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangePasswordCountArgs} args - Arguments to filter ChangePasswords to count.
     * @example
     * // Count the number of ChangePasswords
     * const count = await prisma.changePassword.count({
     *   where: {
     *     // ... the filter for the ChangePasswords we want to count
     *   }
     * })
    **/
    count<T extends ChangePasswordCountArgs>(
      args?: Subset<T, ChangePasswordCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangePasswordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangePassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangePasswordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangePasswordAggregateArgs>(args: Subset<T, ChangePasswordAggregateArgs>): PrismaPromise<GetChangePasswordAggregateType<T>>

    /**
     * Group by ChangePassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangePasswordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangePasswordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangePasswordGroupByArgs['orderBy'] }
        : { orderBy?: ChangePasswordGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangePasswordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangePasswordGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangePassword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChangePasswordClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ChangePassword findUnique
   */
  export type ChangePasswordFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * Throw an Error if a ChangePassword can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ChangePassword to fetch.
    **/
    where: ChangePasswordWhereUniqueInput
  }


  /**
   * ChangePassword findFirst
   */
  export type ChangePasswordFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * Throw an Error if a ChangePassword can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ChangePassword to fetch.
    **/
    where?: ChangePasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangePasswords to fetch.
    **/
    orderBy?: Enumerable<ChangePasswordOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangePasswords.
    **/
    cursor?: ChangePasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangePasswords from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangePasswords.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangePasswords.
    **/
    distinct?: Enumerable<ChangePasswordScalarFieldEnum>
  }


  /**
   * ChangePassword findMany
   */
  export type ChangePasswordFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * Filter, which ChangePasswords to fetch.
    **/
    where?: ChangePasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangePasswords to fetch.
    **/
    orderBy?: Enumerable<ChangePasswordOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangePasswords.
    **/
    cursor?: ChangePasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangePasswords from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangePasswords.
    **/
    skip?: number
    distinct?: Enumerable<ChangePasswordScalarFieldEnum>
  }


  /**
   * ChangePassword create
   */
  export type ChangePasswordCreateArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * The data needed to create a ChangePassword.
    **/
    data: XOR<ChangePasswordCreateInput, ChangePasswordUncheckedCreateInput>
  }


  /**
   * ChangePassword createMany
   */
  export type ChangePasswordCreateManyArgs = {
    data: Enumerable<ChangePasswordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChangePassword update
   */
  export type ChangePasswordUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * The data needed to update a ChangePassword.
    **/
    data: XOR<ChangePasswordUpdateInput, ChangePasswordUncheckedUpdateInput>
    /**
     * Choose, which ChangePassword to update.
    **/
    where: ChangePasswordWhereUniqueInput
  }


  /**
   * ChangePassword updateMany
   */
  export type ChangePasswordUpdateManyArgs = {
    data: XOR<ChangePasswordUpdateManyMutationInput, ChangePasswordUncheckedUpdateManyInput>
    where?: ChangePasswordWhereInput
  }


  /**
   * ChangePassword upsert
   */
  export type ChangePasswordUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * The filter to search for the ChangePassword to update in case it exists.
    **/
    where: ChangePasswordWhereUniqueInput
    /**
     * In case the ChangePassword found by the `where` argument doesn't exist, create a new ChangePassword with this data.
    **/
    create: XOR<ChangePasswordCreateInput, ChangePasswordUncheckedCreateInput>
    /**
     * In case the ChangePassword was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ChangePasswordUpdateInput, ChangePasswordUncheckedUpdateInput>
  }


  /**
   * ChangePassword delete
   */
  export type ChangePasswordDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
    /**
     * Filter which ChangePassword to delete.
    **/
    where: ChangePasswordWhereUniqueInput
  }


  /**
   * ChangePassword deleteMany
   */
  export type ChangePasswordDeleteManyArgs = {
    where?: ChangePasswordWhereInput
  }


  /**
   * ChangePassword without action
   */
  export type ChangePasswordArgs = {
    /**
     * Select specific fields to fetch from the ChangePassword
    **/
    select?: ChangePasswordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ChangePasswordInclude | null
  }



  /**
   * Model CommunityBoard
   */


  export type AggregateCommunityBoard = {
    count: CommunityBoardCountAggregateOutputType | null
    avg: CommunityBoardAvgAggregateOutputType | null
    sum: CommunityBoardSumAggregateOutputType | null
    min: CommunityBoardMinAggregateOutputType | null
    max: CommunityBoardMaxAggregateOutputType | null
  }

  export type CommunityBoardAvgAggregateOutputType = {
    id: number
    priority: number
    createdBy: number
  }

  export type CommunityBoardSumAggregateOutputType = {
    id: number
    priority: number
    createdBy: number
  }

  export type CommunityBoardMinAggregateOutputType = {
    id: number
    name: string | null
    description: string | null
    priority: number
    isDeleted: boolean | null
    createdBy: number
    createdAt: Date | null
    activeAt: Date | null
  }

  export type CommunityBoardMaxAggregateOutputType = {
    id: number
    name: string | null
    description: string | null
    priority: number
    isDeleted: boolean | null
    createdBy: number
    createdAt: Date | null
    activeAt: Date | null
  }

  export type CommunityBoardCountAggregateOutputType = {
    id: number
    name: number | null
    description: number | null
    priority: number
    isDeleted: number | null
    createdBy: number
    createdAt: number | null
    activeAt: number | null
    _all: number
  }


  export type CommunityBoardAvgAggregateInputType = {
    id?: true
    priority?: true
    createdBy?: true
  }

  export type CommunityBoardSumAggregateInputType = {
    id?: true
    priority?: true
    createdBy?: true
  }

  export type CommunityBoardMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priority?: true
    isDeleted?: true
    createdBy?: true
    createdAt?: true
    activeAt?: true
  }

  export type CommunityBoardMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priority?: true
    isDeleted?: true
    createdBy?: true
    createdAt?: true
    activeAt?: true
  }

  export type CommunityBoardCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priority?: true
    isDeleted?: true
    createdBy?: true
    createdAt?: true
    activeAt?: true
    _all?: true
  }

  export type CommunityBoardAggregateArgs = {
    /**
     * Filter which CommunityBoard to aggregate.
    **/
    where?: CommunityBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoards to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoards.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityBoards
    **/
    count?: true | CommunityBoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityBoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityBoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityBoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityBoardMaxAggregateInputType
  }

  export type GetCommunityBoardAggregateType<T extends CommunityBoardAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityBoard]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityBoard[P]>
      : GetScalarType<T[P], AggregateCommunityBoard[P]>
  }


    
    
  export type CommunityBoardGroupByArgs = {
    where?: CommunityBoardWhereInput
    orderBy?: Enumerable<CommunityBoardOrderByInput>
    by: Array<CommunityBoardScalarFieldEnum>
    having?: CommunityBoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommunityBoardCountAggregateInputType | true
    avg?: CommunityBoardAvgAggregateInputType
    sum?: CommunityBoardSumAggregateInputType
    min?: CommunityBoardMinAggregateInputType
    max?: CommunityBoardMaxAggregateInputType
  }


  export type CommunityBoardGroupByOutputType = {
    id: number
    name: string
    description: string | null
    priority: number
    isDeleted: boolean
    createdBy: number
    createdAt: Date
    activeAt: Date | null
    count: CommunityBoardCountAggregateOutputType | null
    avg: CommunityBoardAvgAggregateOutputType | null
    sum: CommunityBoardSumAggregateOutputType | null
    min: CommunityBoardMinAggregateOutputType | null
    max: CommunityBoardMaxAggregateOutputType | null
  }

  type GetCommunityBoardGroupByPayload<T extends CommunityBoardGroupByArgs> = Promise<Array<
    PickArray<CommunityBoardGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommunityBoardGroupByOutputType))]: GetScalarType<T[P], CommunityBoardGroupByOutputType[P]>
    }
  >>
    

  export type CommunityBoardSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    priority?: boolean
    isDeleted?: boolean
    createdBy?: boolean
    createdAt?: boolean
    activeAt?: boolean
    user?: boolean | UserArgs
    communityBoardPins?: boolean | CommunityBoardPinFindManyArgs
    communityPosts?: boolean | CommunityPostFindManyArgs
  }

  export type CommunityBoardInclude = {
    user?: boolean | UserArgs
    communityBoardPins?: boolean | CommunityBoardPinFindManyArgs
    communityPosts?: boolean | CommunityPostFindManyArgs
  }

  export type CommunityBoardGetPayload<
    S extends boolean | null | undefined | CommunityBoardArgs,
    U = keyof S
      > = S extends true
        ? CommunityBoard
    : S extends undefined
    ? never
    : S extends CommunityBoardArgs | CommunityBoardFindManyArgs
    ?'include' extends U
    ? CommunityBoard  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'communityBoardPins'
        ? Array < CommunityBoardPinGetPayload<S['include'][P]>>  :
        P extends 'communityPosts'
        ? Array < CommunityPostGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityBoard ?CommunityBoard [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'communityBoardPins'
        ? Array < CommunityBoardPinGetPayload<S['select'][P]>>  :
        P extends 'communityPosts'
        ? Array < CommunityPostGetPayload<S['select'][P]>>  : never
  } 
    : CommunityBoard
  : CommunityBoard


  type CommunityBoardCountArgs = Merge<
    Omit<CommunityBoardFindManyArgs, 'select' | 'include'> & {
      select?: CommunityBoardCountAggregateInputType | true
    }
  >

  export interface CommunityBoardDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityBoard that matches the filter.
     * @param {CommunityBoardFindUniqueArgs} args - Arguments to find a CommunityBoard
     * @example
     * // Get one CommunityBoard
     * const communityBoard = await prisma.communityBoard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityBoardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityBoardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityBoard'> extends True ? CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard | null >, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T> | null >>

    /**
     * Find the first CommunityBoard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardFindFirstArgs} args - Arguments to find a CommunityBoard
     * @example
     * // Get one CommunityBoard
     * const communityBoard = await prisma.communityBoard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityBoardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityBoardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityBoard'> extends True ? CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard | null >, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T> | null >>

    /**
     * Find zero or more CommunityBoards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityBoards
     * const communityBoards = await prisma.communityBoard.findMany()
     * 
     * // Get first 10 CommunityBoards
     * const communityBoards = await prisma.communityBoard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityBoardWithIdOnly = await prisma.communityBoard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityBoardFindManyArgs>(
      args?: SelectSubset<T, CommunityBoardFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommunityBoard>>, PrismaPromise<Array<CommunityBoardGetPayload<T>>>>

    /**
     * Create a CommunityBoard.
     * @param {CommunityBoardCreateArgs} args - Arguments to create a CommunityBoard.
     * @example
     * // Create one CommunityBoard
     * const CommunityBoard = await prisma.communityBoard.create({
     *   data: {
     *     // ... data to create a CommunityBoard
     *   }
     * })
     * 
    **/
    create<T extends CommunityBoardCreateArgs>(
      args: SelectSubset<T, CommunityBoardCreateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>>

    /**
     * Create many CommunityBoards.
     *     @param {CommunityBoardCreateManyArgs} args - Arguments to create many CommunityBoards.
     *     @example
     *     // Create many CommunityBoards
     *     const communityBoard = await prisma.communityBoard.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityBoardCreateManyArgs>(
      args?: SelectSubset<T, CommunityBoardCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityBoard.
     * @param {CommunityBoardDeleteArgs} args - Arguments to delete one CommunityBoard.
     * @example
     * // Delete one CommunityBoard
     * const CommunityBoard = await prisma.communityBoard.delete({
     *   where: {
     *     // ... filter to delete one CommunityBoard
     *   }
     * })
     * 
    **/
    delete<T extends CommunityBoardDeleteArgs>(
      args: SelectSubset<T, CommunityBoardDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>>

    /**
     * Update one CommunityBoard.
     * @param {CommunityBoardUpdateArgs} args - Arguments to update one CommunityBoard.
     * @example
     * // Update one CommunityBoard
     * const communityBoard = await prisma.communityBoard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityBoardUpdateArgs>(
      args: SelectSubset<T, CommunityBoardUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>>

    /**
     * Delete zero or more CommunityBoards.
     * @param {CommunityBoardDeleteManyArgs} args - Arguments to filter CommunityBoards to delete.
     * @example
     * // Delete a few CommunityBoards
     * const { count } = await prisma.communityBoard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityBoardDeleteManyArgs>(
      args?: SelectSubset<T, CommunityBoardDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityBoards
     * const communityBoard = await prisma.communityBoard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityBoardUpdateManyArgs>(
      args: SelectSubset<T, CommunityBoardUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityBoard.
     * @param {CommunityBoardUpsertArgs} args - Arguments to update or create a CommunityBoard.
     * @example
     * // Update or create a CommunityBoard
     * const communityBoard = await prisma.communityBoard.upsert({
     *   create: {
     *     // ... data to create a CommunityBoard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityBoard we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityBoardUpsertArgs>(
      args: SelectSubset<T, CommunityBoardUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard>, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T>>>

    /**
     * Count the number of CommunityBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCountArgs} args - Arguments to filter CommunityBoards to count.
     * @example
     * // Count the number of CommunityBoards
     * const count = await prisma.communityBoard.count({
     *   where: {
     *     // ... the filter for the CommunityBoards we want to count
     *   }
     * })
    **/
    count<T extends CommunityBoardCountArgs>(
      args?: Subset<T, CommunityBoardCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityBoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityBoardAggregateArgs>(args: Subset<T, CommunityBoardAggregateArgs>): PrismaPromise<GetCommunityBoardAggregateType<T>>

    /**
     * Group by CommunityBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityBoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityBoardGroupByArgs['orderBy'] }
        : { orderBy?: CommunityBoardGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityBoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityBoardGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityBoard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityBoardClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    communityBoardPins<T extends CommunityBoardPinFindManyArgs = {}>(args?: Subset<T, CommunityBoardPinFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityBoardPin>>, PrismaPromise<Array<CommunityBoardPinGetPayload<T>>>>;

    communityPosts<T extends CommunityPostFindManyArgs = {}>(args?: Subset<T, CommunityPostFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityPost>>, PrismaPromise<Array<CommunityPostGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityBoard findUnique
   */
  export type CommunityBoardFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * Throw an Error if a CommunityBoard can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoard to fetch.
    **/
    where: CommunityBoardWhereUniqueInput
  }


  /**
   * CommunityBoard findFirst
   */
  export type CommunityBoardFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * Throw an Error if a CommunityBoard can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoard to fetch.
    **/
    where?: CommunityBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoards to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBoards.
    **/
    cursor?: CommunityBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoards.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityBoards.
    **/
    distinct?: Enumerable<CommunityBoardScalarFieldEnum>
  }


  /**
   * CommunityBoard findMany
   */
  export type CommunityBoardFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * Filter, which CommunityBoards to fetch.
    **/
    where?: CommunityBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoards to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityBoards.
    **/
    cursor?: CommunityBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoards.
    **/
    skip?: number
    distinct?: Enumerable<CommunityBoardScalarFieldEnum>
  }


  /**
   * CommunityBoard create
   */
  export type CommunityBoardCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * The data needed to create a CommunityBoard.
    **/
    data: XOR<CommunityBoardCreateInput, CommunityBoardUncheckedCreateInput>
  }


  /**
   * CommunityBoard createMany
   */
  export type CommunityBoardCreateManyArgs = {
    data: Enumerable<CommunityBoardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommunityBoard update
   */
  export type CommunityBoardUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * The data needed to update a CommunityBoard.
    **/
    data: XOR<CommunityBoardUpdateInput, CommunityBoardUncheckedUpdateInput>
    /**
     * Choose, which CommunityBoard to update.
    **/
    where: CommunityBoardWhereUniqueInput
  }


  /**
   * CommunityBoard updateMany
   */
  export type CommunityBoardUpdateManyArgs = {
    data: XOR<CommunityBoardUpdateManyMutationInput, CommunityBoardUncheckedUpdateManyInput>
    where?: CommunityBoardWhereInput
  }


  /**
   * CommunityBoard upsert
   */
  export type CommunityBoardUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * The filter to search for the CommunityBoard to update in case it exists.
    **/
    where: CommunityBoardWhereUniqueInput
    /**
     * In case the CommunityBoard found by the `where` argument doesn't exist, create a new CommunityBoard with this data.
    **/
    create: XOR<CommunityBoardCreateInput, CommunityBoardUncheckedCreateInput>
    /**
     * In case the CommunityBoard was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityBoardUpdateInput, CommunityBoardUncheckedUpdateInput>
  }


  /**
   * CommunityBoard delete
   */
  export type CommunityBoardDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
    /**
     * Filter which CommunityBoard to delete.
    **/
    where: CommunityBoardWhereUniqueInput
  }


  /**
   * CommunityBoard deleteMany
   */
  export type CommunityBoardDeleteManyArgs = {
    where?: CommunityBoardWhereInput
  }


  /**
   * CommunityBoard without action
   */
  export type CommunityBoardArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoard
    **/
    select?: CommunityBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardInclude | null
  }



  /**
   * Model CommunityBoardCandidate
   */


  export type AggregateCommunityBoardCandidate = {
    count: CommunityBoardCandidateCountAggregateOutputType | null
    avg: CommunityBoardCandidateAvgAggregateOutputType | null
    sum: CommunityBoardCandidateSumAggregateOutputType | null
    min: CommunityBoardCandidateMinAggregateOutputType | null
    max: CommunityBoardCandidateMaxAggregateOutputType | null
  }

  export type CommunityBoardCandidateAvgAggregateOutputType = {
    id: number
    createdBy: number
  }

  export type CommunityBoardCandidateSumAggregateOutputType = {
    id: number
    createdBy: number
  }

  export type CommunityBoardCandidateMinAggregateOutputType = {
    id: number
    name: string | null
    description: string | null
    createdBy: number
    createdAt: Date | null
  }

  export type CommunityBoardCandidateMaxAggregateOutputType = {
    id: number
    name: string | null
    description: string | null
    createdBy: number
    createdAt: Date | null
  }

  export type CommunityBoardCandidateCountAggregateOutputType = {
    id: number
    name: number | null
    description: number | null
    createdBy: number
    createdAt: number | null
    _all: number
  }


  export type CommunityBoardCandidateAvgAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type CommunityBoardCandidateSumAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type CommunityBoardCandidateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
  }

  export type CommunityBoardCandidateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
  }

  export type CommunityBoardCandidateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type CommunityBoardCandidateAggregateArgs = {
    /**
     * Filter which CommunityBoardCandidate to aggregate.
    **/
    where?: CommunityBoardCandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoardCandidates to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityBoardCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidates from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidates.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityBoardCandidates
    **/
    count?: true | CommunityBoardCandidateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityBoardCandidateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityBoardCandidateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityBoardCandidateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityBoardCandidateMaxAggregateInputType
  }

  export type GetCommunityBoardCandidateAggregateType<T extends CommunityBoardCandidateAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityBoardCandidate]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityBoardCandidate[P]>
      : GetScalarType<T[P], AggregateCommunityBoardCandidate[P]>
  }


    
    
  export type CommunityBoardCandidateGroupByArgs = {
    where?: CommunityBoardCandidateWhereInput
    orderBy?: Enumerable<CommunityBoardCandidateOrderByInput>
    by: Array<CommunityBoardCandidateScalarFieldEnum>
    having?: CommunityBoardCandidateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommunityBoardCandidateCountAggregateInputType | true
    avg?: CommunityBoardCandidateAvgAggregateInputType
    sum?: CommunityBoardCandidateSumAggregateInputType
    min?: CommunityBoardCandidateMinAggregateInputType
    max?: CommunityBoardCandidateMaxAggregateInputType
  }


  export type CommunityBoardCandidateGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdBy: number
    createdAt: Date
    count: CommunityBoardCandidateCountAggregateOutputType | null
    avg: CommunityBoardCandidateAvgAggregateOutputType | null
    sum: CommunityBoardCandidateSumAggregateOutputType | null
    min: CommunityBoardCandidateMinAggregateOutputType | null
    max: CommunityBoardCandidateMaxAggregateOutputType | null
  }

  type GetCommunityBoardCandidateGroupByPayload<T extends CommunityBoardCandidateGroupByArgs> = Promise<Array<
    PickArray<CommunityBoardCandidateGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommunityBoardCandidateGroupByOutputType))]: GetScalarType<T[P], CommunityBoardCandidateGroupByOutputType[P]>
    }
  >>
    

  export type CommunityBoardCandidateSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs
    communityBoardCandidateVotes?: boolean | CommunityBoardCandidateVoteFindManyArgs
  }

  export type CommunityBoardCandidateInclude = {
    user?: boolean | UserArgs
    communityBoardCandidateVotes?: boolean | CommunityBoardCandidateVoteFindManyArgs
  }

  export type CommunityBoardCandidateGetPayload<
    S extends boolean | null | undefined | CommunityBoardCandidateArgs,
    U = keyof S
      > = S extends true
        ? CommunityBoardCandidate
    : S extends undefined
    ? never
    : S extends CommunityBoardCandidateArgs | CommunityBoardCandidateFindManyArgs
    ?'include' extends U
    ? CommunityBoardCandidate  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'communityBoardCandidateVotes'
        ? Array < CommunityBoardCandidateVoteGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityBoardCandidate ?CommunityBoardCandidate [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'communityBoardCandidateVotes'
        ? Array < CommunityBoardCandidateVoteGetPayload<S['select'][P]>>  : never
  } 
    : CommunityBoardCandidate
  : CommunityBoardCandidate


  type CommunityBoardCandidateCountArgs = Merge<
    Omit<CommunityBoardCandidateFindManyArgs, 'select' | 'include'> & {
      select?: CommunityBoardCandidateCountAggregateInputType | true
    }
  >

  export interface CommunityBoardCandidateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityBoardCandidate that matches the filter.
     * @param {CommunityBoardCandidateFindUniqueArgs} args - Arguments to find a CommunityBoardCandidate
     * @example
     * // Get one CommunityBoardCandidate
     * const communityBoardCandidate = await prisma.communityBoardCandidate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityBoardCandidateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityBoardCandidateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityBoardCandidate'> extends True ? CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate | null >, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T> | null >>

    /**
     * Find the first CommunityBoardCandidate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateFindFirstArgs} args - Arguments to find a CommunityBoardCandidate
     * @example
     * // Get one CommunityBoardCandidate
     * const communityBoardCandidate = await prisma.communityBoardCandidate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityBoardCandidateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityBoardCandidateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityBoardCandidate'> extends True ? CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate | null >, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T> | null >>

    /**
     * Find zero or more CommunityBoardCandidates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityBoardCandidates
     * const communityBoardCandidates = await prisma.communityBoardCandidate.findMany()
     * 
     * // Get first 10 CommunityBoardCandidates
     * const communityBoardCandidates = await prisma.communityBoardCandidate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityBoardCandidateWithIdOnly = await prisma.communityBoardCandidate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityBoardCandidateFindManyArgs>(
      args?: SelectSubset<T, CommunityBoardCandidateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommunityBoardCandidate>>, PrismaPromise<Array<CommunityBoardCandidateGetPayload<T>>>>

    /**
     * Create a CommunityBoardCandidate.
     * @param {CommunityBoardCandidateCreateArgs} args - Arguments to create a CommunityBoardCandidate.
     * @example
     * // Create one CommunityBoardCandidate
     * const CommunityBoardCandidate = await prisma.communityBoardCandidate.create({
     *   data: {
     *     // ... data to create a CommunityBoardCandidate
     *   }
     * })
     * 
    **/
    create<T extends CommunityBoardCandidateCreateArgs>(
      args: SelectSubset<T, CommunityBoardCandidateCreateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>>

    /**
     * Create many CommunityBoardCandidates.
     *     @param {CommunityBoardCandidateCreateManyArgs} args - Arguments to create many CommunityBoardCandidates.
     *     @example
     *     // Create many CommunityBoardCandidates
     *     const communityBoardCandidate = await prisma.communityBoardCandidate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityBoardCandidateCreateManyArgs>(
      args?: SelectSubset<T, CommunityBoardCandidateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityBoardCandidate.
     * @param {CommunityBoardCandidateDeleteArgs} args - Arguments to delete one CommunityBoardCandidate.
     * @example
     * // Delete one CommunityBoardCandidate
     * const CommunityBoardCandidate = await prisma.communityBoardCandidate.delete({
     *   where: {
     *     // ... filter to delete one CommunityBoardCandidate
     *   }
     * })
     * 
    **/
    delete<T extends CommunityBoardCandidateDeleteArgs>(
      args: SelectSubset<T, CommunityBoardCandidateDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>>

    /**
     * Update one CommunityBoardCandidate.
     * @param {CommunityBoardCandidateUpdateArgs} args - Arguments to update one CommunityBoardCandidate.
     * @example
     * // Update one CommunityBoardCandidate
     * const communityBoardCandidate = await prisma.communityBoardCandidate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityBoardCandidateUpdateArgs>(
      args: SelectSubset<T, CommunityBoardCandidateUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>>

    /**
     * Delete zero or more CommunityBoardCandidates.
     * @param {CommunityBoardCandidateDeleteManyArgs} args - Arguments to filter CommunityBoardCandidates to delete.
     * @example
     * // Delete a few CommunityBoardCandidates
     * const { count } = await prisma.communityBoardCandidate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityBoardCandidateDeleteManyArgs>(
      args?: SelectSubset<T, CommunityBoardCandidateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityBoardCandidates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityBoardCandidates
     * const communityBoardCandidate = await prisma.communityBoardCandidate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityBoardCandidateUpdateManyArgs>(
      args: SelectSubset<T, CommunityBoardCandidateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityBoardCandidate.
     * @param {CommunityBoardCandidateUpsertArgs} args - Arguments to update or create a CommunityBoardCandidate.
     * @example
     * // Update or create a CommunityBoardCandidate
     * const communityBoardCandidate = await prisma.communityBoardCandidate.upsert({
     *   create: {
     *     // ... data to create a CommunityBoardCandidate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityBoardCandidate we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityBoardCandidateUpsertArgs>(
      args: SelectSubset<T, CommunityBoardCandidateUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate>, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T>>>

    /**
     * Count the number of CommunityBoardCandidates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateCountArgs} args - Arguments to filter CommunityBoardCandidates to count.
     * @example
     * // Count the number of CommunityBoardCandidates
     * const count = await prisma.communityBoardCandidate.count({
     *   where: {
     *     // ... the filter for the CommunityBoardCandidates we want to count
     *   }
     * })
    **/
    count<T extends CommunityBoardCandidateCountArgs>(
      args?: Subset<T, CommunityBoardCandidateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityBoardCandidateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityBoardCandidate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityBoardCandidateAggregateArgs>(args: Subset<T, CommunityBoardCandidateAggregateArgs>): PrismaPromise<GetCommunityBoardCandidateAggregateType<T>>

    /**
     * Group by CommunityBoardCandidate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityBoardCandidateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityBoardCandidateGroupByArgs['orderBy'] }
        : { orderBy?: CommunityBoardCandidateGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityBoardCandidateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityBoardCandidateGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityBoardCandidate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityBoardCandidateClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    communityBoardCandidateVotes<T extends CommunityBoardCandidateVoteFindManyArgs = {}>(args?: Subset<T, CommunityBoardCandidateVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityBoardCandidateVote>>, PrismaPromise<Array<CommunityBoardCandidateVoteGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityBoardCandidate findUnique
   */
  export type CommunityBoardCandidateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * Throw an Error if a CommunityBoardCandidate can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardCandidate to fetch.
    **/
    where: CommunityBoardCandidateWhereUniqueInput
  }


  /**
   * CommunityBoardCandidate findFirst
   */
  export type CommunityBoardCandidateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * Throw an Error if a CommunityBoardCandidate can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardCandidate to fetch.
    **/
    where?: CommunityBoardCandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoardCandidates to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBoardCandidates.
    **/
    cursor?: CommunityBoardCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidates from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidates.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityBoardCandidates.
    **/
    distinct?: Enumerable<CommunityBoardCandidateScalarFieldEnum>
  }


  /**
   * CommunityBoardCandidate findMany
   */
  export type CommunityBoardCandidateFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * Filter, which CommunityBoardCandidates to fetch.
    **/
    where?: CommunityBoardCandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoardCandidates to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityBoardCandidates.
    **/
    cursor?: CommunityBoardCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidates from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidates.
    **/
    skip?: number
    distinct?: Enumerable<CommunityBoardCandidateScalarFieldEnum>
  }


  /**
   * CommunityBoardCandidate create
   */
  export type CommunityBoardCandidateCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * The data needed to create a CommunityBoardCandidate.
    **/
    data: XOR<CommunityBoardCandidateCreateInput, CommunityBoardCandidateUncheckedCreateInput>
  }


  /**
   * CommunityBoardCandidate createMany
   */
  export type CommunityBoardCandidateCreateManyArgs = {
    data: Enumerable<CommunityBoardCandidateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommunityBoardCandidate update
   */
  export type CommunityBoardCandidateUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * The data needed to update a CommunityBoardCandidate.
    **/
    data: XOR<CommunityBoardCandidateUpdateInput, CommunityBoardCandidateUncheckedUpdateInput>
    /**
     * Choose, which CommunityBoardCandidate to update.
    **/
    where: CommunityBoardCandidateWhereUniqueInput
  }


  /**
   * CommunityBoardCandidate updateMany
   */
  export type CommunityBoardCandidateUpdateManyArgs = {
    data: XOR<CommunityBoardCandidateUpdateManyMutationInput, CommunityBoardCandidateUncheckedUpdateManyInput>
    where?: CommunityBoardCandidateWhereInput
  }


  /**
   * CommunityBoardCandidate upsert
   */
  export type CommunityBoardCandidateUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * The filter to search for the CommunityBoardCandidate to update in case it exists.
    **/
    where: CommunityBoardCandidateWhereUniqueInput
    /**
     * In case the CommunityBoardCandidate found by the `where` argument doesn't exist, create a new CommunityBoardCandidate with this data.
    **/
    create: XOR<CommunityBoardCandidateCreateInput, CommunityBoardCandidateUncheckedCreateInput>
    /**
     * In case the CommunityBoardCandidate was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityBoardCandidateUpdateInput, CommunityBoardCandidateUncheckedUpdateInput>
  }


  /**
   * CommunityBoardCandidate delete
   */
  export type CommunityBoardCandidateDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
    /**
     * Filter which CommunityBoardCandidate to delete.
    **/
    where: CommunityBoardCandidateWhereUniqueInput
  }


  /**
   * CommunityBoardCandidate deleteMany
   */
  export type CommunityBoardCandidateDeleteManyArgs = {
    where?: CommunityBoardCandidateWhereInput
  }


  /**
   * CommunityBoardCandidate without action
   */
  export type CommunityBoardCandidateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidate
    **/
    select?: CommunityBoardCandidateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateInclude | null
  }



  /**
   * Model CommunityBoardCandidateVote
   */


  export type AggregateCommunityBoardCandidateVote = {
    count: CommunityBoardCandidateVoteCountAggregateOutputType | null
    avg: CommunityBoardCandidateVoteAvgAggregateOutputType | null
    sum: CommunityBoardCandidateVoteSumAggregateOutputType | null
    min: CommunityBoardCandidateVoteMinAggregateOutputType | null
    max: CommunityBoardCandidateVoteMaxAggregateOutputType | null
  }

  export type CommunityBoardCandidateVoteAvgAggregateOutputType = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardCandidateVoteSumAggregateOutputType = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardCandidateVoteMinAggregateOutputType = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardCandidateVoteMaxAggregateOutputType = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardCandidateVoteCountAggregateOutputType = {
    boardCandidateId: number
    userId: number
    _all: number
  }


  export type CommunityBoardCandidateVoteAvgAggregateInputType = {
    boardCandidateId?: true
    userId?: true
  }

  export type CommunityBoardCandidateVoteSumAggregateInputType = {
    boardCandidateId?: true
    userId?: true
  }

  export type CommunityBoardCandidateVoteMinAggregateInputType = {
    boardCandidateId?: true
    userId?: true
  }

  export type CommunityBoardCandidateVoteMaxAggregateInputType = {
    boardCandidateId?: true
    userId?: true
  }

  export type CommunityBoardCandidateVoteCountAggregateInputType = {
    boardCandidateId?: true
    userId?: true
    _all?: true
  }

  export type CommunityBoardCandidateVoteAggregateArgs = {
    /**
     * Filter which CommunityBoardCandidateVote to aggregate.
    **/
    where?: CommunityBoardCandidateVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoardCandidateVotes to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateVoteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityBoardCandidateVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidateVotes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidateVotes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityBoardCandidateVotes
    **/
    count?: true | CommunityBoardCandidateVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityBoardCandidateVoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityBoardCandidateVoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityBoardCandidateVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityBoardCandidateVoteMaxAggregateInputType
  }

  export type GetCommunityBoardCandidateVoteAggregateType<T extends CommunityBoardCandidateVoteAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityBoardCandidateVote]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityBoardCandidateVote[P]>
      : GetScalarType<T[P], AggregateCommunityBoardCandidateVote[P]>
  }


    
    
  export type CommunityBoardCandidateVoteGroupByArgs = {
    where?: CommunityBoardCandidateVoteWhereInput
    orderBy?: Enumerable<CommunityBoardCandidateVoteOrderByInput>
    by: Array<CommunityBoardCandidateVoteScalarFieldEnum>
    having?: CommunityBoardCandidateVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommunityBoardCandidateVoteCountAggregateInputType | true
    avg?: CommunityBoardCandidateVoteAvgAggregateInputType
    sum?: CommunityBoardCandidateVoteSumAggregateInputType
    min?: CommunityBoardCandidateVoteMinAggregateInputType
    max?: CommunityBoardCandidateVoteMaxAggregateInputType
  }


  export type CommunityBoardCandidateVoteGroupByOutputType = {
    boardCandidateId: number
    userId: number
    count: CommunityBoardCandidateVoteCountAggregateOutputType | null
    avg: CommunityBoardCandidateVoteAvgAggregateOutputType | null
    sum: CommunityBoardCandidateVoteSumAggregateOutputType | null
    min: CommunityBoardCandidateVoteMinAggregateOutputType | null
    max: CommunityBoardCandidateVoteMaxAggregateOutputType | null
  }

  type GetCommunityBoardCandidateVoteGroupByPayload<T extends CommunityBoardCandidateVoteGroupByArgs> = Promise<Array<
    PickArray<CommunityBoardCandidateVoteGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommunityBoardCandidateVoteGroupByOutputType))]: GetScalarType<T[P], CommunityBoardCandidateVoteGroupByOutputType[P]>
    }
  >>
    

  export type CommunityBoardCandidateVoteSelect = {
    boardCandidateId?: boolean
    userId?: boolean
    communityBoardCandidate?: boolean | CommunityBoardCandidateArgs
    user?: boolean | UserArgs
  }

  export type CommunityBoardCandidateVoteInclude = {
    communityBoardCandidate?: boolean | CommunityBoardCandidateArgs
    user?: boolean | UserArgs
  }

  export type CommunityBoardCandidateVoteGetPayload<
    S extends boolean | null | undefined | CommunityBoardCandidateVoteArgs,
    U = keyof S
      > = S extends true
        ? CommunityBoardCandidateVote
    : S extends undefined
    ? never
    : S extends CommunityBoardCandidateVoteArgs | CommunityBoardCandidateVoteFindManyArgs
    ?'include' extends U
    ? CommunityBoardCandidateVote  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityBoardCandidate'
        ? CommunityBoardCandidateGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityBoardCandidateVote ?CommunityBoardCandidateVote [P]
  : 
          P extends 'communityBoardCandidate'
        ? CommunityBoardCandidateGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : CommunityBoardCandidateVote
  : CommunityBoardCandidateVote


  type CommunityBoardCandidateVoteCountArgs = Merge<
    Omit<CommunityBoardCandidateVoteFindManyArgs, 'select' | 'include'> & {
      select?: CommunityBoardCandidateVoteCountAggregateInputType | true
    }
  >

  export interface CommunityBoardCandidateVoteDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityBoardCandidateVote that matches the filter.
     * @param {CommunityBoardCandidateVoteFindUniqueArgs} args - Arguments to find a CommunityBoardCandidateVote
     * @example
     * // Get one CommunityBoardCandidateVote
     * const communityBoardCandidateVote = await prisma.communityBoardCandidateVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityBoardCandidateVoteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityBoardCandidateVoteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityBoardCandidateVote'> extends True ? CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote | null >, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T> | null >>

    /**
     * Find the first CommunityBoardCandidateVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateVoteFindFirstArgs} args - Arguments to find a CommunityBoardCandidateVote
     * @example
     * // Get one CommunityBoardCandidateVote
     * const communityBoardCandidateVote = await prisma.communityBoardCandidateVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityBoardCandidateVoteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityBoardCandidateVoteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityBoardCandidateVote'> extends True ? CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote | null >, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T> | null >>

    /**
     * Find zero or more CommunityBoardCandidateVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateVoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityBoardCandidateVotes
     * const communityBoardCandidateVotes = await prisma.communityBoardCandidateVote.findMany()
     * 
     * // Get first 10 CommunityBoardCandidateVotes
     * const communityBoardCandidateVotes = await prisma.communityBoardCandidateVote.findMany({ take: 10 })
     * 
     * // Only select the `boardCandidateId`
     * const communityBoardCandidateVoteWithBoardCandidateIdOnly = await prisma.communityBoardCandidateVote.findMany({ select: { boardCandidateId: true } })
     * 
    **/
    findMany<T extends CommunityBoardCandidateVoteFindManyArgs>(
      args?: SelectSubset<T, CommunityBoardCandidateVoteFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommunityBoardCandidateVote>>, PrismaPromise<Array<CommunityBoardCandidateVoteGetPayload<T>>>>

    /**
     * Create a CommunityBoardCandidateVote.
     * @param {CommunityBoardCandidateVoteCreateArgs} args - Arguments to create a CommunityBoardCandidateVote.
     * @example
     * // Create one CommunityBoardCandidateVote
     * const CommunityBoardCandidateVote = await prisma.communityBoardCandidateVote.create({
     *   data: {
     *     // ... data to create a CommunityBoardCandidateVote
     *   }
     * })
     * 
    **/
    create<T extends CommunityBoardCandidateVoteCreateArgs>(
      args: SelectSubset<T, CommunityBoardCandidateVoteCreateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>>

    /**
     * Create many CommunityBoardCandidateVotes.
     *     @param {CommunityBoardCandidateVoteCreateManyArgs} args - Arguments to create many CommunityBoardCandidateVotes.
     *     @example
     *     // Create many CommunityBoardCandidateVotes
     *     const communityBoardCandidateVote = await prisma.communityBoardCandidateVote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityBoardCandidateVoteCreateManyArgs>(
      args?: SelectSubset<T, CommunityBoardCandidateVoteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityBoardCandidateVote.
     * @param {CommunityBoardCandidateVoteDeleteArgs} args - Arguments to delete one CommunityBoardCandidateVote.
     * @example
     * // Delete one CommunityBoardCandidateVote
     * const CommunityBoardCandidateVote = await prisma.communityBoardCandidateVote.delete({
     *   where: {
     *     // ... filter to delete one CommunityBoardCandidateVote
     *   }
     * })
     * 
    **/
    delete<T extends CommunityBoardCandidateVoteDeleteArgs>(
      args: SelectSubset<T, CommunityBoardCandidateVoteDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>>

    /**
     * Update one CommunityBoardCandidateVote.
     * @param {CommunityBoardCandidateVoteUpdateArgs} args - Arguments to update one CommunityBoardCandidateVote.
     * @example
     * // Update one CommunityBoardCandidateVote
     * const communityBoardCandidateVote = await prisma.communityBoardCandidateVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityBoardCandidateVoteUpdateArgs>(
      args: SelectSubset<T, CommunityBoardCandidateVoteUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>>

    /**
     * Delete zero or more CommunityBoardCandidateVotes.
     * @param {CommunityBoardCandidateVoteDeleteManyArgs} args - Arguments to filter CommunityBoardCandidateVotes to delete.
     * @example
     * // Delete a few CommunityBoardCandidateVotes
     * const { count } = await prisma.communityBoardCandidateVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityBoardCandidateVoteDeleteManyArgs>(
      args?: SelectSubset<T, CommunityBoardCandidateVoteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityBoardCandidateVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityBoardCandidateVotes
     * const communityBoardCandidateVote = await prisma.communityBoardCandidateVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityBoardCandidateVoteUpdateManyArgs>(
      args: SelectSubset<T, CommunityBoardCandidateVoteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityBoardCandidateVote.
     * @param {CommunityBoardCandidateVoteUpsertArgs} args - Arguments to update or create a CommunityBoardCandidateVote.
     * @example
     * // Update or create a CommunityBoardCandidateVote
     * const communityBoardCandidateVote = await prisma.communityBoardCandidateVote.upsert({
     *   create: {
     *     // ... data to create a CommunityBoardCandidateVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityBoardCandidateVote we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityBoardCandidateVoteUpsertArgs>(
      args: SelectSubset<T, CommunityBoardCandidateVoteUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVote>, Prisma__CommunityBoardCandidateVoteClient<CommunityBoardCandidateVoteGetPayload<T>>>

    /**
     * Count the number of CommunityBoardCandidateVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateVoteCountArgs} args - Arguments to filter CommunityBoardCandidateVotes to count.
     * @example
     * // Count the number of CommunityBoardCandidateVotes
     * const count = await prisma.communityBoardCandidateVote.count({
     *   where: {
     *     // ... the filter for the CommunityBoardCandidateVotes we want to count
     *   }
     * })
    **/
    count<T extends CommunityBoardCandidateVoteCountArgs>(
      args?: Subset<T, CommunityBoardCandidateVoteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityBoardCandidateVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityBoardCandidateVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityBoardCandidateVoteAggregateArgs>(args: Subset<T, CommunityBoardCandidateVoteAggregateArgs>): PrismaPromise<GetCommunityBoardCandidateVoteAggregateType<T>>

    /**
     * Group by CommunityBoardCandidateVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardCandidateVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityBoardCandidateVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityBoardCandidateVoteGroupByArgs['orderBy'] }
        : { orderBy?: CommunityBoardCandidateVoteGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityBoardCandidateVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityBoardCandidateVoteGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityBoardCandidateVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityBoardCandidateVoteClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityBoardCandidate<T extends CommunityBoardCandidateArgs = {}>(args?: Subset<T, CommunityBoardCandidateArgs>): CheckSelect<T, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidate | null >, Prisma__CommunityBoardCandidateClient<CommunityBoardCandidateGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityBoardCandidateVote findUnique
   */
  export type CommunityBoardCandidateVoteFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * Throw an Error if a CommunityBoardCandidateVote can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardCandidateVote to fetch.
    **/
    where: CommunityBoardCandidateVoteWhereUniqueInput
  }


  /**
   * CommunityBoardCandidateVote findFirst
   */
  export type CommunityBoardCandidateVoteFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * Throw an Error if a CommunityBoardCandidateVote can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardCandidateVote to fetch.
    **/
    where?: CommunityBoardCandidateVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoardCandidateVotes to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateVoteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBoardCandidateVotes.
    **/
    cursor?: CommunityBoardCandidateVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidateVotes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidateVotes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityBoardCandidateVotes.
    **/
    distinct?: Enumerable<CommunityBoardCandidateVoteScalarFieldEnum>
  }


  /**
   * CommunityBoardCandidateVote findMany
   */
  export type CommunityBoardCandidateVoteFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * Filter, which CommunityBoardCandidateVotes to fetch.
    **/
    where?: CommunityBoardCandidateVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoardCandidateVotes to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardCandidateVoteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityBoardCandidateVotes.
    **/
    cursor?: CommunityBoardCandidateVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardCandidateVotes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardCandidateVotes.
    **/
    skip?: number
    distinct?: Enumerable<CommunityBoardCandidateVoteScalarFieldEnum>
  }


  /**
   * CommunityBoardCandidateVote create
   */
  export type CommunityBoardCandidateVoteCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * The data needed to create a CommunityBoardCandidateVote.
    **/
    data: XOR<CommunityBoardCandidateVoteCreateInput, CommunityBoardCandidateVoteUncheckedCreateInput>
  }


  /**
   * CommunityBoardCandidateVote createMany
   */
  export type CommunityBoardCandidateVoteCreateManyArgs = {
    data: Enumerable<CommunityBoardCandidateVoteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommunityBoardCandidateVote update
   */
  export type CommunityBoardCandidateVoteUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * The data needed to update a CommunityBoardCandidateVote.
    **/
    data: XOR<CommunityBoardCandidateVoteUpdateInput, CommunityBoardCandidateVoteUncheckedUpdateInput>
    /**
     * Choose, which CommunityBoardCandidateVote to update.
    **/
    where: CommunityBoardCandidateVoteWhereUniqueInput
  }


  /**
   * CommunityBoardCandidateVote updateMany
   */
  export type CommunityBoardCandidateVoteUpdateManyArgs = {
    data: XOR<CommunityBoardCandidateVoteUpdateManyMutationInput, CommunityBoardCandidateVoteUncheckedUpdateManyInput>
    where?: CommunityBoardCandidateVoteWhereInput
  }


  /**
   * CommunityBoardCandidateVote upsert
   */
  export type CommunityBoardCandidateVoteUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * The filter to search for the CommunityBoardCandidateVote to update in case it exists.
    **/
    where: CommunityBoardCandidateVoteWhereUniqueInput
    /**
     * In case the CommunityBoardCandidateVote found by the `where` argument doesn't exist, create a new CommunityBoardCandidateVote with this data.
    **/
    create: XOR<CommunityBoardCandidateVoteCreateInput, CommunityBoardCandidateVoteUncheckedCreateInput>
    /**
     * In case the CommunityBoardCandidateVote was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityBoardCandidateVoteUpdateInput, CommunityBoardCandidateVoteUncheckedUpdateInput>
  }


  /**
   * CommunityBoardCandidateVote delete
   */
  export type CommunityBoardCandidateVoteDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
    /**
     * Filter which CommunityBoardCandidateVote to delete.
    **/
    where: CommunityBoardCandidateVoteWhereUniqueInput
  }


  /**
   * CommunityBoardCandidateVote deleteMany
   */
  export type CommunityBoardCandidateVoteDeleteManyArgs = {
    where?: CommunityBoardCandidateVoteWhereInput
  }


  /**
   * CommunityBoardCandidateVote without action
   */
  export type CommunityBoardCandidateVoteArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardCandidateVote
    **/
    select?: CommunityBoardCandidateVoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardCandidateVoteInclude | null
  }



  /**
   * Model CommunityBoardPin
   */


  export type AggregateCommunityBoardPin = {
    count: CommunityBoardPinCountAggregateOutputType | null
    avg: CommunityBoardPinAvgAggregateOutputType | null
    sum: CommunityBoardPinSumAggregateOutputType | null
    min: CommunityBoardPinMinAggregateOutputType | null
    max: CommunityBoardPinMaxAggregateOutputType | null
  }

  export type CommunityBoardPinAvgAggregateOutputType = {
    userId: number
    boardId: number
  }

  export type CommunityBoardPinSumAggregateOutputType = {
    userId: number
    boardId: number
  }

  export type CommunityBoardPinMinAggregateOutputType = {
    userId: number
    boardId: number
  }

  export type CommunityBoardPinMaxAggregateOutputType = {
    userId: number
    boardId: number
  }

  export type CommunityBoardPinCountAggregateOutputType = {
    userId: number
    boardId: number
    _all: number
  }


  export type CommunityBoardPinAvgAggregateInputType = {
    userId?: true
    boardId?: true
  }

  export type CommunityBoardPinSumAggregateInputType = {
    userId?: true
    boardId?: true
  }

  export type CommunityBoardPinMinAggregateInputType = {
    userId?: true
    boardId?: true
  }

  export type CommunityBoardPinMaxAggregateInputType = {
    userId?: true
    boardId?: true
  }

  export type CommunityBoardPinCountAggregateInputType = {
    userId?: true
    boardId?: true
    _all?: true
  }

  export type CommunityBoardPinAggregateArgs = {
    /**
     * Filter which CommunityBoardPin to aggregate.
    **/
    where?: CommunityBoardPinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoardPins to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardPinOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityBoardPinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardPins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardPins.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityBoardPins
    **/
    count?: true | CommunityBoardPinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityBoardPinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityBoardPinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityBoardPinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityBoardPinMaxAggregateInputType
  }

  export type GetCommunityBoardPinAggregateType<T extends CommunityBoardPinAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityBoardPin]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityBoardPin[P]>
      : GetScalarType<T[P], AggregateCommunityBoardPin[P]>
  }


    
    
  export type CommunityBoardPinGroupByArgs = {
    where?: CommunityBoardPinWhereInput
    orderBy?: Enumerable<CommunityBoardPinOrderByInput>
    by: Array<CommunityBoardPinScalarFieldEnum>
    having?: CommunityBoardPinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommunityBoardPinCountAggregateInputType | true
    avg?: CommunityBoardPinAvgAggregateInputType
    sum?: CommunityBoardPinSumAggregateInputType
    min?: CommunityBoardPinMinAggregateInputType
    max?: CommunityBoardPinMaxAggregateInputType
  }


  export type CommunityBoardPinGroupByOutputType = {
    userId: number
    boardId: number
    count: CommunityBoardPinCountAggregateOutputType | null
    avg: CommunityBoardPinAvgAggregateOutputType | null
    sum: CommunityBoardPinSumAggregateOutputType | null
    min: CommunityBoardPinMinAggregateOutputType | null
    max: CommunityBoardPinMaxAggregateOutputType | null
  }

  type GetCommunityBoardPinGroupByPayload<T extends CommunityBoardPinGroupByArgs> = Promise<Array<
    PickArray<CommunityBoardPinGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommunityBoardPinGroupByOutputType))]: GetScalarType<T[P], CommunityBoardPinGroupByOutputType[P]>
    }
  >>
    

  export type CommunityBoardPinSelect = {
    userId?: boolean
    boardId?: boolean
    communityBoard?: boolean | CommunityBoardArgs
    user?: boolean | UserArgs
  }

  export type CommunityBoardPinInclude = {
    communityBoard?: boolean | CommunityBoardArgs
    user?: boolean | UserArgs
  }

  export type CommunityBoardPinGetPayload<
    S extends boolean | null | undefined | CommunityBoardPinArgs,
    U = keyof S
      > = S extends true
        ? CommunityBoardPin
    : S extends undefined
    ? never
    : S extends CommunityBoardPinArgs | CommunityBoardPinFindManyArgs
    ?'include' extends U
    ? CommunityBoardPin  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityBoard'
        ? CommunityBoardGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityBoardPin ?CommunityBoardPin [P]
  : 
          P extends 'communityBoard'
        ? CommunityBoardGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : CommunityBoardPin
  : CommunityBoardPin


  type CommunityBoardPinCountArgs = Merge<
    Omit<CommunityBoardPinFindManyArgs, 'select' | 'include'> & {
      select?: CommunityBoardPinCountAggregateInputType | true
    }
  >

  export interface CommunityBoardPinDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityBoardPin that matches the filter.
     * @param {CommunityBoardPinFindUniqueArgs} args - Arguments to find a CommunityBoardPin
     * @example
     * // Get one CommunityBoardPin
     * const communityBoardPin = await prisma.communityBoardPin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityBoardPinFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityBoardPinFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityBoardPin'> extends True ? CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin | null >, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T> | null >>

    /**
     * Find the first CommunityBoardPin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardPinFindFirstArgs} args - Arguments to find a CommunityBoardPin
     * @example
     * // Get one CommunityBoardPin
     * const communityBoardPin = await prisma.communityBoardPin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityBoardPinFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityBoardPinFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityBoardPin'> extends True ? CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>> : CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin | null >, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T> | null >>

    /**
     * Find zero or more CommunityBoardPins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardPinFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityBoardPins
     * const communityBoardPins = await prisma.communityBoardPin.findMany()
     * 
     * // Get first 10 CommunityBoardPins
     * const communityBoardPins = await prisma.communityBoardPin.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const communityBoardPinWithUserIdOnly = await prisma.communityBoardPin.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CommunityBoardPinFindManyArgs>(
      args?: SelectSubset<T, CommunityBoardPinFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommunityBoardPin>>, PrismaPromise<Array<CommunityBoardPinGetPayload<T>>>>

    /**
     * Create a CommunityBoardPin.
     * @param {CommunityBoardPinCreateArgs} args - Arguments to create a CommunityBoardPin.
     * @example
     * // Create one CommunityBoardPin
     * const CommunityBoardPin = await prisma.communityBoardPin.create({
     *   data: {
     *     // ... data to create a CommunityBoardPin
     *   }
     * })
     * 
    **/
    create<T extends CommunityBoardPinCreateArgs>(
      args: SelectSubset<T, CommunityBoardPinCreateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>>

    /**
     * Create many CommunityBoardPins.
     *     @param {CommunityBoardPinCreateManyArgs} args - Arguments to create many CommunityBoardPins.
     *     @example
     *     // Create many CommunityBoardPins
     *     const communityBoardPin = await prisma.communityBoardPin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityBoardPinCreateManyArgs>(
      args?: SelectSubset<T, CommunityBoardPinCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityBoardPin.
     * @param {CommunityBoardPinDeleteArgs} args - Arguments to delete one CommunityBoardPin.
     * @example
     * // Delete one CommunityBoardPin
     * const CommunityBoardPin = await prisma.communityBoardPin.delete({
     *   where: {
     *     // ... filter to delete one CommunityBoardPin
     *   }
     * })
     * 
    **/
    delete<T extends CommunityBoardPinDeleteArgs>(
      args: SelectSubset<T, CommunityBoardPinDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>>

    /**
     * Update one CommunityBoardPin.
     * @param {CommunityBoardPinUpdateArgs} args - Arguments to update one CommunityBoardPin.
     * @example
     * // Update one CommunityBoardPin
     * const communityBoardPin = await prisma.communityBoardPin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityBoardPinUpdateArgs>(
      args: SelectSubset<T, CommunityBoardPinUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>>

    /**
     * Delete zero or more CommunityBoardPins.
     * @param {CommunityBoardPinDeleteManyArgs} args - Arguments to filter CommunityBoardPins to delete.
     * @example
     * // Delete a few CommunityBoardPins
     * const { count } = await prisma.communityBoardPin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityBoardPinDeleteManyArgs>(
      args?: SelectSubset<T, CommunityBoardPinDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityBoardPins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardPinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityBoardPins
     * const communityBoardPin = await prisma.communityBoardPin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityBoardPinUpdateManyArgs>(
      args: SelectSubset<T, CommunityBoardPinUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityBoardPin.
     * @param {CommunityBoardPinUpsertArgs} args - Arguments to update or create a CommunityBoardPin.
     * @example
     * // Update or create a CommunityBoardPin
     * const communityBoardPin = await prisma.communityBoardPin.upsert({
     *   create: {
     *     // ... data to create a CommunityBoardPin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityBoardPin we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityBoardPinUpsertArgs>(
      args: SelectSubset<T, CommunityBoardPinUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityBoardPinClient<CommunityBoardPin>, Prisma__CommunityBoardPinClient<CommunityBoardPinGetPayload<T>>>

    /**
     * Count the number of CommunityBoardPins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardPinCountArgs} args - Arguments to filter CommunityBoardPins to count.
     * @example
     * // Count the number of CommunityBoardPins
     * const count = await prisma.communityBoardPin.count({
     *   where: {
     *     // ... the filter for the CommunityBoardPins we want to count
     *   }
     * })
    **/
    count<T extends CommunityBoardPinCountArgs>(
      args?: Subset<T, CommunityBoardPinCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityBoardPinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityBoardPin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardPinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityBoardPinAggregateArgs>(args: Subset<T, CommunityBoardPinAggregateArgs>): PrismaPromise<GetCommunityBoardPinAggregateType<T>>

    /**
     * Group by CommunityBoardPin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBoardPinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityBoardPinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityBoardPinGroupByArgs['orderBy'] }
        : { orderBy?: CommunityBoardPinGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityBoardPinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityBoardPinGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityBoardPin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityBoardPinClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityBoard<T extends CommunityBoardArgs = {}>(args?: Subset<T, CommunityBoardArgs>): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard | null >, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityBoardPin findUnique
   */
  export type CommunityBoardPinFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * Throw an Error if a CommunityBoardPin can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardPin to fetch.
    **/
    where: CommunityBoardPinWhereUniqueInput
  }


  /**
   * CommunityBoardPin findFirst
   */
  export type CommunityBoardPinFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * Throw an Error if a CommunityBoardPin can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityBoardPin to fetch.
    **/
    where?: CommunityBoardPinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoardPins to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardPinOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBoardPins.
    **/
    cursor?: CommunityBoardPinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardPins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardPins.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityBoardPins.
    **/
    distinct?: Enumerable<CommunityBoardPinScalarFieldEnum>
  }


  /**
   * CommunityBoardPin findMany
   */
  export type CommunityBoardPinFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * Filter, which CommunityBoardPins to fetch.
    **/
    where?: CommunityBoardPinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBoardPins to fetch.
    **/
    orderBy?: Enumerable<CommunityBoardPinOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityBoardPins.
    **/
    cursor?: CommunityBoardPinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBoardPins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBoardPins.
    **/
    skip?: number
    distinct?: Enumerable<CommunityBoardPinScalarFieldEnum>
  }


  /**
   * CommunityBoardPin create
   */
  export type CommunityBoardPinCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * The data needed to create a CommunityBoardPin.
    **/
    data: XOR<CommunityBoardPinCreateInput, CommunityBoardPinUncheckedCreateInput>
  }


  /**
   * CommunityBoardPin createMany
   */
  export type CommunityBoardPinCreateManyArgs = {
    data: Enumerable<CommunityBoardPinCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommunityBoardPin update
   */
  export type CommunityBoardPinUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * The data needed to update a CommunityBoardPin.
    **/
    data: XOR<CommunityBoardPinUpdateInput, CommunityBoardPinUncheckedUpdateInput>
    /**
     * Choose, which CommunityBoardPin to update.
    **/
    where: CommunityBoardPinWhereUniqueInput
  }


  /**
   * CommunityBoardPin updateMany
   */
  export type CommunityBoardPinUpdateManyArgs = {
    data: XOR<CommunityBoardPinUpdateManyMutationInput, CommunityBoardPinUncheckedUpdateManyInput>
    where?: CommunityBoardPinWhereInput
  }


  /**
   * CommunityBoardPin upsert
   */
  export type CommunityBoardPinUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * The filter to search for the CommunityBoardPin to update in case it exists.
    **/
    where: CommunityBoardPinWhereUniqueInput
    /**
     * In case the CommunityBoardPin found by the `where` argument doesn't exist, create a new CommunityBoardPin with this data.
    **/
    create: XOR<CommunityBoardPinCreateInput, CommunityBoardPinUncheckedCreateInput>
    /**
     * In case the CommunityBoardPin was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityBoardPinUpdateInput, CommunityBoardPinUncheckedUpdateInput>
  }


  /**
   * CommunityBoardPin delete
   */
  export type CommunityBoardPinDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
    /**
     * Filter which CommunityBoardPin to delete.
    **/
    where: CommunityBoardPinWhereUniqueInput
  }


  /**
   * CommunityBoardPin deleteMany
   */
  export type CommunityBoardPinDeleteManyArgs = {
    where?: CommunityBoardPinWhereInput
  }


  /**
   * CommunityBoardPin without action
   */
  export type CommunityBoardPinArgs = {
    /**
     * Select specific fields to fetch from the CommunityBoardPin
    **/
    select?: CommunityBoardPinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityBoardPinInclude | null
  }



  /**
   * Model CommunityComment
   */


  export type AggregateCommunityComment = {
    count: CommunityCommentCountAggregateOutputType | null
    avg: CommunityCommentAvgAggregateOutputType | null
    sum: CommunityCommentSumAggregateOutputType | null
    min: CommunityCommentMinAggregateOutputType | null
    max: CommunityCommentMaxAggregateOutputType | null
  }

  export type CommunityCommentAvgAggregateOutputType = {
    id: number
    postId: number
    userId: number
  }

  export type CommunityCommentSumAggregateOutputType = {
    id: number
    postId: number
    userId: number
  }

  export type CommunityCommentMinAggregateOutputType = {
    id: number
    postId: number
    userId: number
    randomNickname: string | null
    body: string | null
    commentedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunityCommentMaxAggregateOutputType = {
    id: number
    postId: number
    userId: number
    randomNickname: string | null
    body: string | null
    commentedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunityCommentCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    randomNickname: number | null
    body: number | null
    commentedAt: number | null
    isDeleted: number | null
    _all: number
  }


  export type CommunityCommentAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type CommunityCommentSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type CommunityCommentMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    randomNickname?: true
    body?: true
    commentedAt?: true
    isDeleted?: true
  }

  export type CommunityCommentMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    randomNickname?: true
    body?: true
    commentedAt?: true
    isDeleted?: true
  }

  export type CommunityCommentCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    randomNickname?: true
    body?: true
    commentedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type CommunityCommentAggregateArgs = {
    /**
     * Filter which CommunityComment to aggregate.
    **/
    where?: CommunityCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityComments to fetch.
    **/
    orderBy?: Enumerable<CommunityCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityComments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityComments
    **/
    count?: true | CommunityCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityCommentMaxAggregateInputType
  }

  export type GetCommunityCommentAggregateType<T extends CommunityCommentAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityComment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityComment[P]>
      : GetScalarType<T[P], AggregateCommunityComment[P]>
  }


    
    
  export type CommunityCommentGroupByArgs = {
    where?: CommunityCommentWhereInput
    orderBy?: Enumerable<CommunityCommentOrderByInput>
    by: Array<CommunityCommentScalarFieldEnum>
    having?: CommunityCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommunityCommentCountAggregateInputType | true
    avg?: CommunityCommentAvgAggregateInputType
    sum?: CommunityCommentSumAggregateInputType
    min?: CommunityCommentMinAggregateInputType
    max?: CommunityCommentMaxAggregateInputType
  }


  export type CommunityCommentGroupByOutputType = {
    id: number
    postId: number
    userId: number
    randomNickname: string
    body: string
    commentedAt: Date
    isDeleted: boolean
    count: CommunityCommentCountAggregateOutputType | null
    avg: CommunityCommentAvgAggregateOutputType | null
    sum: CommunityCommentSumAggregateOutputType | null
    min: CommunityCommentMinAggregateOutputType | null
    max: CommunityCommentMaxAggregateOutputType | null
  }

  type GetCommunityCommentGroupByPayload<T extends CommunityCommentGroupByArgs> = Promise<Array<
    PickArray<CommunityCommentGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommunityCommentGroupByOutputType))]: GetScalarType<T[P], CommunityCommentGroupByOutputType[P]>
    }
  >>
    

  export type CommunityCommentSelect = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    randomNickname?: boolean
    body?: boolean
    commentedAt?: boolean
    isDeleted?: boolean
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    reportComments?: boolean | ReportCommentFindManyArgs
  }

  export type CommunityCommentInclude = {
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    reportComments?: boolean | ReportCommentFindManyArgs
  }

  export type CommunityCommentGetPayload<
    S extends boolean | null | undefined | CommunityCommentArgs,
    U = keyof S
      > = S extends true
        ? CommunityComment
    : S extends undefined
    ? never
    : S extends CommunityCommentArgs | CommunityCommentFindManyArgs
    ?'include' extends U
    ? CommunityComment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['include'][P]>>  :
        P extends 'reportComments'
        ? Array < ReportCommentGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityComment ?CommunityComment [P]
  : 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['select'][P]>>  :
        P extends 'reportComments'
        ? Array < ReportCommentGetPayload<S['select'][P]>>  : never
  } 
    : CommunityComment
  : CommunityComment


  type CommunityCommentCountArgs = Merge<
    Omit<CommunityCommentFindManyArgs, 'select' | 'include'> & {
      select?: CommunityCommentCountAggregateInputType | true
    }
  >

  export interface CommunityCommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityComment that matches the filter.
     * @param {CommunityCommentFindUniqueArgs} args - Arguments to find a CommunityComment
     * @example
     * // Get one CommunityComment
     * const communityComment = await prisma.communityComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityComment'> extends True ? CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>> : CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment | null >, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T> | null >>

    /**
     * Find the first CommunityComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentFindFirstArgs} args - Arguments to find a CommunityComment
     * @example
     * // Get one CommunityComment
     * const communityComment = await prisma.communityComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityComment'> extends True ? CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>> : CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment | null >, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T> | null >>

    /**
     * Find zero or more CommunityComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityComments
     * const communityComments = await prisma.communityComment.findMany()
     * 
     * // Get first 10 CommunityComments
     * const communityComments = await prisma.communityComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityCommentWithIdOnly = await prisma.communityComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityCommentFindManyArgs>(
      args?: SelectSubset<T, CommunityCommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommunityComment>>, PrismaPromise<Array<CommunityCommentGetPayload<T>>>>

    /**
     * Create a CommunityComment.
     * @param {CommunityCommentCreateArgs} args - Arguments to create a CommunityComment.
     * @example
     * // Create one CommunityComment
     * const CommunityComment = await prisma.communityComment.create({
     *   data: {
     *     // ... data to create a CommunityComment
     *   }
     * })
     * 
    **/
    create<T extends CommunityCommentCreateArgs>(
      args: SelectSubset<T, CommunityCommentCreateArgs>
    ): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>>

    /**
     * Create many CommunityComments.
     *     @param {CommunityCommentCreateManyArgs} args - Arguments to create many CommunityComments.
     *     @example
     *     // Create many CommunityComments
     *     const communityComment = await prisma.communityComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityCommentCreateManyArgs>(
      args?: SelectSubset<T, CommunityCommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityComment.
     * @param {CommunityCommentDeleteArgs} args - Arguments to delete one CommunityComment.
     * @example
     * // Delete one CommunityComment
     * const CommunityComment = await prisma.communityComment.delete({
     *   where: {
     *     // ... filter to delete one CommunityComment
     *   }
     * })
     * 
    **/
    delete<T extends CommunityCommentDeleteArgs>(
      args: SelectSubset<T, CommunityCommentDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>>

    /**
     * Update one CommunityComment.
     * @param {CommunityCommentUpdateArgs} args - Arguments to update one CommunityComment.
     * @example
     * // Update one CommunityComment
     * const communityComment = await prisma.communityComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityCommentUpdateArgs>(
      args: SelectSubset<T, CommunityCommentUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>>

    /**
     * Delete zero or more CommunityComments.
     * @param {CommunityCommentDeleteManyArgs} args - Arguments to filter CommunityComments to delete.
     * @example
     * // Delete a few CommunityComments
     * const { count } = await prisma.communityComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityCommentDeleteManyArgs>(
      args?: SelectSubset<T, CommunityCommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityComments
     * const communityComment = await prisma.communityComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityCommentUpdateManyArgs>(
      args: SelectSubset<T, CommunityCommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityComment.
     * @param {CommunityCommentUpsertArgs} args - Arguments to update or create a CommunityComment.
     * @example
     * // Update or create a CommunityComment
     * const communityComment = await prisma.communityComment.upsert({
     *   create: {
     *     // ... data to create a CommunityComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityComment we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityCommentUpsertArgs>(
      args: SelectSubset<T, CommunityCommentUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment>, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T>>>

    /**
     * Count the number of CommunityComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentCountArgs} args - Arguments to filter CommunityComments to count.
     * @example
     * // Count the number of CommunityComments
     * const count = await prisma.communityComment.count({
     *   where: {
     *     // ... the filter for the CommunityComments we want to count
     *   }
     * })
    **/
    count<T extends CommunityCommentCountArgs>(
      args?: Subset<T, CommunityCommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityCommentAggregateArgs>(args: Subset<T, CommunityCommentAggregateArgs>): PrismaPromise<GetCommunityCommentAggregateType<T>>

    /**
     * Group by CommunityComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityCommentGroupByArgs['orderBy'] }
        : { orderBy?: CommunityCommentGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityCommentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityCommentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityPost<T extends CommunityPostArgs = {}>(args?: Subset<T, CommunityPostArgs>): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    communitySubcomments<T extends CommunitySubcommentFindManyArgs = {}>(args?: Subset<T, CommunitySubcommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunitySubcomment>>, PrismaPromise<Array<CommunitySubcommentGetPayload<T>>>>;

    reportComments<T extends ReportCommentFindManyArgs = {}>(args?: Subset<T, ReportCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReportComment>>, PrismaPromise<Array<ReportCommentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityComment findUnique
   */
  export type CommunityCommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * Throw an Error if a CommunityComment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityComment to fetch.
    **/
    where: CommunityCommentWhereUniqueInput
  }


  /**
   * CommunityComment findFirst
   */
  export type CommunityCommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * Throw an Error if a CommunityComment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityComment to fetch.
    **/
    where?: CommunityCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityComments to fetch.
    **/
    orderBy?: Enumerable<CommunityCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityComments.
    **/
    cursor?: CommunityCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityComments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityComments.
    **/
    distinct?: Enumerable<CommunityCommentScalarFieldEnum>
  }


  /**
   * CommunityComment findMany
   */
  export type CommunityCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * Filter, which CommunityComments to fetch.
    **/
    where?: CommunityCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityComments to fetch.
    **/
    orderBy?: Enumerable<CommunityCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityComments.
    **/
    cursor?: CommunityCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityComments.
    **/
    skip?: number
    distinct?: Enumerable<CommunityCommentScalarFieldEnum>
  }


  /**
   * CommunityComment create
   */
  export type CommunityCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * The data needed to create a CommunityComment.
    **/
    data: XOR<CommunityCommentCreateInput, CommunityCommentUncheckedCreateInput>
  }


  /**
   * CommunityComment createMany
   */
  export type CommunityCommentCreateManyArgs = {
    data: Enumerable<CommunityCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommunityComment update
   */
  export type CommunityCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * The data needed to update a CommunityComment.
    **/
    data: XOR<CommunityCommentUpdateInput, CommunityCommentUncheckedUpdateInput>
    /**
     * Choose, which CommunityComment to update.
    **/
    where: CommunityCommentWhereUniqueInput
  }


  /**
   * CommunityComment updateMany
   */
  export type CommunityCommentUpdateManyArgs = {
    data: XOR<CommunityCommentUpdateManyMutationInput, CommunityCommentUncheckedUpdateManyInput>
    where?: CommunityCommentWhereInput
  }


  /**
   * CommunityComment upsert
   */
  export type CommunityCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * The filter to search for the CommunityComment to update in case it exists.
    **/
    where: CommunityCommentWhereUniqueInput
    /**
     * In case the CommunityComment found by the `where` argument doesn't exist, create a new CommunityComment with this data.
    **/
    create: XOR<CommunityCommentCreateInput, CommunityCommentUncheckedCreateInput>
    /**
     * In case the CommunityComment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityCommentUpdateInput, CommunityCommentUncheckedUpdateInput>
  }


  /**
   * CommunityComment delete
   */
  export type CommunityCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
    /**
     * Filter which CommunityComment to delete.
    **/
    where: CommunityCommentWhereUniqueInput
  }


  /**
   * CommunityComment deleteMany
   */
  export type CommunityCommentDeleteManyArgs = {
    where?: CommunityCommentWhereInput
  }


  /**
   * CommunityComment without action
   */
  export type CommunityCommentArgs = {
    /**
     * Select specific fields to fetch from the CommunityComment
    **/
    select?: CommunityCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityCommentInclude | null
  }



  /**
   * Model CommunityPost
   */


  export type AggregateCommunityPost = {
    count: CommunityPostCountAggregateOutputType | null
    avg: CommunityPostAvgAggregateOutputType | null
    sum: CommunityPostSumAggregateOutputType | null
    min: CommunityPostMinAggregateOutputType | null
    max: CommunityPostMaxAggregateOutputType | null
  }

  export type CommunityPostAvgAggregateOutputType = {
    id: number
    boardId: number
    userId: number
    likesCount: number
    commentsCount: number
    bookmarksCount: number
  }

  export type CommunityPostSumAggregateOutputType = {
    id: number
    boardId: number
    userId: number
    likesCount: number
    commentsCount: number
    bookmarksCount: number
  }

  export type CommunityPostMinAggregateOutputType = {
    id: number
    boardId: number
    userId: number
    title: string | null
    body: string | null
    randomNickname: string | null
    likesCount: number
    commentsCount: number
    bookmarksCount: number
    postedAt: Date | null
    editedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunityPostMaxAggregateOutputType = {
    id: number
    boardId: number
    userId: number
    title: string | null
    body: string | null
    randomNickname: string | null
    likesCount: number
    commentsCount: number
    bookmarksCount: number
    postedAt: Date | null
    editedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunityPostCountAggregateOutputType = {
    id: number
    boardId: number
    userId: number
    title: number | null
    body: number | null
    randomNickname: number | null
    likesCount: number
    commentsCount: number
    bookmarksCount: number
    postedAt: number | null
    editedAt: number | null
    isDeleted: number | null
    _all: number
  }


  export type CommunityPostAvgAggregateInputType = {
    id?: true
    boardId?: true
    userId?: true
    likesCount?: true
    commentsCount?: true
    bookmarksCount?: true
  }

  export type CommunityPostSumAggregateInputType = {
    id?: true
    boardId?: true
    userId?: true
    likesCount?: true
    commentsCount?: true
    bookmarksCount?: true
  }

  export type CommunityPostMinAggregateInputType = {
    id?: true
    boardId?: true
    userId?: true
    title?: true
    body?: true
    randomNickname?: true
    likesCount?: true
    commentsCount?: true
    bookmarksCount?: true
    postedAt?: true
    editedAt?: true
    isDeleted?: true
  }

  export type CommunityPostMaxAggregateInputType = {
    id?: true
    boardId?: true
    userId?: true
    title?: true
    body?: true
    randomNickname?: true
    likesCount?: true
    commentsCount?: true
    bookmarksCount?: true
    postedAt?: true
    editedAt?: true
    isDeleted?: true
  }

  export type CommunityPostCountAggregateInputType = {
    id?: true
    boardId?: true
    userId?: true
    title?: true
    body?: true
    randomNickname?: true
    likesCount?: true
    commentsCount?: true
    bookmarksCount?: true
    postedAt?: true
    editedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type CommunityPostAggregateArgs = {
    /**
     * Filter which CommunityPost to aggregate.
    **/
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
    **/
    orderBy?: Enumerable<CommunityPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityPosts
    **/
    count?: true | CommunityPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityPostMaxAggregateInputType
  }

  export type GetCommunityPostAggregateType<T extends CommunityPostAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityPost]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityPost[P]>
      : GetScalarType<T[P], AggregateCommunityPost[P]>
  }


    
    
  export type CommunityPostGroupByArgs = {
    where?: CommunityPostWhereInput
    orderBy?: Enumerable<CommunityPostOrderByInput>
    by: Array<CommunityPostScalarFieldEnum>
    having?: CommunityPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommunityPostCountAggregateInputType | true
    avg?: CommunityPostAvgAggregateInputType
    sum?: CommunityPostSumAggregateInputType
    min?: CommunityPostMinAggregateInputType
    max?: CommunityPostMaxAggregateInputType
  }


  export type CommunityPostGroupByOutputType = {
    id: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount: number
    commentsCount: number
    bookmarksCount: number
    postedAt: Date
    editedAt: Date | null
    isDeleted: boolean
    count: CommunityPostCountAggregateOutputType | null
    avg: CommunityPostAvgAggregateOutputType | null
    sum: CommunityPostSumAggregateOutputType | null
    min: CommunityPostMinAggregateOutputType | null
    max: CommunityPostMaxAggregateOutputType | null
  }

  type GetCommunityPostGroupByPayload<T extends CommunityPostGroupByArgs> = Promise<Array<
    PickArray<CommunityPostGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommunityPostGroupByOutputType))]: GetScalarType<T[P], CommunityPostGroupByOutputType[P]>
    }
  >>
    

  export type CommunityPostSelect = {
    id?: boolean
    boardId?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    randomNickname?: boolean
    likesCount?: boolean
    commentsCount?: boolean
    bookmarksCount?: boolean
    postedAt?: boolean
    editedAt?: boolean
    isDeleted?: boolean
    communityBoard?: boolean | CommunityBoardArgs
    user?: boolean | UserArgs
    communityComments?: boolean | CommunityCommentFindManyArgs
    communityPostBookmarks?: boolean | CommunityPostBookmarkFindManyArgs
    communityPostLikes?: boolean | CommunityPostLikeFindManyArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    reportPosts?: boolean | ReportPostFindManyArgs
  }

  export type CommunityPostInclude = {
    communityBoard?: boolean | CommunityBoardArgs
    user?: boolean | UserArgs
    communityComments?: boolean | CommunityCommentFindManyArgs
    communityPostBookmarks?: boolean | CommunityPostBookmarkFindManyArgs
    communityPostLikes?: boolean | CommunityPostLikeFindManyArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    reportPosts?: boolean | ReportPostFindManyArgs
  }

  export type CommunityPostGetPayload<
    S extends boolean | null | undefined | CommunityPostArgs,
    U = keyof S
      > = S extends true
        ? CommunityPost
    : S extends undefined
    ? never
    : S extends CommunityPostArgs | CommunityPostFindManyArgs
    ?'include' extends U
    ? CommunityPost  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityBoard'
        ? CommunityBoardGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'communityComments'
        ? Array < CommunityCommentGetPayload<S['include'][P]>>  :
        P extends 'communityPostBookmarks'
        ? Array < CommunityPostBookmarkGetPayload<S['include'][P]>>  :
        P extends 'communityPostLikes'
        ? Array < CommunityPostLikeGetPayload<S['include'][P]>>  :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['include'][P]>>  :
        P extends 'reportPosts'
        ? Array < ReportPostGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityPost ?CommunityPost [P]
  : 
          P extends 'communityBoard'
        ? CommunityBoardGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'communityComments'
        ? Array < CommunityCommentGetPayload<S['select'][P]>>  :
        P extends 'communityPostBookmarks'
        ? Array < CommunityPostBookmarkGetPayload<S['select'][P]>>  :
        P extends 'communityPostLikes'
        ? Array < CommunityPostLikeGetPayload<S['select'][P]>>  :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['select'][P]>>  :
        P extends 'reportPosts'
        ? Array < ReportPostGetPayload<S['select'][P]>>  : never
  } 
    : CommunityPost
  : CommunityPost


  type CommunityPostCountArgs = Merge<
    Omit<CommunityPostFindManyArgs, 'select' | 'include'> & {
      select?: CommunityPostCountAggregateInputType | true
    }
  >

  export interface CommunityPostDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityPost that matches the filter.
     * @param {CommunityPostFindUniqueArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityPost'> extends True ? CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>

    /**
     * Find the first CommunityPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostFindFirstArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityPost'> extends True ? CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>

    /**
     * Find zero or more CommunityPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityPosts
     * const communityPosts = await prisma.communityPost.findMany()
     * 
     * // Get first 10 CommunityPosts
     * const communityPosts = await prisma.communityPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityPostWithIdOnly = await prisma.communityPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityPostFindManyArgs>(
      args?: SelectSubset<T, CommunityPostFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommunityPost>>, PrismaPromise<Array<CommunityPostGetPayload<T>>>>

    /**
     * Create a CommunityPost.
     * @param {CommunityPostCreateArgs} args - Arguments to create a CommunityPost.
     * @example
     * // Create one CommunityPost
     * const CommunityPost = await prisma.communityPost.create({
     *   data: {
     *     // ... data to create a CommunityPost
     *   }
     * })
     * 
    **/
    create<T extends CommunityPostCreateArgs>(
      args: SelectSubset<T, CommunityPostCreateArgs>
    ): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>>

    /**
     * Create many CommunityPosts.
     *     @param {CommunityPostCreateManyArgs} args - Arguments to create many CommunityPosts.
     *     @example
     *     // Create many CommunityPosts
     *     const communityPost = await prisma.communityPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityPostCreateManyArgs>(
      args?: SelectSubset<T, CommunityPostCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityPost.
     * @param {CommunityPostDeleteArgs} args - Arguments to delete one CommunityPost.
     * @example
     * // Delete one CommunityPost
     * const CommunityPost = await prisma.communityPost.delete({
     *   where: {
     *     // ... filter to delete one CommunityPost
     *   }
     * })
     * 
    **/
    delete<T extends CommunityPostDeleteArgs>(
      args: SelectSubset<T, CommunityPostDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>>

    /**
     * Update one CommunityPost.
     * @param {CommunityPostUpdateArgs} args - Arguments to update one CommunityPost.
     * @example
     * // Update one CommunityPost
     * const communityPost = await prisma.communityPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityPostUpdateArgs>(
      args: SelectSubset<T, CommunityPostUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>>

    /**
     * Delete zero or more CommunityPosts.
     * @param {CommunityPostDeleteManyArgs} args - Arguments to filter CommunityPosts to delete.
     * @example
     * // Delete a few CommunityPosts
     * const { count } = await prisma.communityPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityPostDeleteManyArgs>(
      args?: SelectSubset<T, CommunityPostDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityPosts
     * const communityPost = await prisma.communityPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityPostUpdateManyArgs>(
      args: SelectSubset<T, CommunityPostUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityPost.
     * @param {CommunityPostUpsertArgs} args - Arguments to update or create a CommunityPost.
     * @example
     * // Update or create a CommunityPost
     * const communityPost = await prisma.communityPost.upsert({
     *   create: {
     *     // ... data to create a CommunityPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityPost we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityPostUpsertArgs>(
      args: SelectSubset<T, CommunityPostUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost>, Prisma__CommunityPostClient<CommunityPostGetPayload<T>>>

    /**
     * Count the number of CommunityPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostCountArgs} args - Arguments to filter CommunityPosts to count.
     * @example
     * // Count the number of CommunityPosts
     * const count = await prisma.communityPost.count({
     *   where: {
     *     // ... the filter for the CommunityPosts we want to count
     *   }
     * })
    **/
    count<T extends CommunityPostCountArgs>(
      args?: Subset<T, CommunityPostCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityPostAggregateArgs>(args: Subset<T, CommunityPostAggregateArgs>): PrismaPromise<GetCommunityPostAggregateType<T>>

    /**
     * Group by CommunityPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityPostGroupByArgs['orderBy'] }
        : { orderBy?: CommunityPostGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityPostGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityPostClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityBoard<T extends CommunityBoardArgs = {}>(args?: Subset<T, CommunityBoardArgs>): CheckSelect<T, Prisma__CommunityBoardClient<CommunityBoard | null >, Prisma__CommunityBoardClient<CommunityBoardGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    communityComments<T extends CommunityCommentFindManyArgs = {}>(args?: Subset<T, CommunityCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityComment>>, PrismaPromise<Array<CommunityCommentGetPayload<T>>>>;

    communityPostBookmarks<T extends CommunityPostBookmarkFindManyArgs = {}>(args?: Subset<T, CommunityPostBookmarkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityPostBookmark>>, PrismaPromise<Array<CommunityPostBookmarkGetPayload<T>>>>;

    communityPostLikes<T extends CommunityPostLikeFindManyArgs = {}>(args?: Subset<T, CommunityPostLikeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityPostLike>>, PrismaPromise<Array<CommunityPostLikeGetPayload<T>>>>;

    communitySubcomments<T extends CommunitySubcommentFindManyArgs = {}>(args?: Subset<T, CommunitySubcommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunitySubcomment>>, PrismaPromise<Array<CommunitySubcommentGetPayload<T>>>>;

    reportPosts<T extends ReportPostFindManyArgs = {}>(args?: Subset<T, ReportPostFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReportPost>>, PrismaPromise<Array<ReportPostGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityPost findUnique
   */
  export type CommunityPostFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * Throw an Error if a CommunityPost can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPost to fetch.
    **/
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost findFirst
   */
  export type CommunityPostFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * Throw an Error if a CommunityPost can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPost to fetch.
    **/
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
    **/
    orderBy?: Enumerable<CommunityPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPosts.
    **/
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityPosts.
    **/
    distinct?: Enumerable<CommunityPostScalarFieldEnum>
  }


  /**
   * CommunityPost findMany
   */
  export type CommunityPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * Filter, which CommunityPosts to fetch.
    **/
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
    **/
    orderBy?: Enumerable<CommunityPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityPosts.
    **/
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
    **/
    skip?: number
    distinct?: Enumerable<CommunityPostScalarFieldEnum>
  }


  /**
   * CommunityPost create
   */
  export type CommunityPostCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * The data needed to create a CommunityPost.
    **/
    data: XOR<CommunityPostCreateInput, CommunityPostUncheckedCreateInput>
  }


  /**
   * CommunityPost createMany
   */
  export type CommunityPostCreateManyArgs = {
    data: Enumerable<CommunityPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommunityPost update
   */
  export type CommunityPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * The data needed to update a CommunityPost.
    **/
    data: XOR<CommunityPostUpdateInput, CommunityPostUncheckedUpdateInput>
    /**
     * Choose, which CommunityPost to update.
    **/
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost updateMany
   */
  export type CommunityPostUpdateManyArgs = {
    data: XOR<CommunityPostUpdateManyMutationInput, CommunityPostUncheckedUpdateManyInput>
    where?: CommunityPostWhereInput
  }


  /**
   * CommunityPost upsert
   */
  export type CommunityPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * The filter to search for the CommunityPost to update in case it exists.
    **/
    where: CommunityPostWhereUniqueInput
    /**
     * In case the CommunityPost found by the `where` argument doesn't exist, create a new CommunityPost with this data.
    **/
    create: XOR<CommunityPostCreateInput, CommunityPostUncheckedCreateInput>
    /**
     * In case the CommunityPost was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityPostUpdateInput, CommunityPostUncheckedUpdateInput>
  }


  /**
   * CommunityPost delete
   */
  export type CommunityPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
    /**
     * Filter which CommunityPost to delete.
    **/
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost deleteMany
   */
  export type CommunityPostDeleteManyArgs = {
    where?: CommunityPostWhereInput
  }


  /**
   * CommunityPost without action
   */
  export type CommunityPostArgs = {
    /**
     * Select specific fields to fetch from the CommunityPost
    **/
    select?: CommunityPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostInclude | null
  }



  /**
   * Model CommunityPostBookmark
   */


  export type AggregateCommunityPostBookmark = {
    count: CommunityPostBookmarkCountAggregateOutputType | null
    avg: CommunityPostBookmarkAvgAggregateOutputType | null
    sum: CommunityPostBookmarkSumAggregateOutputType | null
    min: CommunityPostBookmarkMinAggregateOutputType | null
    max: CommunityPostBookmarkMaxAggregateOutputType | null
  }

  export type CommunityPostBookmarkAvgAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostBookmarkSumAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostBookmarkMinAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostBookmarkMaxAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostBookmarkCountAggregateOutputType = {
    userId: number
    postId: number
    _all: number
  }


  export type CommunityPostBookmarkAvgAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostBookmarkSumAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostBookmarkMinAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostBookmarkMaxAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostBookmarkCountAggregateInputType = {
    userId?: true
    postId?: true
    _all?: true
  }

  export type CommunityPostBookmarkAggregateArgs = {
    /**
     * Filter which CommunityPostBookmark to aggregate.
    **/
    where?: CommunityPostBookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPostBookmarks to fetch.
    **/
    orderBy?: Enumerable<CommunityPostBookmarkOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityPostBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostBookmarks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostBookmarks.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityPostBookmarks
    **/
    count?: true | CommunityPostBookmarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityPostBookmarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityPostBookmarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityPostBookmarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityPostBookmarkMaxAggregateInputType
  }

  export type GetCommunityPostBookmarkAggregateType<T extends CommunityPostBookmarkAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityPostBookmark]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityPostBookmark[P]>
      : GetScalarType<T[P], AggregateCommunityPostBookmark[P]>
  }


    
    
  export type CommunityPostBookmarkGroupByArgs = {
    where?: CommunityPostBookmarkWhereInput
    orderBy?: Enumerable<CommunityPostBookmarkOrderByInput>
    by: Array<CommunityPostBookmarkScalarFieldEnum>
    having?: CommunityPostBookmarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommunityPostBookmarkCountAggregateInputType | true
    avg?: CommunityPostBookmarkAvgAggregateInputType
    sum?: CommunityPostBookmarkSumAggregateInputType
    min?: CommunityPostBookmarkMinAggregateInputType
    max?: CommunityPostBookmarkMaxAggregateInputType
  }


  export type CommunityPostBookmarkGroupByOutputType = {
    userId: number
    postId: number
    count: CommunityPostBookmarkCountAggregateOutputType | null
    avg: CommunityPostBookmarkAvgAggregateOutputType | null
    sum: CommunityPostBookmarkSumAggregateOutputType | null
    min: CommunityPostBookmarkMinAggregateOutputType | null
    max: CommunityPostBookmarkMaxAggregateOutputType | null
  }

  type GetCommunityPostBookmarkGroupByPayload<T extends CommunityPostBookmarkGroupByArgs> = Promise<Array<
    PickArray<CommunityPostBookmarkGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommunityPostBookmarkGroupByOutputType))]: GetScalarType<T[P], CommunityPostBookmarkGroupByOutputType[P]>
    }
  >>
    

  export type CommunityPostBookmarkSelect = {
    userId?: boolean
    postId?: boolean
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type CommunityPostBookmarkInclude = {
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type CommunityPostBookmarkGetPayload<
    S extends boolean | null | undefined | CommunityPostBookmarkArgs,
    U = keyof S
      > = S extends true
        ? CommunityPostBookmark
    : S extends undefined
    ? never
    : S extends CommunityPostBookmarkArgs | CommunityPostBookmarkFindManyArgs
    ?'include' extends U
    ? CommunityPostBookmark  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityPostBookmark ?CommunityPostBookmark [P]
  : 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : CommunityPostBookmark
  : CommunityPostBookmark


  type CommunityPostBookmarkCountArgs = Merge<
    Omit<CommunityPostBookmarkFindManyArgs, 'select' | 'include'> & {
      select?: CommunityPostBookmarkCountAggregateInputType | true
    }
  >

  export interface CommunityPostBookmarkDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityPostBookmark that matches the filter.
     * @param {CommunityPostBookmarkFindUniqueArgs} args - Arguments to find a CommunityPostBookmark
     * @example
     * // Get one CommunityPostBookmark
     * const communityPostBookmark = await prisma.communityPostBookmark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityPostBookmarkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityPostBookmarkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityPostBookmark'> extends True ? CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark | null >, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T> | null >>

    /**
     * Find the first CommunityPostBookmark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostBookmarkFindFirstArgs} args - Arguments to find a CommunityPostBookmark
     * @example
     * // Get one CommunityPostBookmark
     * const communityPostBookmark = await prisma.communityPostBookmark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityPostBookmarkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityPostBookmarkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityPostBookmark'> extends True ? CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark | null >, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T> | null >>

    /**
     * Find zero or more CommunityPostBookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostBookmarkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityPostBookmarks
     * const communityPostBookmarks = await prisma.communityPostBookmark.findMany()
     * 
     * // Get first 10 CommunityPostBookmarks
     * const communityPostBookmarks = await prisma.communityPostBookmark.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const communityPostBookmarkWithUserIdOnly = await prisma.communityPostBookmark.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CommunityPostBookmarkFindManyArgs>(
      args?: SelectSubset<T, CommunityPostBookmarkFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommunityPostBookmark>>, PrismaPromise<Array<CommunityPostBookmarkGetPayload<T>>>>

    /**
     * Create a CommunityPostBookmark.
     * @param {CommunityPostBookmarkCreateArgs} args - Arguments to create a CommunityPostBookmark.
     * @example
     * // Create one CommunityPostBookmark
     * const CommunityPostBookmark = await prisma.communityPostBookmark.create({
     *   data: {
     *     // ... data to create a CommunityPostBookmark
     *   }
     * })
     * 
    **/
    create<T extends CommunityPostBookmarkCreateArgs>(
      args: SelectSubset<T, CommunityPostBookmarkCreateArgs>
    ): CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>>

    /**
     * Create many CommunityPostBookmarks.
     *     @param {CommunityPostBookmarkCreateManyArgs} args - Arguments to create many CommunityPostBookmarks.
     *     @example
     *     // Create many CommunityPostBookmarks
     *     const communityPostBookmark = await prisma.communityPostBookmark.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityPostBookmarkCreateManyArgs>(
      args?: SelectSubset<T, CommunityPostBookmarkCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityPostBookmark.
     * @param {CommunityPostBookmarkDeleteArgs} args - Arguments to delete one CommunityPostBookmark.
     * @example
     * // Delete one CommunityPostBookmark
     * const CommunityPostBookmark = await prisma.communityPostBookmark.delete({
     *   where: {
     *     // ... filter to delete one CommunityPostBookmark
     *   }
     * })
     * 
    **/
    delete<T extends CommunityPostBookmarkDeleteArgs>(
      args: SelectSubset<T, CommunityPostBookmarkDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>>

    /**
     * Update one CommunityPostBookmark.
     * @param {CommunityPostBookmarkUpdateArgs} args - Arguments to update one CommunityPostBookmark.
     * @example
     * // Update one CommunityPostBookmark
     * const communityPostBookmark = await prisma.communityPostBookmark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityPostBookmarkUpdateArgs>(
      args: SelectSubset<T, CommunityPostBookmarkUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>>

    /**
     * Delete zero or more CommunityPostBookmarks.
     * @param {CommunityPostBookmarkDeleteManyArgs} args - Arguments to filter CommunityPostBookmarks to delete.
     * @example
     * // Delete a few CommunityPostBookmarks
     * const { count } = await prisma.communityPostBookmark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityPostBookmarkDeleteManyArgs>(
      args?: SelectSubset<T, CommunityPostBookmarkDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityPostBookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostBookmarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityPostBookmarks
     * const communityPostBookmark = await prisma.communityPostBookmark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityPostBookmarkUpdateManyArgs>(
      args: SelectSubset<T, CommunityPostBookmarkUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityPostBookmark.
     * @param {CommunityPostBookmarkUpsertArgs} args - Arguments to update or create a CommunityPostBookmark.
     * @example
     * // Update or create a CommunityPostBookmark
     * const communityPostBookmark = await prisma.communityPostBookmark.upsert({
     *   create: {
     *     // ... data to create a CommunityPostBookmark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityPostBookmark we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityPostBookmarkUpsertArgs>(
      args: SelectSubset<T, CommunityPostBookmarkUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityPostBookmarkClient<CommunityPostBookmark>, Prisma__CommunityPostBookmarkClient<CommunityPostBookmarkGetPayload<T>>>

    /**
     * Count the number of CommunityPostBookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostBookmarkCountArgs} args - Arguments to filter CommunityPostBookmarks to count.
     * @example
     * // Count the number of CommunityPostBookmarks
     * const count = await prisma.communityPostBookmark.count({
     *   where: {
     *     // ... the filter for the CommunityPostBookmarks we want to count
     *   }
     * })
    **/
    count<T extends CommunityPostBookmarkCountArgs>(
      args?: Subset<T, CommunityPostBookmarkCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityPostBookmarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityPostBookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostBookmarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityPostBookmarkAggregateArgs>(args: Subset<T, CommunityPostBookmarkAggregateArgs>): PrismaPromise<GetCommunityPostBookmarkAggregateType<T>>

    /**
     * Group by CommunityPostBookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostBookmarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityPostBookmarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityPostBookmarkGroupByArgs['orderBy'] }
        : { orderBy?: CommunityPostBookmarkGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityPostBookmarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityPostBookmarkGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityPostBookmark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityPostBookmarkClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityPost<T extends CommunityPostArgs = {}>(args?: Subset<T, CommunityPostArgs>): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityPostBookmark findUnique
   */
  export type CommunityPostBookmarkFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * Throw an Error if a CommunityPostBookmark can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPostBookmark to fetch.
    **/
    where: CommunityPostBookmarkWhereUniqueInput
  }


  /**
   * CommunityPostBookmark findFirst
   */
  export type CommunityPostBookmarkFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * Throw an Error if a CommunityPostBookmark can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPostBookmark to fetch.
    **/
    where?: CommunityPostBookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPostBookmarks to fetch.
    **/
    orderBy?: Enumerable<CommunityPostBookmarkOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPostBookmarks.
    **/
    cursor?: CommunityPostBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostBookmarks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostBookmarks.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityPostBookmarks.
    **/
    distinct?: Enumerable<CommunityPostBookmarkScalarFieldEnum>
  }


  /**
   * CommunityPostBookmark findMany
   */
  export type CommunityPostBookmarkFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * Filter, which CommunityPostBookmarks to fetch.
    **/
    where?: CommunityPostBookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPostBookmarks to fetch.
    **/
    orderBy?: Enumerable<CommunityPostBookmarkOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityPostBookmarks.
    **/
    cursor?: CommunityPostBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostBookmarks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostBookmarks.
    **/
    skip?: number
    distinct?: Enumerable<CommunityPostBookmarkScalarFieldEnum>
  }


  /**
   * CommunityPostBookmark create
   */
  export type CommunityPostBookmarkCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * The data needed to create a CommunityPostBookmark.
    **/
    data: XOR<CommunityPostBookmarkCreateInput, CommunityPostBookmarkUncheckedCreateInput>
  }


  /**
   * CommunityPostBookmark createMany
   */
  export type CommunityPostBookmarkCreateManyArgs = {
    data: Enumerable<CommunityPostBookmarkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommunityPostBookmark update
   */
  export type CommunityPostBookmarkUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * The data needed to update a CommunityPostBookmark.
    **/
    data: XOR<CommunityPostBookmarkUpdateInput, CommunityPostBookmarkUncheckedUpdateInput>
    /**
     * Choose, which CommunityPostBookmark to update.
    **/
    where: CommunityPostBookmarkWhereUniqueInput
  }


  /**
   * CommunityPostBookmark updateMany
   */
  export type CommunityPostBookmarkUpdateManyArgs = {
    data: XOR<CommunityPostBookmarkUpdateManyMutationInput, CommunityPostBookmarkUncheckedUpdateManyInput>
    where?: CommunityPostBookmarkWhereInput
  }


  /**
   * CommunityPostBookmark upsert
   */
  export type CommunityPostBookmarkUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * The filter to search for the CommunityPostBookmark to update in case it exists.
    **/
    where: CommunityPostBookmarkWhereUniqueInput
    /**
     * In case the CommunityPostBookmark found by the `where` argument doesn't exist, create a new CommunityPostBookmark with this data.
    **/
    create: XOR<CommunityPostBookmarkCreateInput, CommunityPostBookmarkUncheckedCreateInput>
    /**
     * In case the CommunityPostBookmark was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityPostBookmarkUpdateInput, CommunityPostBookmarkUncheckedUpdateInput>
  }


  /**
   * CommunityPostBookmark delete
   */
  export type CommunityPostBookmarkDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
    /**
     * Filter which CommunityPostBookmark to delete.
    **/
    where: CommunityPostBookmarkWhereUniqueInput
  }


  /**
   * CommunityPostBookmark deleteMany
   */
  export type CommunityPostBookmarkDeleteManyArgs = {
    where?: CommunityPostBookmarkWhereInput
  }


  /**
   * CommunityPostBookmark without action
   */
  export type CommunityPostBookmarkArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostBookmark
    **/
    select?: CommunityPostBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostBookmarkInclude | null
  }



  /**
   * Model CommunityPostLike
   */


  export type AggregateCommunityPostLike = {
    count: CommunityPostLikeCountAggregateOutputType | null
    avg: CommunityPostLikeAvgAggregateOutputType | null
    sum: CommunityPostLikeSumAggregateOutputType | null
    min: CommunityPostLikeMinAggregateOutputType | null
    max: CommunityPostLikeMaxAggregateOutputType | null
  }

  export type CommunityPostLikeAvgAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeSumAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeMinAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeMaxAggregateOutputType = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeCountAggregateOutputType = {
    userId: number
    postId: number
    _all: number
  }


  export type CommunityPostLikeAvgAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostLikeSumAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostLikeMinAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostLikeMaxAggregateInputType = {
    userId?: true
    postId?: true
  }

  export type CommunityPostLikeCountAggregateInputType = {
    userId?: true
    postId?: true
    _all?: true
  }

  export type CommunityPostLikeAggregateArgs = {
    /**
     * Filter which CommunityPostLike to aggregate.
    **/
    where?: CommunityPostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPostLikes to fetch.
    **/
    orderBy?: Enumerable<CommunityPostLikeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunityPostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostLikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostLikes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityPostLikes
    **/
    count?: true | CommunityPostLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunityPostLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunityPostLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunityPostLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunityPostLikeMaxAggregateInputType
  }

  export type GetCommunityPostLikeAggregateType<T extends CommunityPostLikeAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunityPostLike]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityPostLike[P]>
      : GetScalarType<T[P], AggregateCommunityPostLike[P]>
  }


    
    
  export type CommunityPostLikeGroupByArgs = {
    where?: CommunityPostLikeWhereInput
    orderBy?: Enumerable<CommunityPostLikeOrderByInput>
    by: Array<CommunityPostLikeScalarFieldEnum>
    having?: CommunityPostLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommunityPostLikeCountAggregateInputType | true
    avg?: CommunityPostLikeAvgAggregateInputType
    sum?: CommunityPostLikeSumAggregateInputType
    min?: CommunityPostLikeMinAggregateInputType
    max?: CommunityPostLikeMaxAggregateInputType
  }


  export type CommunityPostLikeGroupByOutputType = {
    userId: number
    postId: number
    count: CommunityPostLikeCountAggregateOutputType | null
    avg: CommunityPostLikeAvgAggregateOutputType | null
    sum: CommunityPostLikeSumAggregateOutputType | null
    min: CommunityPostLikeMinAggregateOutputType | null
    max: CommunityPostLikeMaxAggregateOutputType | null
  }

  type GetCommunityPostLikeGroupByPayload<T extends CommunityPostLikeGroupByArgs> = Promise<Array<
    PickArray<CommunityPostLikeGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommunityPostLikeGroupByOutputType))]: GetScalarType<T[P], CommunityPostLikeGroupByOutputType[P]>
    }
  >>
    

  export type CommunityPostLikeSelect = {
    userId?: boolean
    postId?: boolean
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type CommunityPostLikeInclude = {
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type CommunityPostLikeGetPayload<
    S extends boolean | null | undefined | CommunityPostLikeArgs,
    U = keyof S
      > = S extends true
        ? CommunityPostLike
    : S extends undefined
    ? never
    : S extends CommunityPostLikeArgs | CommunityPostLikeFindManyArgs
    ?'include' extends U
    ? CommunityPostLike  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunityPostLike ?CommunityPostLike [P]
  : 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : CommunityPostLike
  : CommunityPostLike


  type CommunityPostLikeCountArgs = Merge<
    Omit<CommunityPostLikeFindManyArgs, 'select' | 'include'> & {
      select?: CommunityPostLikeCountAggregateInputType | true
    }
  >

  export interface CommunityPostLikeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunityPostLike that matches the filter.
     * @param {CommunityPostLikeFindUniqueArgs} args - Arguments to find a CommunityPostLike
     * @example
     * // Get one CommunityPostLike
     * const communityPostLike = await prisma.communityPostLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityPostLikeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityPostLikeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityPostLike'> extends True ? CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike | null >, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T> | null >>

    /**
     * Find the first CommunityPostLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostLikeFindFirstArgs} args - Arguments to find a CommunityPostLike
     * @example
     * // Get one CommunityPostLike
     * const communityPostLike = await prisma.communityPostLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityPostLikeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityPostLikeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityPostLike'> extends True ? CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>> : CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike | null >, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T> | null >>

    /**
     * Find zero or more CommunityPostLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostLikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityPostLikes
     * const communityPostLikes = await prisma.communityPostLike.findMany()
     * 
     * // Get first 10 CommunityPostLikes
     * const communityPostLikes = await prisma.communityPostLike.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const communityPostLikeWithUserIdOnly = await prisma.communityPostLike.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CommunityPostLikeFindManyArgs>(
      args?: SelectSubset<T, CommunityPostLikeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommunityPostLike>>, PrismaPromise<Array<CommunityPostLikeGetPayload<T>>>>

    /**
     * Create a CommunityPostLike.
     * @param {CommunityPostLikeCreateArgs} args - Arguments to create a CommunityPostLike.
     * @example
     * // Create one CommunityPostLike
     * const CommunityPostLike = await prisma.communityPostLike.create({
     *   data: {
     *     // ... data to create a CommunityPostLike
     *   }
     * })
     * 
    **/
    create<T extends CommunityPostLikeCreateArgs>(
      args: SelectSubset<T, CommunityPostLikeCreateArgs>
    ): CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>>

    /**
     * Create many CommunityPostLikes.
     *     @param {CommunityPostLikeCreateManyArgs} args - Arguments to create many CommunityPostLikes.
     *     @example
     *     // Create many CommunityPostLikes
     *     const communityPostLike = await prisma.communityPostLike.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityPostLikeCreateManyArgs>(
      args?: SelectSubset<T, CommunityPostLikeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityPostLike.
     * @param {CommunityPostLikeDeleteArgs} args - Arguments to delete one CommunityPostLike.
     * @example
     * // Delete one CommunityPostLike
     * const CommunityPostLike = await prisma.communityPostLike.delete({
     *   where: {
     *     // ... filter to delete one CommunityPostLike
     *   }
     * })
     * 
    **/
    delete<T extends CommunityPostLikeDeleteArgs>(
      args: SelectSubset<T, CommunityPostLikeDeleteArgs>
    ): CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>>

    /**
     * Update one CommunityPostLike.
     * @param {CommunityPostLikeUpdateArgs} args - Arguments to update one CommunityPostLike.
     * @example
     * // Update one CommunityPostLike
     * const communityPostLike = await prisma.communityPostLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityPostLikeUpdateArgs>(
      args: SelectSubset<T, CommunityPostLikeUpdateArgs>
    ): CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>>

    /**
     * Delete zero or more CommunityPostLikes.
     * @param {CommunityPostLikeDeleteManyArgs} args - Arguments to filter CommunityPostLikes to delete.
     * @example
     * // Delete a few CommunityPostLikes
     * const { count } = await prisma.communityPostLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityPostLikeDeleteManyArgs>(
      args?: SelectSubset<T, CommunityPostLikeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityPostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityPostLikes
     * const communityPostLike = await prisma.communityPostLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityPostLikeUpdateManyArgs>(
      args: SelectSubset<T, CommunityPostLikeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityPostLike.
     * @param {CommunityPostLikeUpsertArgs} args - Arguments to update or create a CommunityPostLike.
     * @example
     * // Update or create a CommunityPostLike
     * const communityPostLike = await prisma.communityPostLike.upsert({
     *   create: {
     *     // ... data to create a CommunityPostLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityPostLike we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityPostLikeUpsertArgs>(
      args: SelectSubset<T, CommunityPostLikeUpsertArgs>
    ): CheckSelect<T, Prisma__CommunityPostLikeClient<CommunityPostLike>, Prisma__CommunityPostLikeClient<CommunityPostLikeGetPayload<T>>>

    /**
     * Count the number of CommunityPostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostLikeCountArgs} args - Arguments to filter CommunityPostLikes to count.
     * @example
     * // Count the number of CommunityPostLikes
     * const count = await prisma.communityPostLike.count({
     *   where: {
     *     // ... the filter for the CommunityPostLikes we want to count
     *   }
     * })
    **/
    count<T extends CommunityPostLikeCountArgs>(
      args?: Subset<T, CommunityPostLikeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityPostLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityPostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityPostLikeAggregateArgs>(args: Subset<T, CommunityPostLikeAggregateArgs>): PrismaPromise<GetCommunityPostLikeAggregateType<T>>

    /**
     * Group by CommunityPostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityPostLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityPostLikeGroupByArgs['orderBy'] }
        : { orderBy?: CommunityPostLikeGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityPostLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityPostLikeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityPostLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityPostLikeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityPost<T extends CommunityPostArgs = {}>(args?: Subset<T, CommunityPostArgs>): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunityPostLike findUnique
   */
  export type CommunityPostLikeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * Throw an Error if a CommunityPostLike can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPostLike to fetch.
    **/
    where: CommunityPostLikeWhereUniqueInput
  }


  /**
   * CommunityPostLike findFirst
   */
  export type CommunityPostLikeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * Throw an Error if a CommunityPostLike can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunityPostLike to fetch.
    **/
    where?: CommunityPostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPostLikes to fetch.
    **/
    orderBy?: Enumerable<CommunityPostLikeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPostLikes.
    **/
    cursor?: CommunityPostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostLikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostLikes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityPostLikes.
    **/
    distinct?: Enumerable<CommunityPostLikeScalarFieldEnum>
  }


  /**
   * CommunityPostLike findMany
   */
  export type CommunityPostLikeFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * Filter, which CommunityPostLikes to fetch.
    **/
    where?: CommunityPostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPostLikes to fetch.
    **/
    orderBy?: Enumerable<CommunityPostLikeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityPostLikes.
    **/
    cursor?: CommunityPostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPostLikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPostLikes.
    **/
    skip?: number
    distinct?: Enumerable<CommunityPostLikeScalarFieldEnum>
  }


  /**
   * CommunityPostLike create
   */
  export type CommunityPostLikeCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * The data needed to create a CommunityPostLike.
    **/
    data: XOR<CommunityPostLikeCreateInput, CommunityPostLikeUncheckedCreateInput>
  }


  /**
   * CommunityPostLike createMany
   */
  export type CommunityPostLikeCreateManyArgs = {
    data: Enumerable<CommunityPostLikeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommunityPostLike update
   */
  export type CommunityPostLikeUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * The data needed to update a CommunityPostLike.
    **/
    data: XOR<CommunityPostLikeUpdateInput, CommunityPostLikeUncheckedUpdateInput>
    /**
     * Choose, which CommunityPostLike to update.
    **/
    where: CommunityPostLikeWhereUniqueInput
  }


  /**
   * CommunityPostLike updateMany
   */
  export type CommunityPostLikeUpdateManyArgs = {
    data: XOR<CommunityPostLikeUpdateManyMutationInput, CommunityPostLikeUncheckedUpdateManyInput>
    where?: CommunityPostLikeWhereInput
  }


  /**
   * CommunityPostLike upsert
   */
  export type CommunityPostLikeUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * The filter to search for the CommunityPostLike to update in case it exists.
    **/
    where: CommunityPostLikeWhereUniqueInput
    /**
     * In case the CommunityPostLike found by the `where` argument doesn't exist, create a new CommunityPostLike with this data.
    **/
    create: XOR<CommunityPostLikeCreateInput, CommunityPostLikeUncheckedCreateInput>
    /**
     * In case the CommunityPostLike was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunityPostLikeUpdateInput, CommunityPostLikeUncheckedUpdateInput>
  }


  /**
   * CommunityPostLike delete
   */
  export type CommunityPostLikeDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
    /**
     * Filter which CommunityPostLike to delete.
    **/
    where: CommunityPostLikeWhereUniqueInput
  }


  /**
   * CommunityPostLike deleteMany
   */
  export type CommunityPostLikeDeleteManyArgs = {
    where?: CommunityPostLikeWhereInput
  }


  /**
   * CommunityPostLike without action
   */
  export type CommunityPostLikeArgs = {
    /**
     * Select specific fields to fetch from the CommunityPostLike
    **/
    select?: CommunityPostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunityPostLikeInclude | null
  }



  /**
   * Model CommunitySubcomment
   */


  export type AggregateCommunitySubcomment = {
    count: CommunitySubcommentCountAggregateOutputType | null
    avg: CommunitySubcommentAvgAggregateOutputType | null
    sum: CommunitySubcommentSumAggregateOutputType | null
    min: CommunitySubcommentMinAggregateOutputType | null
    max: CommunitySubcommentMaxAggregateOutputType | null
  }

  export type CommunitySubcommentAvgAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
  }

  export type CommunitySubcommentSumAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
  }

  export type CommunitySubcommentMinAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
    randomNickname: string | null
    body: string | null
    subcommentedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunitySubcommentMaxAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
    randomNickname: string | null
    body: string | null
    subcommentedAt: Date | null
    isDeleted: boolean | null
  }

  export type CommunitySubcommentCountAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
    randomNickname: number | null
    body: number | null
    subcommentedAt: number | null
    isDeleted: number | null
    _all: number
  }


  export type CommunitySubcommentAvgAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
  }

  export type CommunitySubcommentSumAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
  }

  export type CommunitySubcommentMinAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    randomNickname?: true
    body?: true
    subcommentedAt?: true
    isDeleted?: true
  }

  export type CommunitySubcommentMaxAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    randomNickname?: true
    body?: true
    subcommentedAt?: true
    isDeleted?: true
  }

  export type CommunitySubcommentCountAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    randomNickname?: true
    body?: true
    subcommentedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type CommunitySubcommentAggregateArgs = {
    /**
     * Filter which CommunitySubcomment to aggregate.
    **/
    where?: CommunitySubcommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunitySubcomments to fetch.
    **/
    orderBy?: Enumerable<CommunitySubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommunitySubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunitySubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunitySubcomments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunitySubcomments
    **/
    count?: true | CommunitySubcommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommunitySubcommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommunitySubcommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommunitySubcommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommunitySubcommentMaxAggregateInputType
  }

  export type GetCommunitySubcommentAggregateType<T extends CommunitySubcommentAggregateArgs> = {
    [P in keyof T & keyof AggregateCommunitySubcomment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunitySubcomment[P]>
      : GetScalarType<T[P], AggregateCommunitySubcomment[P]>
  }


    
    
  export type CommunitySubcommentGroupByArgs = {
    where?: CommunitySubcommentWhereInput
    orderBy?: Enumerable<CommunitySubcommentOrderByInput>
    by: Array<CommunitySubcommentScalarFieldEnum>
    having?: CommunitySubcommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommunitySubcommentCountAggregateInputType | true
    avg?: CommunitySubcommentAvgAggregateInputType
    sum?: CommunitySubcommentSumAggregateInputType
    min?: CommunitySubcommentMinAggregateInputType
    max?: CommunitySubcommentMaxAggregateInputType
  }


  export type CommunitySubcommentGroupByOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
    randomNickname: string
    body: string
    subcommentedAt: Date
    isDeleted: boolean
    count: CommunitySubcommentCountAggregateOutputType | null
    avg: CommunitySubcommentAvgAggregateOutputType | null
    sum: CommunitySubcommentSumAggregateOutputType | null
    min: CommunitySubcommentMinAggregateOutputType | null
    max: CommunitySubcommentMaxAggregateOutputType | null
  }

  type GetCommunitySubcommentGroupByPayload<T extends CommunitySubcommentGroupByArgs> = Promise<Array<
    PickArray<CommunitySubcommentGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommunitySubcommentGroupByOutputType))]: GetScalarType<T[P], CommunitySubcommentGroupByOutputType[P]>
    }
  >>
    

  export type CommunitySubcommentSelect = {
    id?: boolean
    userId?: boolean
    postId?: boolean
    commentId?: boolean
    randomNickname?: boolean
    body?: boolean
    subcommentedAt?: boolean
    isDeleted?: boolean
    communityComment?: boolean | CommunityCommentArgs
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
    reportSubcomments?: boolean | ReportSubcommentFindManyArgs
  }

  export type CommunitySubcommentInclude = {
    communityComment?: boolean | CommunityCommentArgs
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
    reportSubcomments?: boolean | ReportSubcommentFindManyArgs
  }

  export type CommunitySubcommentGetPayload<
    S extends boolean | null | undefined | CommunitySubcommentArgs,
    U = keyof S
      > = S extends true
        ? CommunitySubcomment
    : S extends undefined
    ? never
    : S extends CommunitySubcommentArgs | CommunitySubcommentFindManyArgs
    ?'include' extends U
    ? CommunitySubcomment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityComment'
        ? CommunityCommentGetPayload<S['include'][P]> :
        P extends 'communityPost'
        ? CommunityPostGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'reportSubcomments'
        ? Array < ReportSubcommentGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommunitySubcomment ?CommunitySubcomment [P]
  : 
          P extends 'communityComment'
        ? CommunityCommentGetPayload<S['select'][P]> :
        P extends 'communityPost'
        ? CommunityPostGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'reportSubcomments'
        ? Array < ReportSubcommentGetPayload<S['select'][P]>>  : never
  } 
    : CommunitySubcomment
  : CommunitySubcomment


  type CommunitySubcommentCountArgs = Merge<
    Omit<CommunitySubcommentFindManyArgs, 'select' | 'include'> & {
      select?: CommunitySubcommentCountAggregateInputType | true
    }
  >

  export interface CommunitySubcommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommunitySubcomment that matches the filter.
     * @param {CommunitySubcommentFindUniqueArgs} args - Arguments to find a CommunitySubcomment
     * @example
     * // Get one CommunitySubcomment
     * const communitySubcomment = await prisma.communitySubcomment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunitySubcommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunitySubcommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunitySubcomment'> extends True ? CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>> : CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment | null >, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T> | null >>

    /**
     * Find the first CommunitySubcomment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunitySubcommentFindFirstArgs} args - Arguments to find a CommunitySubcomment
     * @example
     * // Get one CommunitySubcomment
     * const communitySubcomment = await prisma.communitySubcomment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunitySubcommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunitySubcommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunitySubcomment'> extends True ? CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>> : CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment | null >, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T> | null >>

    /**
     * Find zero or more CommunitySubcomments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunitySubcommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunitySubcomments
     * const communitySubcomments = await prisma.communitySubcomment.findMany()
     * 
     * // Get first 10 CommunitySubcomments
     * const communitySubcomments = await prisma.communitySubcomment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communitySubcommentWithIdOnly = await prisma.communitySubcomment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunitySubcommentFindManyArgs>(
      args?: SelectSubset<T, CommunitySubcommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommunitySubcomment>>, PrismaPromise<Array<CommunitySubcommentGetPayload<T>>>>

    /**
     * Create a CommunitySubcomment.
     * @param {CommunitySubcommentCreateArgs} args - Arguments to create a CommunitySubcomment.
     * @example
     * // Create one CommunitySubcomment
     * const CommunitySubcomment = await prisma.communitySubcomment.create({
     *   data: {
     *     // ... data to create a CommunitySubcomment
     *   }
     * })
     * 
    **/
    create<T extends CommunitySubcommentCreateArgs>(
      args: SelectSubset<T, CommunitySubcommentCreateArgs>
    ): CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>>

    /**
     * Create many CommunitySubcomments.
     *     @param {CommunitySubcommentCreateManyArgs} args - Arguments to create many CommunitySubcomments.
     *     @example
     *     // Create many CommunitySubcomments
     *     const communitySubcomment = await prisma.communitySubcomment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunitySubcommentCreateManyArgs>(
      args?: SelectSubset<T, CommunitySubcommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommunitySubcomment.
     * @param {CommunitySubcommentDeleteArgs} args - Arguments to delete one CommunitySubcomment.
     * @example
     * // Delete one CommunitySubcomment
     * const CommunitySubcomment = await prisma.communitySubcomment.delete({
     *   where: {
     *     // ... filter to delete one CommunitySubcomment
     *   }
     * })
     * 
    **/
    delete<T extends CommunitySubcommentDeleteArgs>(
      args: SelectSubset<T, CommunitySubcommentDeleteArgs>
    ): CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>>

    /**
     * Update one CommunitySubcomment.
     * @param {CommunitySubcommentUpdateArgs} args - Arguments to update one CommunitySubcomment.
     * @example
     * // Update one CommunitySubcomment
     * const communitySubcomment = await prisma.communitySubcomment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunitySubcommentUpdateArgs>(
      args: SelectSubset<T, CommunitySubcommentUpdateArgs>
    ): CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>>

    /**
     * Delete zero or more CommunitySubcomments.
     * @param {CommunitySubcommentDeleteManyArgs} args - Arguments to filter CommunitySubcomments to delete.
     * @example
     * // Delete a few CommunitySubcomments
     * const { count } = await prisma.communitySubcomment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunitySubcommentDeleteManyArgs>(
      args?: SelectSubset<T, CommunitySubcommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunitySubcomments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunitySubcommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunitySubcomments
     * const communitySubcomment = await prisma.communitySubcomment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunitySubcommentUpdateManyArgs>(
      args: SelectSubset<T, CommunitySubcommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunitySubcomment.
     * @param {CommunitySubcommentUpsertArgs} args - Arguments to update or create a CommunitySubcomment.
     * @example
     * // Update or create a CommunitySubcomment
     * const communitySubcomment = await prisma.communitySubcomment.upsert({
     *   create: {
     *     // ... data to create a CommunitySubcomment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunitySubcomment we want to update
     *   }
     * })
    **/
    upsert<T extends CommunitySubcommentUpsertArgs>(
      args: SelectSubset<T, CommunitySubcommentUpsertArgs>
    ): CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment>, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T>>>

    /**
     * Count the number of CommunitySubcomments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunitySubcommentCountArgs} args - Arguments to filter CommunitySubcomments to count.
     * @example
     * // Count the number of CommunitySubcomments
     * const count = await prisma.communitySubcomment.count({
     *   where: {
     *     // ... the filter for the CommunitySubcomments we want to count
     *   }
     * })
    **/
    count<T extends CommunitySubcommentCountArgs>(
      args?: Subset<T, CommunitySubcommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunitySubcommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunitySubcomment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunitySubcommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunitySubcommentAggregateArgs>(args: Subset<T, CommunitySubcommentAggregateArgs>): PrismaPromise<GetCommunitySubcommentAggregateType<T>>

    /**
     * Group by CommunitySubcomment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunitySubcommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunitySubcommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunitySubcommentGroupByArgs['orderBy'] }
        : { orderBy?: CommunitySubcommentGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunitySubcommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunitySubcommentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunitySubcomment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunitySubcommentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityComment<T extends CommunityCommentArgs = {}>(args?: Subset<T, CommunityCommentArgs>): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment | null >, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T> | null >>;

    communityPost<T extends CommunityPostArgs = {}>(args?: Subset<T, CommunityPostArgs>): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    reportSubcomments<T extends ReportSubcommentFindManyArgs = {}>(args?: Subset<T, ReportSubcommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReportSubcomment>>, PrismaPromise<Array<ReportSubcommentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommunitySubcomment findUnique
   */
  export type CommunitySubcommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * Throw an Error if a CommunitySubcomment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunitySubcomment to fetch.
    **/
    where: CommunitySubcommentWhereUniqueInput
  }


  /**
   * CommunitySubcomment findFirst
   */
  export type CommunitySubcommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * Throw an Error if a CommunitySubcomment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommunitySubcomment to fetch.
    **/
    where?: CommunitySubcommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunitySubcomments to fetch.
    **/
    orderBy?: Enumerable<CommunitySubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunitySubcomments.
    **/
    cursor?: CommunitySubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunitySubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunitySubcomments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunitySubcomments.
    **/
    distinct?: Enumerable<CommunitySubcommentScalarFieldEnum>
  }


  /**
   * CommunitySubcomment findMany
   */
  export type CommunitySubcommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * Filter, which CommunitySubcomments to fetch.
    **/
    where?: CommunitySubcommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunitySubcomments to fetch.
    **/
    orderBy?: Enumerable<CommunitySubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunitySubcomments.
    **/
    cursor?: CommunitySubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunitySubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunitySubcomments.
    **/
    skip?: number
    distinct?: Enumerable<CommunitySubcommentScalarFieldEnum>
  }


  /**
   * CommunitySubcomment create
   */
  export type CommunitySubcommentCreateArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * The data needed to create a CommunitySubcomment.
    **/
    data: XOR<CommunitySubcommentCreateInput, CommunitySubcommentUncheckedCreateInput>
  }


  /**
   * CommunitySubcomment createMany
   */
  export type CommunitySubcommentCreateManyArgs = {
    data: Enumerable<CommunitySubcommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommunitySubcomment update
   */
  export type CommunitySubcommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * The data needed to update a CommunitySubcomment.
    **/
    data: XOR<CommunitySubcommentUpdateInput, CommunitySubcommentUncheckedUpdateInput>
    /**
     * Choose, which CommunitySubcomment to update.
    **/
    where: CommunitySubcommentWhereUniqueInput
  }


  /**
   * CommunitySubcomment updateMany
   */
  export type CommunitySubcommentUpdateManyArgs = {
    data: XOR<CommunitySubcommentUpdateManyMutationInput, CommunitySubcommentUncheckedUpdateManyInput>
    where?: CommunitySubcommentWhereInput
  }


  /**
   * CommunitySubcomment upsert
   */
  export type CommunitySubcommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * The filter to search for the CommunitySubcomment to update in case it exists.
    **/
    where: CommunitySubcommentWhereUniqueInput
    /**
     * In case the CommunitySubcomment found by the `where` argument doesn't exist, create a new CommunitySubcomment with this data.
    **/
    create: XOR<CommunitySubcommentCreateInput, CommunitySubcommentUncheckedCreateInput>
    /**
     * In case the CommunitySubcomment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommunitySubcommentUpdateInput, CommunitySubcommentUncheckedUpdateInput>
  }


  /**
   * CommunitySubcomment delete
   */
  export type CommunitySubcommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
    /**
     * Filter which CommunitySubcomment to delete.
    **/
    where: CommunitySubcommentWhereUniqueInput
  }


  /**
   * CommunitySubcomment deleteMany
   */
  export type CommunitySubcommentDeleteManyArgs = {
    where?: CommunitySubcommentWhereInput
  }


  /**
   * CommunitySubcomment without action
   */
  export type CommunitySubcommentArgs = {
    /**
     * Select specific fields to fetch from the CommunitySubcomment
    **/
    select?: CommunitySubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommunitySubcommentInclude | null
  }



  /**
   * Model CoverageMajor
   */


  export type AggregateCoverageMajor = {
    count: CoverageMajorCountAggregateOutputType | null
    min: CoverageMajorMinAggregateOutputType | null
    max: CoverageMajorMaxAggregateOutputType | null
  }

  export type CoverageMajorMinAggregateOutputType = {
    coverageCollege: string | null
    name: string | null
    code: string | null
  }

  export type CoverageMajorMaxAggregateOutputType = {
    coverageCollege: string | null
    name: string | null
    code: string | null
  }

  export type CoverageMajorCountAggregateOutputType = {
    coverageCollege: number | null
    name: number | null
    code: number | null
    _all: number
  }


  export type CoverageMajorMinAggregateInputType = {
    coverageCollege?: true
    name?: true
    code?: true
  }

  export type CoverageMajorMaxAggregateInputType = {
    coverageCollege?: true
    name?: true
    code?: true
  }

  export type CoverageMajorCountAggregateInputType = {
    coverageCollege?: true
    name?: true
    code?: true
    _all?: true
  }

  export type CoverageMajorAggregateArgs = {
    /**
     * Filter which CoverageMajor to aggregate.
    **/
    where?: CoverageMajorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoverageMajors to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CoverageMajorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajors.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoverageMajors
    **/
    count?: true | CoverageMajorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CoverageMajorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CoverageMajorMaxAggregateInputType
  }

  export type GetCoverageMajorAggregateType<T extends CoverageMajorAggregateArgs> = {
    [P in keyof T & keyof AggregateCoverageMajor]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoverageMajor[P]>
      : GetScalarType<T[P], AggregateCoverageMajor[P]>
  }


    
    
  export type CoverageMajorGroupByArgs = {
    where?: CoverageMajorWhereInput
    orderBy?: Enumerable<CoverageMajorOrderByInput>
    by: Array<CoverageMajorScalarFieldEnum>
    having?: CoverageMajorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CoverageMajorCountAggregateInputType | true
    min?: CoverageMajorMinAggregateInputType
    max?: CoverageMajorMaxAggregateInputType
  }


  export type CoverageMajorGroupByOutputType = {
    coverageCollege: string | null
    name: string
    code: string
    count: CoverageMajorCountAggregateOutputType | null
    min: CoverageMajorMinAggregateOutputType | null
    max: CoverageMajorMaxAggregateOutputType | null
  }

  type GetCoverageMajorGroupByPayload<T extends CoverageMajorGroupByArgs> = Promise<Array<
    PickArray<CoverageMajorGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CoverageMajorGroupByOutputType))]: GetScalarType<T[P], CoverageMajorGroupByOutputType[P]>
    }
  >>
    

  export type CoverageMajorSelect = {
    coverageCollege?: boolean
    name?: boolean
    code?: boolean
    coverageMajorLectures?: boolean | CoverageMajorLectureFindManyArgs
  }

  export type CoverageMajorInclude = {
    coverageMajorLectures?: boolean | CoverageMajorLectureFindManyArgs
  }

  export type CoverageMajorGetPayload<
    S extends boolean | null | undefined | CoverageMajorArgs,
    U = keyof S
      > = S extends true
        ? CoverageMajor
    : S extends undefined
    ? never
    : S extends CoverageMajorArgs | CoverageMajorFindManyArgs
    ?'include' extends U
    ? CoverageMajor  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'coverageMajorLectures'
        ? Array < CoverageMajorLectureGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CoverageMajor ?CoverageMajor [P]
  : 
          P extends 'coverageMajorLectures'
        ? Array < CoverageMajorLectureGetPayload<S['select'][P]>>  : never
  } 
    : CoverageMajor
  : CoverageMajor


  type CoverageMajorCountArgs = Merge<
    Omit<CoverageMajorFindManyArgs, 'select' | 'include'> & {
      select?: CoverageMajorCountAggregateInputType | true
    }
  >

  export interface CoverageMajorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CoverageMajor that matches the filter.
     * @param {CoverageMajorFindUniqueArgs} args - Arguments to find a CoverageMajor
     * @example
     * // Get one CoverageMajor
     * const coverageMajor = await prisma.coverageMajor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoverageMajorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CoverageMajorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CoverageMajor'> extends True ? CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>> : CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor | null >, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T> | null >>

    /**
     * Find the first CoverageMajor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorFindFirstArgs} args - Arguments to find a CoverageMajor
     * @example
     * // Get one CoverageMajor
     * const coverageMajor = await prisma.coverageMajor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoverageMajorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CoverageMajorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CoverageMajor'> extends True ? CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>> : CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor | null >, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T> | null >>

    /**
     * Find zero or more CoverageMajors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoverageMajors
     * const coverageMajors = await prisma.coverageMajor.findMany()
     * 
     * // Get first 10 CoverageMajors
     * const coverageMajors = await prisma.coverageMajor.findMany({ take: 10 })
     * 
     * // Only select the `coverageCollege`
     * const coverageMajorWithCoverageCollegeOnly = await prisma.coverageMajor.findMany({ select: { coverageCollege: true } })
     * 
    **/
    findMany<T extends CoverageMajorFindManyArgs>(
      args?: SelectSubset<T, CoverageMajorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CoverageMajor>>, PrismaPromise<Array<CoverageMajorGetPayload<T>>>>

    /**
     * Create a CoverageMajor.
     * @param {CoverageMajorCreateArgs} args - Arguments to create a CoverageMajor.
     * @example
     * // Create one CoverageMajor
     * const CoverageMajor = await prisma.coverageMajor.create({
     *   data: {
     *     // ... data to create a CoverageMajor
     *   }
     * })
     * 
    **/
    create<T extends CoverageMajorCreateArgs>(
      args: SelectSubset<T, CoverageMajorCreateArgs>
    ): CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>>

    /**
     * Create many CoverageMajors.
     *     @param {CoverageMajorCreateManyArgs} args - Arguments to create many CoverageMajors.
     *     @example
     *     // Create many CoverageMajors
     *     const coverageMajor = await prisma.coverageMajor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CoverageMajorCreateManyArgs>(
      args?: SelectSubset<T, CoverageMajorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CoverageMajor.
     * @param {CoverageMajorDeleteArgs} args - Arguments to delete one CoverageMajor.
     * @example
     * // Delete one CoverageMajor
     * const CoverageMajor = await prisma.coverageMajor.delete({
     *   where: {
     *     // ... filter to delete one CoverageMajor
     *   }
     * })
     * 
    **/
    delete<T extends CoverageMajorDeleteArgs>(
      args: SelectSubset<T, CoverageMajorDeleteArgs>
    ): CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>>

    /**
     * Update one CoverageMajor.
     * @param {CoverageMajorUpdateArgs} args - Arguments to update one CoverageMajor.
     * @example
     * // Update one CoverageMajor
     * const coverageMajor = await prisma.coverageMajor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoverageMajorUpdateArgs>(
      args: SelectSubset<T, CoverageMajorUpdateArgs>
    ): CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>>

    /**
     * Delete zero or more CoverageMajors.
     * @param {CoverageMajorDeleteManyArgs} args - Arguments to filter CoverageMajors to delete.
     * @example
     * // Delete a few CoverageMajors
     * const { count } = await prisma.coverageMajor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoverageMajorDeleteManyArgs>(
      args?: SelectSubset<T, CoverageMajorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoverageMajors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoverageMajors
     * const coverageMajor = await prisma.coverageMajor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoverageMajorUpdateManyArgs>(
      args: SelectSubset<T, CoverageMajorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CoverageMajor.
     * @param {CoverageMajorUpsertArgs} args - Arguments to update or create a CoverageMajor.
     * @example
     * // Update or create a CoverageMajor
     * const coverageMajor = await prisma.coverageMajor.upsert({
     *   create: {
     *     // ... data to create a CoverageMajor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoverageMajor we want to update
     *   }
     * })
    **/
    upsert<T extends CoverageMajorUpsertArgs>(
      args: SelectSubset<T, CoverageMajorUpsertArgs>
    ): CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor>, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T>>>

    /**
     * Count the number of CoverageMajors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorCountArgs} args - Arguments to filter CoverageMajors to count.
     * @example
     * // Count the number of CoverageMajors
     * const count = await prisma.coverageMajor.count({
     *   where: {
     *     // ... the filter for the CoverageMajors we want to count
     *   }
     * })
    **/
    count<T extends CoverageMajorCountArgs>(
      args?: Subset<T, CoverageMajorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoverageMajorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoverageMajor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoverageMajorAggregateArgs>(args: Subset<T, CoverageMajorAggregateArgs>): PrismaPromise<GetCoverageMajorAggregateType<T>>

    /**
     * Group by CoverageMajor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoverageMajorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoverageMajorGroupByArgs['orderBy'] }
        : { orderBy?: CoverageMajorGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoverageMajorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoverageMajorGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoverageMajor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CoverageMajorClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    coverageMajorLectures<T extends CoverageMajorLectureFindManyArgs = {}>(args?: Subset<T, CoverageMajorLectureFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CoverageMajorLecture>>, PrismaPromise<Array<CoverageMajorLectureGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CoverageMajor findUnique
   */
  export type CoverageMajorFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * Throw an Error if a CoverageMajor can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CoverageMajor to fetch.
    **/
    where: CoverageMajorWhereUniqueInput
  }


  /**
   * CoverageMajor findFirst
   */
  export type CoverageMajorFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * Throw an Error if a CoverageMajor can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CoverageMajor to fetch.
    **/
    where?: CoverageMajorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoverageMajors to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoverageMajors.
    **/
    cursor?: CoverageMajorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajors.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoverageMajors.
    **/
    distinct?: Enumerable<CoverageMajorScalarFieldEnum>
  }


  /**
   * CoverageMajor findMany
   */
  export type CoverageMajorFindManyArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * Filter, which CoverageMajors to fetch.
    **/
    where?: CoverageMajorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoverageMajors to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoverageMajors.
    **/
    cursor?: CoverageMajorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajors.
    **/
    skip?: number
    distinct?: Enumerable<CoverageMajorScalarFieldEnum>
  }


  /**
   * CoverageMajor create
   */
  export type CoverageMajorCreateArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * The data needed to create a CoverageMajor.
    **/
    data: XOR<CoverageMajorCreateInput, CoverageMajorUncheckedCreateInput>
  }


  /**
   * CoverageMajor createMany
   */
  export type CoverageMajorCreateManyArgs = {
    data: Enumerable<CoverageMajorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CoverageMajor update
   */
  export type CoverageMajorUpdateArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * The data needed to update a CoverageMajor.
    **/
    data: XOR<CoverageMajorUpdateInput, CoverageMajorUncheckedUpdateInput>
    /**
     * Choose, which CoverageMajor to update.
    **/
    where: CoverageMajorWhereUniqueInput
  }


  /**
   * CoverageMajor updateMany
   */
  export type CoverageMajorUpdateManyArgs = {
    data: XOR<CoverageMajorUpdateManyMutationInput, CoverageMajorUncheckedUpdateManyInput>
    where?: CoverageMajorWhereInput
  }


  /**
   * CoverageMajor upsert
   */
  export type CoverageMajorUpsertArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * The filter to search for the CoverageMajor to update in case it exists.
    **/
    where: CoverageMajorWhereUniqueInput
    /**
     * In case the CoverageMajor found by the `where` argument doesn't exist, create a new CoverageMajor with this data.
    **/
    create: XOR<CoverageMajorCreateInput, CoverageMajorUncheckedCreateInput>
    /**
     * In case the CoverageMajor was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CoverageMajorUpdateInput, CoverageMajorUncheckedUpdateInput>
  }


  /**
   * CoverageMajor delete
   */
  export type CoverageMajorDeleteArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
    /**
     * Filter which CoverageMajor to delete.
    **/
    where: CoverageMajorWhereUniqueInput
  }


  /**
   * CoverageMajor deleteMany
   */
  export type CoverageMajorDeleteManyArgs = {
    where?: CoverageMajorWhereInput
  }


  /**
   * CoverageMajor without action
   */
  export type CoverageMajorArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajor
    **/
    select?: CoverageMajorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorInclude | null
  }



  /**
   * Model CoverageMajorLecture
   */


  export type AggregateCoverageMajorLecture = {
    count: CoverageMajorLectureCountAggregateOutputType | null
    min: CoverageMajorLectureMinAggregateOutputType | null
    max: CoverageMajorLectureMaxAggregateOutputType | null
  }

  export type CoverageMajorLectureMinAggregateOutputType = {
    lectureId: string | null
    majorCode: string | null
  }

  export type CoverageMajorLectureMaxAggregateOutputType = {
    lectureId: string | null
    majorCode: string | null
  }

  export type CoverageMajorLectureCountAggregateOutputType = {
    lectureId: number | null
    majorCode: number | null
    _all: number
  }


  export type CoverageMajorLectureMinAggregateInputType = {
    lectureId?: true
    majorCode?: true
  }

  export type CoverageMajorLectureMaxAggregateInputType = {
    lectureId?: true
    majorCode?: true
  }

  export type CoverageMajorLectureCountAggregateInputType = {
    lectureId?: true
    majorCode?: true
    _all?: true
  }

  export type CoverageMajorLectureAggregateArgs = {
    /**
     * Filter which CoverageMajorLecture to aggregate.
    **/
    where?: CoverageMajorLectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoverageMajorLectures to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorLectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CoverageMajorLectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajorLectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajorLectures.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoverageMajorLectures
    **/
    count?: true | CoverageMajorLectureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CoverageMajorLectureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CoverageMajorLectureMaxAggregateInputType
  }

  export type GetCoverageMajorLectureAggregateType<T extends CoverageMajorLectureAggregateArgs> = {
    [P in keyof T & keyof AggregateCoverageMajorLecture]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoverageMajorLecture[P]>
      : GetScalarType<T[P], AggregateCoverageMajorLecture[P]>
  }


    
    
  export type CoverageMajorLectureGroupByArgs = {
    where?: CoverageMajorLectureWhereInput
    orderBy?: Enumerable<CoverageMajorLectureOrderByInput>
    by: Array<CoverageMajorLectureScalarFieldEnum>
    having?: CoverageMajorLectureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CoverageMajorLectureCountAggregateInputType | true
    min?: CoverageMajorLectureMinAggregateInputType
    max?: CoverageMajorLectureMaxAggregateInputType
  }


  export type CoverageMajorLectureGroupByOutputType = {
    lectureId: string
    majorCode: string
    count: CoverageMajorLectureCountAggregateOutputType | null
    min: CoverageMajorLectureMinAggregateOutputType | null
    max: CoverageMajorLectureMaxAggregateOutputType | null
  }

  type GetCoverageMajorLectureGroupByPayload<T extends CoverageMajorLectureGroupByArgs> = Promise<Array<
    PickArray<CoverageMajorLectureGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CoverageMajorLectureGroupByOutputType))]: GetScalarType<T[P], CoverageMajorLectureGroupByOutputType[P]>
    }
  >>
    

  export type CoverageMajorLectureSelect = {
    lectureId?: boolean
    majorCode?: boolean
    lecture?: boolean | LectureArgs
    coverageMajor?: boolean | CoverageMajorArgs
  }

  export type CoverageMajorLectureInclude = {
    lecture?: boolean | LectureArgs
    coverageMajor?: boolean | CoverageMajorArgs
  }

  export type CoverageMajorLectureGetPayload<
    S extends boolean | null | undefined | CoverageMajorLectureArgs,
    U = keyof S
      > = S extends true
        ? CoverageMajorLecture
    : S extends undefined
    ? never
    : S extends CoverageMajorLectureArgs | CoverageMajorLectureFindManyArgs
    ?'include' extends U
    ? CoverageMajorLecture  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'lecture'
        ? LectureGetPayload<S['include'][P]> :
        P extends 'coverageMajor'
        ? CoverageMajorGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CoverageMajorLecture ?CoverageMajorLecture [P]
  : 
          P extends 'lecture'
        ? LectureGetPayload<S['select'][P]> :
        P extends 'coverageMajor'
        ? CoverageMajorGetPayload<S['select'][P]> : never
  } 
    : CoverageMajorLecture
  : CoverageMajorLecture


  type CoverageMajorLectureCountArgs = Merge<
    Omit<CoverageMajorLectureFindManyArgs, 'select' | 'include'> & {
      select?: CoverageMajorLectureCountAggregateInputType | true
    }
  >

  export interface CoverageMajorLectureDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CoverageMajorLecture that matches the filter.
     * @param {CoverageMajorLectureFindUniqueArgs} args - Arguments to find a CoverageMajorLecture
     * @example
     * // Get one CoverageMajorLecture
     * const coverageMajorLecture = await prisma.coverageMajorLecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoverageMajorLectureFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CoverageMajorLectureFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CoverageMajorLecture'> extends True ? CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>> : CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture | null >, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T> | null >>

    /**
     * Find the first CoverageMajorLecture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorLectureFindFirstArgs} args - Arguments to find a CoverageMajorLecture
     * @example
     * // Get one CoverageMajorLecture
     * const coverageMajorLecture = await prisma.coverageMajorLecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoverageMajorLectureFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CoverageMajorLectureFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CoverageMajorLecture'> extends True ? CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>> : CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture | null >, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T> | null >>

    /**
     * Find zero or more CoverageMajorLectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorLectureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoverageMajorLectures
     * const coverageMajorLectures = await prisma.coverageMajorLecture.findMany()
     * 
     * // Get first 10 CoverageMajorLectures
     * const coverageMajorLectures = await prisma.coverageMajorLecture.findMany({ take: 10 })
     * 
     * // Only select the `lectureId`
     * const coverageMajorLectureWithLectureIdOnly = await prisma.coverageMajorLecture.findMany({ select: { lectureId: true } })
     * 
    **/
    findMany<T extends CoverageMajorLectureFindManyArgs>(
      args?: SelectSubset<T, CoverageMajorLectureFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CoverageMajorLecture>>, PrismaPromise<Array<CoverageMajorLectureGetPayload<T>>>>

    /**
     * Create a CoverageMajorLecture.
     * @param {CoverageMajorLectureCreateArgs} args - Arguments to create a CoverageMajorLecture.
     * @example
     * // Create one CoverageMajorLecture
     * const CoverageMajorLecture = await prisma.coverageMajorLecture.create({
     *   data: {
     *     // ... data to create a CoverageMajorLecture
     *   }
     * })
     * 
    **/
    create<T extends CoverageMajorLectureCreateArgs>(
      args: SelectSubset<T, CoverageMajorLectureCreateArgs>
    ): CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>>

    /**
     * Create many CoverageMajorLectures.
     *     @param {CoverageMajorLectureCreateManyArgs} args - Arguments to create many CoverageMajorLectures.
     *     @example
     *     // Create many CoverageMajorLectures
     *     const coverageMajorLecture = await prisma.coverageMajorLecture.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CoverageMajorLectureCreateManyArgs>(
      args?: SelectSubset<T, CoverageMajorLectureCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CoverageMajorLecture.
     * @param {CoverageMajorLectureDeleteArgs} args - Arguments to delete one CoverageMajorLecture.
     * @example
     * // Delete one CoverageMajorLecture
     * const CoverageMajorLecture = await prisma.coverageMajorLecture.delete({
     *   where: {
     *     // ... filter to delete one CoverageMajorLecture
     *   }
     * })
     * 
    **/
    delete<T extends CoverageMajorLectureDeleteArgs>(
      args: SelectSubset<T, CoverageMajorLectureDeleteArgs>
    ): CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>>

    /**
     * Update one CoverageMajorLecture.
     * @param {CoverageMajorLectureUpdateArgs} args - Arguments to update one CoverageMajorLecture.
     * @example
     * // Update one CoverageMajorLecture
     * const coverageMajorLecture = await prisma.coverageMajorLecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoverageMajorLectureUpdateArgs>(
      args: SelectSubset<T, CoverageMajorLectureUpdateArgs>
    ): CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>>

    /**
     * Delete zero or more CoverageMajorLectures.
     * @param {CoverageMajorLectureDeleteManyArgs} args - Arguments to filter CoverageMajorLectures to delete.
     * @example
     * // Delete a few CoverageMajorLectures
     * const { count } = await prisma.coverageMajorLecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoverageMajorLectureDeleteManyArgs>(
      args?: SelectSubset<T, CoverageMajorLectureDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoverageMajorLectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorLectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoverageMajorLectures
     * const coverageMajorLecture = await prisma.coverageMajorLecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoverageMajorLectureUpdateManyArgs>(
      args: SelectSubset<T, CoverageMajorLectureUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CoverageMajorLecture.
     * @param {CoverageMajorLectureUpsertArgs} args - Arguments to update or create a CoverageMajorLecture.
     * @example
     * // Update or create a CoverageMajorLecture
     * const coverageMajorLecture = await prisma.coverageMajorLecture.upsert({
     *   create: {
     *     // ... data to create a CoverageMajorLecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoverageMajorLecture we want to update
     *   }
     * })
    **/
    upsert<T extends CoverageMajorLectureUpsertArgs>(
      args: SelectSubset<T, CoverageMajorLectureUpsertArgs>
    ): CheckSelect<T, Prisma__CoverageMajorLectureClient<CoverageMajorLecture>, Prisma__CoverageMajorLectureClient<CoverageMajorLectureGetPayload<T>>>

    /**
     * Count the number of CoverageMajorLectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorLectureCountArgs} args - Arguments to filter CoverageMajorLectures to count.
     * @example
     * // Count the number of CoverageMajorLectures
     * const count = await prisma.coverageMajorLecture.count({
     *   where: {
     *     // ... the filter for the CoverageMajorLectures we want to count
     *   }
     * })
    **/
    count<T extends CoverageMajorLectureCountArgs>(
      args?: Subset<T, CoverageMajorLectureCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoverageMajorLectureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoverageMajorLecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorLectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoverageMajorLectureAggregateArgs>(args: Subset<T, CoverageMajorLectureAggregateArgs>): PrismaPromise<GetCoverageMajorLectureAggregateType<T>>

    /**
     * Group by CoverageMajorLecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverageMajorLectureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoverageMajorLectureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoverageMajorLectureGroupByArgs['orderBy'] }
        : { orderBy?: CoverageMajorLectureGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoverageMajorLectureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoverageMajorLectureGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoverageMajorLecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CoverageMajorLectureClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    lecture<T extends LectureArgs = {}>(args?: Subset<T, LectureArgs>): CheckSelect<T, Prisma__LectureClient<Lecture | null >, Prisma__LectureClient<LectureGetPayload<T> | null >>;

    coverageMajor<T extends CoverageMajorArgs = {}>(args?: Subset<T, CoverageMajorArgs>): CheckSelect<T, Prisma__CoverageMajorClient<CoverageMajor | null >, Prisma__CoverageMajorClient<CoverageMajorGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CoverageMajorLecture findUnique
   */
  export type CoverageMajorLectureFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * Throw an Error if a CoverageMajorLecture can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CoverageMajorLecture to fetch.
    **/
    where: CoverageMajorLectureWhereUniqueInput
  }


  /**
   * CoverageMajorLecture findFirst
   */
  export type CoverageMajorLectureFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * Throw an Error if a CoverageMajorLecture can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CoverageMajorLecture to fetch.
    **/
    where?: CoverageMajorLectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoverageMajorLectures to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorLectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoverageMajorLectures.
    **/
    cursor?: CoverageMajorLectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajorLectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajorLectures.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoverageMajorLectures.
    **/
    distinct?: Enumerable<CoverageMajorLectureScalarFieldEnum>
  }


  /**
   * CoverageMajorLecture findMany
   */
  export type CoverageMajorLectureFindManyArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * Filter, which CoverageMajorLectures to fetch.
    **/
    where?: CoverageMajorLectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoverageMajorLectures to fetch.
    **/
    orderBy?: Enumerable<CoverageMajorLectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoverageMajorLectures.
    **/
    cursor?: CoverageMajorLectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverageMajorLectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverageMajorLectures.
    **/
    skip?: number
    distinct?: Enumerable<CoverageMajorLectureScalarFieldEnum>
  }


  /**
   * CoverageMajorLecture create
   */
  export type CoverageMajorLectureCreateArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * The data needed to create a CoverageMajorLecture.
    **/
    data: XOR<CoverageMajorLectureCreateInput, CoverageMajorLectureUncheckedCreateInput>
  }


  /**
   * CoverageMajorLecture createMany
   */
  export type CoverageMajorLectureCreateManyArgs = {
    data: Enumerable<CoverageMajorLectureCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CoverageMajorLecture update
   */
  export type CoverageMajorLectureUpdateArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * The data needed to update a CoverageMajorLecture.
    **/
    data: XOR<CoverageMajorLectureUpdateInput, CoverageMajorLectureUncheckedUpdateInput>
    /**
     * Choose, which CoverageMajorLecture to update.
    **/
    where: CoverageMajorLectureWhereUniqueInput
  }


  /**
   * CoverageMajorLecture updateMany
   */
  export type CoverageMajorLectureUpdateManyArgs = {
    data: XOR<CoverageMajorLectureUpdateManyMutationInput, CoverageMajorLectureUncheckedUpdateManyInput>
    where?: CoverageMajorLectureWhereInput
  }


  /**
   * CoverageMajorLecture upsert
   */
  export type CoverageMajorLectureUpsertArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * The filter to search for the CoverageMajorLecture to update in case it exists.
    **/
    where: CoverageMajorLectureWhereUniqueInput
    /**
     * In case the CoverageMajorLecture found by the `where` argument doesn't exist, create a new CoverageMajorLecture with this data.
    **/
    create: XOR<CoverageMajorLectureCreateInput, CoverageMajorLectureUncheckedCreateInput>
    /**
     * In case the CoverageMajorLecture was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CoverageMajorLectureUpdateInput, CoverageMajorLectureUncheckedUpdateInput>
  }


  /**
   * CoverageMajorLecture delete
   */
  export type CoverageMajorLectureDeleteArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
    /**
     * Filter which CoverageMajorLecture to delete.
    **/
    where: CoverageMajorLectureWhereUniqueInput
  }


  /**
   * CoverageMajorLecture deleteMany
   */
  export type CoverageMajorLectureDeleteManyArgs = {
    where?: CoverageMajorLectureWhereInput
  }


  /**
   * CoverageMajorLecture without action
   */
  export type CoverageMajorLectureArgs = {
    /**
     * Select specific fields to fetch from the CoverageMajorLecture
    **/
    select?: CoverageMajorLectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoverageMajorLectureInclude | null
  }



  /**
   * Model Lecture
   */


  export type AggregateLecture = {
    count: LectureCountAggregateOutputType | null
    avg: LectureAvgAggregateOutputType | null
    sum: LectureSumAggregateOutputType | null
    min: LectureMinAggregateOutputType | null
    max: LectureMaxAggregateOutputType | null
  }

  export type LectureAvgAggregateOutputType = {
    year: number | null
    grade: number | null
    credit: number | null
    building: number | null
  }

  export type LectureSumAggregateOutputType = {
    year: number | null
    grade: number | null
    credit: number | null
    building: number | null
  }

  export type LectureMinAggregateOutputType = {
    id: string | null
    year: number | null
    semester: string | null
    campus: string | null
    college: string | null
    major: string | null
    grade: number | null
    credit: number | null
    course: string | null
    section: string | null
    code: string | null
    name: string | null
    professor: string | null
    schedule: string | null
    building: number | null
    room: string | null
    note: string | null
  }

  export type LectureMaxAggregateOutputType = {
    id: string | null
    year: number | null
    semester: string | null
    campus: string | null
    college: string | null
    major: string | null
    grade: number | null
    credit: number | null
    course: string | null
    section: string | null
    code: string | null
    name: string | null
    professor: string | null
    schedule: string | null
    building: number | null
    room: string | null
    note: string | null
  }

  export type LectureCountAggregateOutputType = {
    id: number | null
    year: number | null
    semester: number | null
    campus: number | null
    college: number | null
    major: number | null
    grade: number | null
    credit: number | null
    course: number | null
    section: number | null
    code: number | null
    name: number | null
    professor: number | null
    schedule: number | null
    building: number | null
    room: number | null
    note: number | null
    _all: number
  }


  export type LectureAvgAggregateInputType = {
    year?: true
    grade?: true
    credit?: true
    building?: true
  }

  export type LectureSumAggregateInputType = {
    year?: true
    grade?: true
    credit?: true
    building?: true
  }

  export type LectureMinAggregateInputType = {
    id?: true
    year?: true
    semester?: true
    campus?: true
    college?: true
    major?: true
    grade?: true
    credit?: true
    course?: true
    section?: true
    code?: true
    name?: true
    professor?: true
    schedule?: true
    building?: true
    room?: true
    note?: true
  }

  export type LectureMaxAggregateInputType = {
    id?: true
    year?: true
    semester?: true
    campus?: true
    college?: true
    major?: true
    grade?: true
    credit?: true
    course?: true
    section?: true
    code?: true
    name?: true
    professor?: true
    schedule?: true
    building?: true
    room?: true
    note?: true
  }

  export type LectureCountAggregateInputType = {
    id?: true
    year?: true
    semester?: true
    campus?: true
    college?: true
    major?: true
    grade?: true
    credit?: true
    course?: true
    section?: true
    code?: true
    name?: true
    professor?: true
    schedule?: true
    building?: true
    room?: true
    note?: true
    _all?: true
  }

  export type LectureAggregateArgs = {
    /**
     * Filter which Lecture to aggregate.
    **/
    where?: LectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
    **/
    orderBy?: Enumerable<LectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lectures
    **/
    count?: true | LectureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: LectureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: LectureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: LectureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: LectureMaxAggregateInputType
  }

  export type GetLectureAggregateType<T extends LectureAggregateArgs> = {
    [P in keyof T & keyof AggregateLecture]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecture[P]>
      : GetScalarType<T[P], AggregateLecture[P]>
  }


    
    
  export type LectureGroupByArgs = {
    where?: LectureWhereInput
    orderBy?: Enumerable<LectureOrderByInput>
    by: Array<LectureScalarFieldEnum>
    having?: LectureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: LectureCountAggregateInputType | true
    avg?: LectureAvgAggregateInputType
    sum?: LectureSumAggregateInputType
    min?: LectureMinAggregateInputType
    max?: LectureMaxAggregateInputType
  }


  export type LectureGroupByOutputType = {
    id: string
    year: number | null
    semester: string | null
    campus: string | null
    college: string | null
    major: string | null
    grade: number | null
    credit: number | null
    course: string | null
    section: string | null
    code: string | null
    name: string | null
    professor: string | null
    schedule: string | null
    building: number | null
    room: string | null
    note: string | null
    count: LectureCountAggregateOutputType | null
    avg: LectureAvgAggregateOutputType | null
    sum: LectureSumAggregateOutputType | null
    min: LectureMinAggregateOutputType | null
    max: LectureMaxAggregateOutputType | null
  }

  type GetLectureGroupByPayload<T extends LectureGroupByArgs> = Promise<Array<
    PickArray<LectureGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof LectureGroupByOutputType))]: GetScalarType<T[P], LectureGroupByOutputType[P]>
    }
  >>
    

  export type LectureSelect = {
    id?: boolean
    year?: boolean
    semester?: boolean
    campus?: boolean
    college?: boolean
    major?: boolean
    grade?: boolean
    credit?: boolean
    course?: boolean
    section?: boolean
    code?: boolean
    name?: boolean
    professor?: boolean
    schedule?: boolean
    building?: boolean
    room?: boolean
    note?: boolean
    coverageMajorLectures?: boolean | CoverageMajorLectureFindManyArgs
    periods?: boolean | PeriodFindManyArgs
  }

  export type LectureInclude = {
    coverageMajorLectures?: boolean | CoverageMajorLectureFindManyArgs
    periods?: boolean | PeriodFindManyArgs
  }

  export type LectureGetPayload<
    S extends boolean | null | undefined | LectureArgs,
    U = keyof S
      > = S extends true
        ? Lecture
    : S extends undefined
    ? never
    : S extends LectureArgs | LectureFindManyArgs
    ?'include' extends U
    ? Lecture  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'coverageMajorLectures'
        ? Array < CoverageMajorLectureGetPayload<S['include'][P]>>  :
        P extends 'periods'
        ? Array < PeriodGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Lecture ?Lecture [P]
  : 
          P extends 'coverageMajorLectures'
        ? Array < CoverageMajorLectureGetPayload<S['select'][P]>>  :
        P extends 'periods'
        ? Array < PeriodGetPayload<S['select'][P]>>  : never
  } 
    : Lecture
  : Lecture


  type LectureCountArgs = Merge<
    Omit<LectureFindManyArgs, 'select' | 'include'> & {
      select?: LectureCountAggregateInputType | true
    }
  >

  export interface LectureDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Lecture that matches the filter.
     * @param {LectureFindUniqueArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LectureFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LectureFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Lecture'> extends True ? CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>> : CheckSelect<T, Prisma__LectureClient<Lecture | null >, Prisma__LectureClient<LectureGetPayload<T> | null >>

    /**
     * Find the first Lecture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindFirstArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LectureFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LectureFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Lecture'> extends True ? CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>> : CheckSelect<T, Prisma__LectureClient<Lecture | null >, Prisma__LectureClient<LectureGetPayload<T> | null >>

    /**
     * Find zero or more Lectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lectures
     * const lectures = await prisma.lecture.findMany()
     * 
     * // Get first 10 Lectures
     * const lectures = await prisma.lecture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lectureWithIdOnly = await prisma.lecture.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LectureFindManyArgs>(
      args?: SelectSubset<T, LectureFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Lecture>>, PrismaPromise<Array<LectureGetPayload<T>>>>

    /**
     * Create a Lecture.
     * @param {LectureCreateArgs} args - Arguments to create a Lecture.
     * @example
     * // Create one Lecture
     * const Lecture = await prisma.lecture.create({
     *   data: {
     *     // ... data to create a Lecture
     *   }
     * })
     * 
    **/
    create<T extends LectureCreateArgs>(
      args: SelectSubset<T, LectureCreateArgs>
    ): CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>>

    /**
     * Create many Lectures.
     *     @param {LectureCreateManyArgs} args - Arguments to create many Lectures.
     *     @example
     *     // Create many Lectures
     *     const lecture = await prisma.lecture.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LectureCreateManyArgs>(
      args?: SelectSubset<T, LectureCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Lecture.
     * @param {LectureDeleteArgs} args - Arguments to delete one Lecture.
     * @example
     * // Delete one Lecture
     * const Lecture = await prisma.lecture.delete({
     *   where: {
     *     // ... filter to delete one Lecture
     *   }
     * })
     * 
    **/
    delete<T extends LectureDeleteArgs>(
      args: SelectSubset<T, LectureDeleteArgs>
    ): CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>>

    /**
     * Update one Lecture.
     * @param {LectureUpdateArgs} args - Arguments to update one Lecture.
     * @example
     * // Update one Lecture
     * const lecture = await prisma.lecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LectureUpdateArgs>(
      args: SelectSubset<T, LectureUpdateArgs>
    ): CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>>

    /**
     * Delete zero or more Lectures.
     * @param {LectureDeleteManyArgs} args - Arguments to filter Lectures to delete.
     * @example
     * // Delete a few Lectures
     * const { count } = await prisma.lecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LectureDeleteManyArgs>(
      args?: SelectSubset<T, LectureDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lectures
     * const lecture = await prisma.lecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LectureUpdateManyArgs>(
      args: SelectSubset<T, LectureUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Lecture.
     * @param {LectureUpsertArgs} args - Arguments to update or create a Lecture.
     * @example
     * // Update or create a Lecture
     * const lecture = await prisma.lecture.upsert({
     *   create: {
     *     // ... data to create a Lecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecture we want to update
     *   }
     * })
    **/
    upsert<T extends LectureUpsertArgs>(
      args: SelectSubset<T, LectureUpsertArgs>
    ): CheckSelect<T, Prisma__LectureClient<Lecture>, Prisma__LectureClient<LectureGetPayload<T>>>

    /**
     * Count the number of Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureCountArgs} args - Arguments to filter Lectures to count.
     * @example
     * // Count the number of Lectures
     * const count = await prisma.lecture.count({
     *   where: {
     *     // ... the filter for the Lectures we want to count
     *   }
     * })
    **/
    count<T extends LectureCountArgs>(
      args?: Subset<T, LectureCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LectureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LectureAggregateArgs>(args: Subset<T, LectureAggregateArgs>): PrismaPromise<GetLectureAggregateType<T>>

    /**
     * Group by Lecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LectureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LectureGroupByArgs['orderBy'] }
        : { orderBy?: LectureGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LectureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLectureGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LectureClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    coverageMajorLectures<T extends CoverageMajorLectureFindManyArgs = {}>(args?: Subset<T, CoverageMajorLectureFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CoverageMajorLecture>>, PrismaPromise<Array<CoverageMajorLectureGetPayload<T>>>>;

    periods<T extends PeriodFindManyArgs = {}>(args?: Subset<T, PeriodFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Period>>, PrismaPromise<Array<PeriodGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Lecture findUnique
   */
  export type LectureFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * Throw an Error if a Lecture can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Lecture to fetch.
    **/
    where: LectureWhereUniqueInput
  }


  /**
   * Lecture findFirst
   */
  export type LectureFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * Throw an Error if a Lecture can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Lecture to fetch.
    **/
    where?: LectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
    **/
    orderBy?: Enumerable<LectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lectures.
    **/
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lectures.
    **/
    distinct?: Enumerable<LectureScalarFieldEnum>
  }


  /**
   * Lecture findMany
   */
  export type LectureFindManyArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * Filter, which Lectures to fetch.
    **/
    where?: LectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
    **/
    orderBy?: Enumerable<LectureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lectures.
    **/
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
    **/
    skip?: number
    distinct?: Enumerable<LectureScalarFieldEnum>
  }


  /**
   * Lecture create
   */
  export type LectureCreateArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * The data needed to create a Lecture.
    **/
    data: XOR<LectureCreateInput, LectureUncheckedCreateInput>
  }


  /**
   * Lecture createMany
   */
  export type LectureCreateManyArgs = {
    data: Enumerable<LectureCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Lecture update
   */
  export type LectureUpdateArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * The data needed to update a Lecture.
    **/
    data: XOR<LectureUpdateInput, LectureUncheckedUpdateInput>
    /**
     * Choose, which Lecture to update.
    **/
    where: LectureWhereUniqueInput
  }


  /**
   * Lecture updateMany
   */
  export type LectureUpdateManyArgs = {
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyInput>
    where?: LectureWhereInput
  }


  /**
   * Lecture upsert
   */
  export type LectureUpsertArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * The filter to search for the Lecture to update in case it exists.
    **/
    where: LectureWhereUniqueInput
    /**
     * In case the Lecture found by the `where` argument doesn't exist, create a new Lecture with this data.
    **/
    create: XOR<LectureCreateInput, LectureUncheckedCreateInput>
    /**
     * In case the Lecture was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<LectureUpdateInput, LectureUncheckedUpdateInput>
  }


  /**
   * Lecture delete
   */
  export type LectureDeleteArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
    /**
     * Filter which Lecture to delete.
    **/
    where: LectureWhereUniqueInput
  }


  /**
   * Lecture deleteMany
   */
  export type LectureDeleteManyArgs = {
    where?: LectureWhereInput
  }


  /**
   * Lecture without action
   */
  export type LectureArgs = {
    /**
     * Select specific fields to fetch from the Lecture
    **/
    select?: LectureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LectureInclude | null
  }



  /**
   * Model LiveChat
   */


  export type AggregateLiveChat = {
    count: LiveChatCountAggregateOutputType | null
    avg: LiveChatAvgAggregateOutputType | null
    sum: LiveChatSumAggregateOutputType | null
    min: LiveChatMinAggregateOutputType | null
    max: LiveChatMaxAggregateOutputType | null
  }

  export type LiveChatAvgAggregateOutputType = {
    id: number
    userId: number
  }

  export type LiveChatSumAggregateOutputType = {
    id: number
    userId: number
  }

  export type LiveChatMinAggregateOutputType = {
    id: number
    message: string | null
    createdAt: Date | null
    userId: number
    randomNickname: string | null
  }

  export type LiveChatMaxAggregateOutputType = {
    id: number
    message: string | null
    createdAt: Date | null
    userId: number
    randomNickname: string | null
  }

  export type LiveChatCountAggregateOutputType = {
    id: number
    message: number | null
    createdAt: number | null
    userId: number
    randomNickname: number | null
    _all: number
  }


  export type LiveChatAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LiveChatSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LiveChatMinAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    userId?: true
    randomNickname?: true
  }

  export type LiveChatMaxAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    userId?: true
    randomNickname?: true
  }

  export type LiveChatCountAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    userId?: true
    randomNickname?: true
    _all?: true
  }

  export type LiveChatAggregateArgs = {
    /**
     * Filter which LiveChat to aggregate.
    **/
    where?: LiveChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveChats to fetch.
    **/
    orderBy?: Enumerable<LiveChatOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: LiveChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveChats from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveChats.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiveChats
    **/
    count?: true | LiveChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: LiveChatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: LiveChatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: LiveChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: LiveChatMaxAggregateInputType
  }

  export type GetLiveChatAggregateType<T extends LiveChatAggregateArgs> = {
    [P in keyof T & keyof AggregateLiveChat]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiveChat[P]>
      : GetScalarType<T[P], AggregateLiveChat[P]>
  }


    
    
  export type LiveChatGroupByArgs = {
    where?: LiveChatWhereInput
    orderBy?: Enumerable<LiveChatOrderByInput>
    by: Array<LiveChatScalarFieldEnum>
    having?: LiveChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: LiveChatCountAggregateInputType | true
    avg?: LiveChatAvgAggregateInputType
    sum?: LiveChatSumAggregateInputType
    min?: LiveChatMinAggregateInputType
    max?: LiveChatMaxAggregateInputType
  }


  export type LiveChatGroupByOutputType = {
    id: number
    message: string
    createdAt: Date
    userId: number
    randomNickname: string
    count: LiveChatCountAggregateOutputType | null
    avg: LiveChatAvgAggregateOutputType | null
    sum: LiveChatSumAggregateOutputType | null
    min: LiveChatMinAggregateOutputType | null
    max: LiveChatMaxAggregateOutputType | null
  }

  type GetLiveChatGroupByPayload<T extends LiveChatGroupByArgs> = Promise<Array<
    PickArray<LiveChatGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof LiveChatGroupByOutputType))]: GetScalarType<T[P], LiveChatGroupByOutputType[P]>
    }
  >>
    

  export type LiveChatSelect = {
    id?: boolean
    message?: boolean
    createdAt?: boolean
    userId?: boolean
    randomNickname?: boolean
    user?: boolean | UserArgs
  }

  export type LiveChatInclude = {
    user?: boolean | UserArgs
  }

  export type LiveChatGetPayload<
    S extends boolean | null | undefined | LiveChatArgs,
    U = keyof S
      > = S extends true
        ? LiveChat
    : S extends undefined
    ? never
    : S extends LiveChatArgs | LiveChatFindManyArgs
    ?'include' extends U
    ? LiveChat  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LiveChat ?LiveChat [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : LiveChat
  : LiveChat


  type LiveChatCountArgs = Merge<
    Omit<LiveChatFindManyArgs, 'select' | 'include'> & {
      select?: LiveChatCountAggregateInputType | true
    }
  >

  export interface LiveChatDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one LiveChat that matches the filter.
     * @param {LiveChatFindUniqueArgs} args - Arguments to find a LiveChat
     * @example
     * // Get one LiveChat
     * const liveChat = await prisma.liveChat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LiveChatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LiveChatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LiveChat'> extends True ? CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>> : CheckSelect<T, Prisma__LiveChatClient<LiveChat | null >, Prisma__LiveChatClient<LiveChatGetPayload<T> | null >>

    /**
     * Find the first LiveChat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveChatFindFirstArgs} args - Arguments to find a LiveChat
     * @example
     * // Get one LiveChat
     * const liveChat = await prisma.liveChat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LiveChatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LiveChatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LiveChat'> extends True ? CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>> : CheckSelect<T, Prisma__LiveChatClient<LiveChat | null >, Prisma__LiveChatClient<LiveChatGetPayload<T> | null >>

    /**
     * Find zero or more LiveChats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveChatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiveChats
     * const liveChats = await prisma.liveChat.findMany()
     * 
     * // Get first 10 LiveChats
     * const liveChats = await prisma.liveChat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liveChatWithIdOnly = await prisma.liveChat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LiveChatFindManyArgs>(
      args?: SelectSubset<T, LiveChatFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LiveChat>>, PrismaPromise<Array<LiveChatGetPayload<T>>>>

    /**
     * Create a LiveChat.
     * @param {LiveChatCreateArgs} args - Arguments to create a LiveChat.
     * @example
     * // Create one LiveChat
     * const LiveChat = await prisma.liveChat.create({
     *   data: {
     *     // ... data to create a LiveChat
     *   }
     * })
     * 
    **/
    create<T extends LiveChatCreateArgs>(
      args: SelectSubset<T, LiveChatCreateArgs>
    ): CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>>

    /**
     * Create many LiveChats.
     *     @param {LiveChatCreateManyArgs} args - Arguments to create many LiveChats.
     *     @example
     *     // Create many LiveChats
     *     const liveChat = await prisma.liveChat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LiveChatCreateManyArgs>(
      args?: SelectSubset<T, LiveChatCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LiveChat.
     * @param {LiveChatDeleteArgs} args - Arguments to delete one LiveChat.
     * @example
     * // Delete one LiveChat
     * const LiveChat = await prisma.liveChat.delete({
     *   where: {
     *     // ... filter to delete one LiveChat
     *   }
     * })
     * 
    **/
    delete<T extends LiveChatDeleteArgs>(
      args: SelectSubset<T, LiveChatDeleteArgs>
    ): CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>>

    /**
     * Update one LiveChat.
     * @param {LiveChatUpdateArgs} args - Arguments to update one LiveChat.
     * @example
     * // Update one LiveChat
     * const liveChat = await prisma.liveChat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LiveChatUpdateArgs>(
      args: SelectSubset<T, LiveChatUpdateArgs>
    ): CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>>

    /**
     * Delete zero or more LiveChats.
     * @param {LiveChatDeleteManyArgs} args - Arguments to filter LiveChats to delete.
     * @example
     * // Delete a few LiveChats
     * const { count } = await prisma.liveChat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LiveChatDeleteManyArgs>(
      args?: SelectSubset<T, LiveChatDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiveChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiveChats
     * const liveChat = await prisma.liveChat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LiveChatUpdateManyArgs>(
      args: SelectSubset<T, LiveChatUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LiveChat.
     * @param {LiveChatUpsertArgs} args - Arguments to update or create a LiveChat.
     * @example
     * // Update or create a LiveChat
     * const liveChat = await prisma.liveChat.upsert({
     *   create: {
     *     // ... data to create a LiveChat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiveChat we want to update
     *   }
     * })
    **/
    upsert<T extends LiveChatUpsertArgs>(
      args: SelectSubset<T, LiveChatUpsertArgs>
    ): CheckSelect<T, Prisma__LiveChatClient<LiveChat>, Prisma__LiveChatClient<LiveChatGetPayload<T>>>

    /**
     * Count the number of LiveChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveChatCountArgs} args - Arguments to filter LiveChats to count.
     * @example
     * // Count the number of LiveChats
     * const count = await prisma.liveChat.count({
     *   where: {
     *     // ... the filter for the LiveChats we want to count
     *   }
     * })
    **/
    count<T extends LiveChatCountArgs>(
      args?: Subset<T, LiveChatCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiveChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiveChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiveChatAggregateArgs>(args: Subset<T, LiveChatAggregateArgs>): PrismaPromise<GetLiveChatAggregateType<T>>

    /**
     * Group by LiveChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiveChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiveChatGroupByArgs['orderBy'] }
        : { orderBy?: LiveChatGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiveChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiveChatGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiveChat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LiveChatClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * LiveChat findUnique
   */
  export type LiveChatFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * Throw an Error if a LiveChat can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LiveChat to fetch.
    **/
    where: LiveChatWhereUniqueInput
  }


  /**
   * LiveChat findFirst
   */
  export type LiveChatFindFirstArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * Throw an Error if a LiveChat can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LiveChat to fetch.
    **/
    where?: LiveChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveChats to fetch.
    **/
    orderBy?: Enumerable<LiveChatOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiveChats.
    **/
    cursor?: LiveChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveChats from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveChats.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiveChats.
    **/
    distinct?: Enumerable<LiveChatScalarFieldEnum>
  }


  /**
   * LiveChat findMany
   */
  export type LiveChatFindManyArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * Filter, which LiveChats to fetch.
    **/
    where?: LiveChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveChats to fetch.
    **/
    orderBy?: Enumerable<LiveChatOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiveChats.
    **/
    cursor?: LiveChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveChats from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveChats.
    **/
    skip?: number
    distinct?: Enumerable<LiveChatScalarFieldEnum>
  }


  /**
   * LiveChat create
   */
  export type LiveChatCreateArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * The data needed to create a LiveChat.
    **/
    data: XOR<LiveChatCreateInput, LiveChatUncheckedCreateInput>
  }


  /**
   * LiveChat createMany
   */
  export type LiveChatCreateManyArgs = {
    data: Enumerable<LiveChatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LiveChat update
   */
  export type LiveChatUpdateArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * The data needed to update a LiveChat.
    **/
    data: XOR<LiveChatUpdateInput, LiveChatUncheckedUpdateInput>
    /**
     * Choose, which LiveChat to update.
    **/
    where: LiveChatWhereUniqueInput
  }


  /**
   * LiveChat updateMany
   */
  export type LiveChatUpdateManyArgs = {
    data: XOR<LiveChatUpdateManyMutationInput, LiveChatUncheckedUpdateManyInput>
    where?: LiveChatWhereInput
  }


  /**
   * LiveChat upsert
   */
  export type LiveChatUpsertArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * The filter to search for the LiveChat to update in case it exists.
    **/
    where: LiveChatWhereUniqueInput
    /**
     * In case the LiveChat found by the `where` argument doesn't exist, create a new LiveChat with this data.
    **/
    create: XOR<LiveChatCreateInput, LiveChatUncheckedCreateInput>
    /**
     * In case the LiveChat was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<LiveChatUpdateInput, LiveChatUncheckedUpdateInput>
  }


  /**
   * LiveChat delete
   */
  export type LiveChatDeleteArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
    /**
     * Filter which LiveChat to delete.
    **/
    where: LiveChatWhereUniqueInput
  }


  /**
   * LiveChat deleteMany
   */
  export type LiveChatDeleteManyArgs = {
    where?: LiveChatWhereInput
  }


  /**
   * LiveChat without action
   */
  export type LiveChatArgs = {
    /**
     * Select specific fields to fetch from the LiveChat
    **/
    select?: LiveChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LiveChatInclude | null
  }



  /**
   * Model NoticeNotificationsSubscription
   */


  export type AggregateNoticeNotificationsSubscription = {
    count: NoticeNotificationsSubscriptionCountAggregateOutputType | null
    avg: NoticeNotificationsSubscriptionAvgAggregateOutputType | null
    sum: NoticeNotificationsSubscriptionSumAggregateOutputType | null
    min: NoticeNotificationsSubscriptionMinAggregateOutputType | null
    max: NoticeNotificationsSubscriptionMaxAggregateOutputType | null
  }

  export type NoticeNotificationsSubscriptionAvgAggregateOutputType = {
    id: number
    userId: number
  }

  export type NoticeNotificationsSubscriptionSumAggregateOutputType = {
    id: number
    userId: number
  }

  export type NoticeNotificationsSubscriptionMinAggregateOutputType = {
    id: number
    userId: number
    noticeKey: string | null
    subscribedAt: Date | null
  }

  export type NoticeNotificationsSubscriptionMaxAggregateOutputType = {
    id: number
    userId: number
    noticeKey: string | null
    subscribedAt: Date | null
  }

  export type NoticeNotificationsSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    noticeKey: number | null
    subscribedAt: number | null
    _all: number
  }


  export type NoticeNotificationsSubscriptionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NoticeNotificationsSubscriptionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NoticeNotificationsSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    noticeKey?: true
    subscribedAt?: true
  }

  export type NoticeNotificationsSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    noticeKey?: true
    subscribedAt?: true
  }

  export type NoticeNotificationsSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    noticeKey?: true
    subscribedAt?: true
    _all?: true
  }

  export type NoticeNotificationsSubscriptionAggregateArgs = {
    /**
     * Filter which NoticeNotificationsSubscription to aggregate.
    **/
    where?: NoticeNotificationsSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoticeNotificationsSubscriptions to fetch.
    **/
    orderBy?: Enumerable<NoticeNotificationsSubscriptionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: NoticeNotificationsSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoticeNotificationsSubscriptions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoticeNotificationsSubscriptions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoticeNotificationsSubscriptions
    **/
    count?: true | NoticeNotificationsSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: NoticeNotificationsSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: NoticeNotificationsSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: NoticeNotificationsSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: NoticeNotificationsSubscriptionMaxAggregateInputType
  }

  export type GetNoticeNotificationsSubscriptionAggregateType<T extends NoticeNotificationsSubscriptionAggregateArgs> = {
    [P in keyof T & keyof AggregateNoticeNotificationsSubscription]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoticeNotificationsSubscription[P]>
      : GetScalarType<T[P], AggregateNoticeNotificationsSubscription[P]>
  }


    
    
  export type NoticeNotificationsSubscriptionGroupByArgs = {
    where?: NoticeNotificationsSubscriptionWhereInput
    orderBy?: Enumerable<NoticeNotificationsSubscriptionOrderByInput>
    by: Array<NoticeNotificationsSubscriptionScalarFieldEnum>
    having?: NoticeNotificationsSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: NoticeNotificationsSubscriptionCountAggregateInputType | true
    avg?: NoticeNotificationsSubscriptionAvgAggregateInputType
    sum?: NoticeNotificationsSubscriptionSumAggregateInputType
    min?: NoticeNotificationsSubscriptionMinAggregateInputType
    max?: NoticeNotificationsSubscriptionMaxAggregateInputType
  }


  export type NoticeNotificationsSubscriptionGroupByOutputType = {
    id: number
    userId: number
    noticeKey: string
    subscribedAt: Date
    count: NoticeNotificationsSubscriptionCountAggregateOutputType | null
    avg: NoticeNotificationsSubscriptionAvgAggregateOutputType | null
    sum: NoticeNotificationsSubscriptionSumAggregateOutputType | null
    min: NoticeNotificationsSubscriptionMinAggregateOutputType | null
    max: NoticeNotificationsSubscriptionMaxAggregateOutputType | null
  }

  type GetNoticeNotificationsSubscriptionGroupByPayload<T extends NoticeNotificationsSubscriptionGroupByArgs> = Promise<Array<
    PickArray<NoticeNotificationsSubscriptionGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof NoticeNotificationsSubscriptionGroupByOutputType))]: GetScalarType<T[P], NoticeNotificationsSubscriptionGroupByOutputType[P]>
    }
  >>
    

  export type NoticeNotificationsSubscriptionSelect = {
    id?: boolean
    userId?: boolean
    noticeKey?: boolean
    subscribedAt?: boolean
    user?: boolean | UserArgs
  }

  export type NoticeNotificationsSubscriptionInclude = {
    user?: boolean | UserArgs
  }

  export type NoticeNotificationsSubscriptionGetPayload<
    S extends boolean | null | undefined | NoticeNotificationsSubscriptionArgs,
    U = keyof S
      > = S extends true
        ? NoticeNotificationsSubscription
    : S extends undefined
    ? never
    : S extends NoticeNotificationsSubscriptionArgs | NoticeNotificationsSubscriptionFindManyArgs
    ?'include' extends U
    ? NoticeNotificationsSubscription  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof NoticeNotificationsSubscription ?NoticeNotificationsSubscription [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : NoticeNotificationsSubscription
  : NoticeNotificationsSubscription


  type NoticeNotificationsSubscriptionCountArgs = Merge<
    Omit<NoticeNotificationsSubscriptionFindManyArgs, 'select' | 'include'> & {
      select?: NoticeNotificationsSubscriptionCountAggregateInputType | true
    }
  >

  export interface NoticeNotificationsSubscriptionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one NoticeNotificationsSubscription that matches the filter.
     * @param {NoticeNotificationsSubscriptionFindUniqueArgs} args - Arguments to find a NoticeNotificationsSubscription
     * @example
     * // Get one NoticeNotificationsSubscription
     * const noticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NoticeNotificationsSubscriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NoticeNotificationsSubscription'> extends True ? CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription | null >, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T> | null >>

    /**
     * Find the first NoticeNotificationsSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeNotificationsSubscriptionFindFirstArgs} args - Arguments to find a NoticeNotificationsSubscription
     * @example
     * // Get one NoticeNotificationsSubscription
     * const noticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NoticeNotificationsSubscriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NoticeNotificationsSubscriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NoticeNotificationsSubscription'> extends True ? CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription | null >, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T> | null >>

    /**
     * Find zero or more NoticeNotificationsSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeNotificationsSubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoticeNotificationsSubscriptions
     * const noticeNotificationsSubscriptions = await prisma.noticeNotificationsSubscription.findMany()
     * 
     * // Get first 10 NoticeNotificationsSubscriptions
     * const noticeNotificationsSubscriptions = await prisma.noticeNotificationsSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeNotificationsSubscriptionWithIdOnly = await prisma.noticeNotificationsSubscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NoticeNotificationsSubscriptionFindManyArgs>(
      args?: SelectSubset<T, NoticeNotificationsSubscriptionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<NoticeNotificationsSubscription>>, PrismaPromise<Array<NoticeNotificationsSubscriptionGetPayload<T>>>>

    /**
     * Create a NoticeNotificationsSubscription.
     * @param {NoticeNotificationsSubscriptionCreateArgs} args - Arguments to create a NoticeNotificationsSubscription.
     * @example
     * // Create one NoticeNotificationsSubscription
     * const NoticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.create({
     *   data: {
     *     // ... data to create a NoticeNotificationsSubscription
     *   }
     * })
     * 
    **/
    create<T extends NoticeNotificationsSubscriptionCreateArgs>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionCreateArgs>
    ): CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>>

    /**
     * Create many NoticeNotificationsSubscriptions.
     *     @param {NoticeNotificationsSubscriptionCreateManyArgs} args - Arguments to create many NoticeNotificationsSubscriptions.
     *     @example
     *     // Create many NoticeNotificationsSubscriptions
     *     const noticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NoticeNotificationsSubscriptionCreateManyArgs>(
      args?: SelectSubset<T, NoticeNotificationsSubscriptionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a NoticeNotificationsSubscription.
     * @param {NoticeNotificationsSubscriptionDeleteArgs} args - Arguments to delete one NoticeNotificationsSubscription.
     * @example
     * // Delete one NoticeNotificationsSubscription
     * const NoticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.delete({
     *   where: {
     *     // ... filter to delete one NoticeNotificationsSubscription
     *   }
     * })
     * 
    **/
    delete<T extends NoticeNotificationsSubscriptionDeleteArgs>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionDeleteArgs>
    ): CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>>

    /**
     * Update one NoticeNotificationsSubscription.
     * @param {NoticeNotificationsSubscriptionUpdateArgs} args - Arguments to update one NoticeNotificationsSubscription.
     * @example
     * // Update one NoticeNotificationsSubscription
     * const noticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NoticeNotificationsSubscriptionUpdateArgs>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionUpdateArgs>
    ): CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>>

    /**
     * Delete zero or more NoticeNotificationsSubscriptions.
     * @param {NoticeNotificationsSubscriptionDeleteManyArgs} args - Arguments to filter NoticeNotificationsSubscriptions to delete.
     * @example
     * // Delete a few NoticeNotificationsSubscriptions
     * const { count } = await prisma.noticeNotificationsSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NoticeNotificationsSubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, NoticeNotificationsSubscriptionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoticeNotificationsSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeNotificationsSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoticeNotificationsSubscriptions
     * const noticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NoticeNotificationsSubscriptionUpdateManyArgs>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one NoticeNotificationsSubscription.
     * @param {NoticeNotificationsSubscriptionUpsertArgs} args - Arguments to update or create a NoticeNotificationsSubscription.
     * @example
     * // Update or create a NoticeNotificationsSubscription
     * const noticeNotificationsSubscription = await prisma.noticeNotificationsSubscription.upsert({
     *   create: {
     *     // ... data to create a NoticeNotificationsSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoticeNotificationsSubscription we want to update
     *   }
     * })
    **/
    upsert<T extends NoticeNotificationsSubscriptionUpsertArgs>(
      args: SelectSubset<T, NoticeNotificationsSubscriptionUpsertArgs>
    ): CheckSelect<T, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscription>, Prisma__NoticeNotificationsSubscriptionClient<NoticeNotificationsSubscriptionGetPayload<T>>>

    /**
     * Count the number of NoticeNotificationsSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeNotificationsSubscriptionCountArgs} args - Arguments to filter NoticeNotificationsSubscriptions to count.
     * @example
     * // Count the number of NoticeNotificationsSubscriptions
     * const count = await prisma.noticeNotificationsSubscription.count({
     *   where: {
     *     // ... the filter for the NoticeNotificationsSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends NoticeNotificationsSubscriptionCountArgs>(
      args?: Subset<T, NoticeNotificationsSubscriptionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeNotificationsSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoticeNotificationsSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeNotificationsSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeNotificationsSubscriptionAggregateArgs>(args: Subset<T, NoticeNotificationsSubscriptionAggregateArgs>): PrismaPromise<GetNoticeNotificationsSubscriptionAggregateType<T>>

    /**
     * Group by NoticeNotificationsSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeNotificationsSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeNotificationsSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeNotificationsSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: NoticeNotificationsSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeNotificationsSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeNotificationsSubscriptionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoticeNotificationsSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NoticeNotificationsSubscriptionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * NoticeNotificationsSubscription findUnique
   */
  export type NoticeNotificationsSubscriptionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * Throw an Error if a NoticeNotificationsSubscription can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NoticeNotificationsSubscription to fetch.
    **/
    where: NoticeNotificationsSubscriptionWhereUniqueInput
  }


  /**
   * NoticeNotificationsSubscription findFirst
   */
  export type NoticeNotificationsSubscriptionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * Throw an Error if a NoticeNotificationsSubscription can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NoticeNotificationsSubscription to fetch.
    **/
    where?: NoticeNotificationsSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoticeNotificationsSubscriptions to fetch.
    **/
    orderBy?: Enumerable<NoticeNotificationsSubscriptionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoticeNotificationsSubscriptions.
    **/
    cursor?: NoticeNotificationsSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoticeNotificationsSubscriptions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoticeNotificationsSubscriptions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoticeNotificationsSubscriptions.
    **/
    distinct?: Enumerable<NoticeNotificationsSubscriptionScalarFieldEnum>
  }


  /**
   * NoticeNotificationsSubscription findMany
   */
  export type NoticeNotificationsSubscriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * Filter, which NoticeNotificationsSubscriptions to fetch.
    **/
    where?: NoticeNotificationsSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoticeNotificationsSubscriptions to fetch.
    **/
    orderBy?: Enumerable<NoticeNotificationsSubscriptionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoticeNotificationsSubscriptions.
    **/
    cursor?: NoticeNotificationsSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoticeNotificationsSubscriptions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoticeNotificationsSubscriptions.
    **/
    skip?: number
    distinct?: Enumerable<NoticeNotificationsSubscriptionScalarFieldEnum>
  }


  /**
   * NoticeNotificationsSubscription create
   */
  export type NoticeNotificationsSubscriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * The data needed to create a NoticeNotificationsSubscription.
    **/
    data: XOR<NoticeNotificationsSubscriptionCreateInput, NoticeNotificationsSubscriptionUncheckedCreateInput>
  }


  /**
   * NoticeNotificationsSubscription createMany
   */
  export type NoticeNotificationsSubscriptionCreateManyArgs = {
    data: Enumerable<NoticeNotificationsSubscriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NoticeNotificationsSubscription update
   */
  export type NoticeNotificationsSubscriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * The data needed to update a NoticeNotificationsSubscription.
    **/
    data: XOR<NoticeNotificationsSubscriptionUpdateInput, NoticeNotificationsSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which NoticeNotificationsSubscription to update.
    **/
    where: NoticeNotificationsSubscriptionWhereUniqueInput
  }


  /**
   * NoticeNotificationsSubscription updateMany
   */
  export type NoticeNotificationsSubscriptionUpdateManyArgs = {
    data: XOR<NoticeNotificationsSubscriptionUpdateManyMutationInput, NoticeNotificationsSubscriptionUncheckedUpdateManyInput>
    where?: NoticeNotificationsSubscriptionWhereInput
  }


  /**
   * NoticeNotificationsSubscription upsert
   */
  export type NoticeNotificationsSubscriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * The filter to search for the NoticeNotificationsSubscription to update in case it exists.
    **/
    where: NoticeNotificationsSubscriptionWhereUniqueInput
    /**
     * In case the NoticeNotificationsSubscription found by the `where` argument doesn't exist, create a new NoticeNotificationsSubscription with this data.
    **/
    create: XOR<NoticeNotificationsSubscriptionCreateInput, NoticeNotificationsSubscriptionUncheckedCreateInput>
    /**
     * In case the NoticeNotificationsSubscription was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<NoticeNotificationsSubscriptionUpdateInput, NoticeNotificationsSubscriptionUncheckedUpdateInput>
  }


  /**
   * NoticeNotificationsSubscription delete
   */
  export type NoticeNotificationsSubscriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
    /**
     * Filter which NoticeNotificationsSubscription to delete.
    **/
    where: NoticeNotificationsSubscriptionWhereUniqueInput
  }


  /**
   * NoticeNotificationsSubscription deleteMany
   */
  export type NoticeNotificationsSubscriptionDeleteManyArgs = {
    where?: NoticeNotificationsSubscriptionWhereInput
  }


  /**
   * NoticeNotificationsSubscription without action
   */
  export type NoticeNotificationsSubscriptionArgs = {
    /**
     * Select specific fields to fetch from the NoticeNotificationsSubscription
    **/
    select?: NoticeNotificationsSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NoticeNotificationsSubscriptionInclude | null
  }



  /**
   * Model PendingUser
   */


  export type AggregatePendingUser = {
    count: PendingUserCountAggregateOutputType | null
    avg: PendingUserAvgAggregateOutputType | null
    sum: PendingUserSumAggregateOutputType | null
    min: PendingUserMinAggregateOutputType | null
    max: PendingUserMaxAggregateOutputType | null
  }

  export type PendingUserAvgAggregateOutputType = {
    id: number
  }

  export type PendingUserSumAggregateOutputType = {
    id: number
  }

  export type PendingUserMinAggregateOutputType = {
    id: number
    portalId: string | null
    password: string | null
    nickname: string | null
    randomNickname: string | null
    joinedAt: Date | null
    token: string | null
  }

  export type PendingUserMaxAggregateOutputType = {
    id: number
    portalId: string | null
    password: string | null
    nickname: string | null
    randomNickname: string | null
    joinedAt: Date | null
    token: string | null
  }

  export type PendingUserCountAggregateOutputType = {
    id: number
    portalId: number | null
    password: number | null
    nickname: number | null
    randomNickname: number | null
    joinedAt: number | null
    token: number | null
    _all: number
  }


  export type PendingUserAvgAggregateInputType = {
    id?: true
  }

  export type PendingUserSumAggregateInputType = {
    id?: true
  }

  export type PendingUserMinAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    joinedAt?: true
    token?: true
  }

  export type PendingUserMaxAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    joinedAt?: true
    token?: true
  }

  export type PendingUserCountAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    joinedAt?: true
    token?: true
    _all?: true
  }

  export type PendingUserAggregateArgs = {
    /**
     * Filter which PendingUser to aggregate.
    **/
    where?: PendingUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingUsers to fetch.
    **/
    orderBy?: Enumerable<PendingUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PendingUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingUsers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingUsers
    **/
    count?: true | PendingUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PendingUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PendingUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PendingUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PendingUserMaxAggregateInputType
  }

  export type GetPendingUserAggregateType<T extends PendingUserAggregateArgs> = {
    [P in keyof T & keyof AggregatePendingUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingUser[P]>
      : GetScalarType<T[P], AggregatePendingUser[P]>
  }


    
    
  export type PendingUserGroupByArgs = {
    where?: PendingUserWhereInput
    orderBy?: Enumerable<PendingUserOrderByInput>
    by: Array<PendingUserScalarFieldEnum>
    having?: PendingUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: PendingUserCountAggregateInputType | true
    avg?: PendingUserAvgAggregateInputType
    sum?: PendingUserSumAggregateInputType
    min?: PendingUserMinAggregateInputType
    max?: PendingUserMaxAggregateInputType
  }


  export type PendingUserGroupByOutputType = {
    id: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date
    token: string
    count: PendingUserCountAggregateOutputType | null
    avg: PendingUserAvgAggregateOutputType | null
    sum: PendingUserSumAggregateOutputType | null
    min: PendingUserMinAggregateOutputType | null
    max: PendingUserMaxAggregateOutputType | null
  }

  type GetPendingUserGroupByPayload<T extends PendingUserGroupByArgs> = Promise<Array<
    PickArray<PendingUserGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof PendingUserGroupByOutputType))]: GetScalarType<T[P], PendingUserGroupByOutputType[P]>
    }
  >>
    

  export type PendingUserSelect = {
    id?: boolean
    portalId?: boolean
    password?: boolean
    nickname?: boolean
    randomNickname?: boolean
    joinedAt?: boolean
    token?: boolean
  }

  export type PendingUserGetPayload<
    S extends boolean | null | undefined | PendingUserArgs,
    U = keyof S
      > = S extends true
        ? PendingUser
    : S extends undefined
    ? never
    : S extends PendingUserArgs | PendingUserFindManyArgs
    ?'include' extends U
    ? PendingUser 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PendingUser ?PendingUser [P]
  : 
     never
  } 
    : PendingUser
  : PendingUser


  type PendingUserCountArgs = Merge<
    Omit<PendingUserFindManyArgs, 'select' | 'include'> & {
      select?: PendingUserCountAggregateInputType | true
    }
  >

  export interface PendingUserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PendingUser that matches the filter.
     * @param {PendingUserFindUniqueArgs} args - Arguments to find a PendingUser
     * @example
     * // Get one PendingUser
     * const pendingUser = await prisma.pendingUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PendingUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PendingUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PendingUser'> extends True ? CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>> : CheckSelect<T, Prisma__PendingUserClient<PendingUser | null >, Prisma__PendingUserClient<PendingUserGetPayload<T> | null >>

    /**
     * Find the first PendingUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingUserFindFirstArgs} args - Arguments to find a PendingUser
     * @example
     * // Get one PendingUser
     * const pendingUser = await prisma.pendingUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PendingUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PendingUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PendingUser'> extends True ? CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>> : CheckSelect<T, Prisma__PendingUserClient<PendingUser | null >, Prisma__PendingUserClient<PendingUserGetPayload<T> | null >>

    /**
     * Find zero or more PendingUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingUsers
     * const pendingUsers = await prisma.pendingUser.findMany()
     * 
     * // Get first 10 PendingUsers
     * const pendingUsers = await prisma.pendingUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingUserWithIdOnly = await prisma.pendingUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PendingUserFindManyArgs>(
      args?: SelectSubset<T, PendingUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PendingUser>>, PrismaPromise<Array<PendingUserGetPayload<T>>>>

    /**
     * Create a PendingUser.
     * @param {PendingUserCreateArgs} args - Arguments to create a PendingUser.
     * @example
     * // Create one PendingUser
     * const PendingUser = await prisma.pendingUser.create({
     *   data: {
     *     // ... data to create a PendingUser
     *   }
     * })
     * 
    **/
    create<T extends PendingUserCreateArgs>(
      args: SelectSubset<T, PendingUserCreateArgs>
    ): CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>>

    /**
     * Create many PendingUsers.
     *     @param {PendingUserCreateManyArgs} args - Arguments to create many PendingUsers.
     *     @example
     *     // Create many PendingUsers
     *     const pendingUser = await prisma.pendingUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PendingUserCreateManyArgs>(
      args?: SelectSubset<T, PendingUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PendingUser.
     * @param {PendingUserDeleteArgs} args - Arguments to delete one PendingUser.
     * @example
     * // Delete one PendingUser
     * const PendingUser = await prisma.pendingUser.delete({
     *   where: {
     *     // ... filter to delete one PendingUser
     *   }
     * })
     * 
    **/
    delete<T extends PendingUserDeleteArgs>(
      args: SelectSubset<T, PendingUserDeleteArgs>
    ): CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>>

    /**
     * Update one PendingUser.
     * @param {PendingUserUpdateArgs} args - Arguments to update one PendingUser.
     * @example
     * // Update one PendingUser
     * const pendingUser = await prisma.pendingUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PendingUserUpdateArgs>(
      args: SelectSubset<T, PendingUserUpdateArgs>
    ): CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>>

    /**
     * Delete zero or more PendingUsers.
     * @param {PendingUserDeleteManyArgs} args - Arguments to filter PendingUsers to delete.
     * @example
     * // Delete a few PendingUsers
     * const { count } = await prisma.pendingUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PendingUserDeleteManyArgs>(
      args?: SelectSubset<T, PendingUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingUsers
     * const pendingUser = await prisma.pendingUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PendingUserUpdateManyArgs>(
      args: SelectSubset<T, PendingUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PendingUser.
     * @param {PendingUserUpsertArgs} args - Arguments to update or create a PendingUser.
     * @example
     * // Update or create a PendingUser
     * const pendingUser = await prisma.pendingUser.upsert({
     *   create: {
     *     // ... data to create a PendingUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingUser we want to update
     *   }
     * })
    **/
    upsert<T extends PendingUserUpsertArgs>(
      args: SelectSubset<T, PendingUserUpsertArgs>
    ): CheckSelect<T, Prisma__PendingUserClient<PendingUser>, Prisma__PendingUserClient<PendingUserGetPayload<T>>>

    /**
     * Count the number of PendingUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingUserCountArgs} args - Arguments to filter PendingUsers to count.
     * @example
     * // Count the number of PendingUsers
     * const count = await prisma.pendingUser.count({
     *   where: {
     *     // ... the filter for the PendingUsers we want to count
     *   }
     * })
    **/
    count<T extends PendingUserCountArgs>(
      args?: Subset<T, PendingUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingUserAggregateArgs>(args: Subset<T, PendingUserAggregateArgs>): PrismaPromise<GetPendingUserAggregateType<T>>

    /**
     * Group by PendingUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingUserGroupByArgs['orderBy'] }
        : { orderBy?: PendingUserGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PendingUserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PendingUser findUnique
   */
  export type PendingUserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * Throw an Error if a PendingUser can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PendingUser to fetch.
    **/
    where: PendingUserWhereUniqueInput
  }


  /**
   * PendingUser findFirst
   */
  export type PendingUserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * Throw an Error if a PendingUser can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PendingUser to fetch.
    **/
    where?: PendingUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingUsers to fetch.
    **/
    orderBy?: Enumerable<PendingUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingUsers.
    **/
    cursor?: PendingUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingUsers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingUsers.
    **/
    distinct?: Enumerable<PendingUserScalarFieldEnum>
  }


  /**
   * PendingUser findMany
   */
  export type PendingUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * Filter, which PendingUsers to fetch.
    **/
    where?: PendingUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingUsers to fetch.
    **/
    orderBy?: Enumerable<PendingUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingUsers.
    **/
    cursor?: PendingUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingUsers.
    **/
    skip?: number
    distinct?: Enumerable<PendingUserScalarFieldEnum>
  }


  /**
   * PendingUser create
   */
  export type PendingUserCreateArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * The data needed to create a PendingUser.
    **/
    data: XOR<PendingUserCreateInput, PendingUserUncheckedCreateInput>
  }


  /**
   * PendingUser createMany
   */
  export type PendingUserCreateManyArgs = {
    data: Enumerable<PendingUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PendingUser update
   */
  export type PendingUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * The data needed to update a PendingUser.
    **/
    data: XOR<PendingUserUpdateInput, PendingUserUncheckedUpdateInput>
    /**
     * Choose, which PendingUser to update.
    **/
    where: PendingUserWhereUniqueInput
  }


  /**
   * PendingUser updateMany
   */
  export type PendingUserUpdateManyArgs = {
    data: XOR<PendingUserUpdateManyMutationInput, PendingUserUncheckedUpdateManyInput>
    where?: PendingUserWhereInput
  }


  /**
   * PendingUser upsert
   */
  export type PendingUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * The filter to search for the PendingUser to update in case it exists.
    **/
    where: PendingUserWhereUniqueInput
    /**
     * In case the PendingUser found by the `where` argument doesn't exist, create a new PendingUser with this data.
    **/
    create: XOR<PendingUserCreateInput, PendingUserUncheckedCreateInput>
    /**
     * In case the PendingUser was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PendingUserUpdateInput, PendingUserUncheckedUpdateInput>
  }


  /**
   * PendingUser delete
   */
  export type PendingUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
    /**
     * Filter which PendingUser to delete.
    **/
    where: PendingUserWhereUniqueInput
  }


  /**
   * PendingUser deleteMany
   */
  export type PendingUserDeleteManyArgs = {
    where?: PendingUserWhereInput
  }


  /**
   * PendingUser without action
   */
  export type PendingUserArgs = {
    /**
     * Select specific fields to fetch from the PendingUser
    **/
    select?: PendingUserSelect | null
  }



  /**
   * Model Period
   */


  export type AggregatePeriod = {
    count: PeriodCountAggregateOutputType | null
    avg: PeriodAvgAggregateOutputType | null
    sum: PeriodSumAggregateOutputType | null
    min: PeriodMinAggregateOutputType | null
    max: PeriodMaxAggregateOutputType | null
  }

  export type PeriodAvgAggregateOutputType = {
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodSumAggregateOutputType = {
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodMinAggregateOutputType = {
    lectureId: string | null
    day: string | null
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodMaxAggregateOutputType = {
    lectureId: string | null
    day: string | null
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodCountAggregateOutputType = {
    lectureId: number | null
    day: number | null
    startH: number
    startM: number
    endH: number
    endM: number
    _all: number
  }


  export type PeriodAvgAggregateInputType = {
    startH?: true
    startM?: true
    endH?: true
    endM?: true
  }

  export type PeriodSumAggregateInputType = {
    startH?: true
    startM?: true
    endH?: true
    endM?: true
  }

  export type PeriodMinAggregateInputType = {
    lectureId?: true
    day?: true
    startH?: true
    startM?: true
    endH?: true
    endM?: true
  }

  export type PeriodMaxAggregateInputType = {
    lectureId?: true
    day?: true
    startH?: true
    startM?: true
    endH?: true
    endM?: true
  }

  export type PeriodCountAggregateInputType = {
    lectureId?: true
    day?: true
    startH?: true
    startM?: true
    endH?: true
    endM?: true
    _all?: true
  }

  export type PeriodAggregateArgs = {
    /**
     * Filter which Period to aggregate.
    **/
    where?: PeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Periods to fetch.
    **/
    orderBy?: Enumerable<PeriodOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Periods
    **/
    count?: true | PeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PeriodMaxAggregateInputType
  }

  export type GetPeriodAggregateType<T extends PeriodAggregateArgs> = {
    [P in keyof T & keyof AggregatePeriod]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeriod[P]>
      : GetScalarType<T[P], AggregatePeriod[P]>
  }


    
    
  export type PeriodGroupByArgs = {
    where?: PeriodWhereInput
    orderBy?: Enumerable<PeriodOrderByInput>
    by: Array<PeriodScalarFieldEnum>
    having?: PeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: PeriodCountAggregateInputType | true
    avg?: PeriodAvgAggregateInputType
    sum?: PeriodSumAggregateInputType
    min?: PeriodMinAggregateInputType
    max?: PeriodMaxAggregateInputType
  }


  export type PeriodGroupByOutputType = {
    lectureId: string
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
    count: PeriodCountAggregateOutputType | null
    avg: PeriodAvgAggregateOutputType | null
    sum: PeriodSumAggregateOutputType | null
    min: PeriodMinAggregateOutputType | null
    max: PeriodMaxAggregateOutputType | null
  }

  type GetPeriodGroupByPayload<T extends PeriodGroupByArgs> = Promise<Array<
    PickArray<PeriodGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof PeriodGroupByOutputType))]: GetScalarType<T[P], PeriodGroupByOutputType[P]>
    }
  >>
    

  export type PeriodSelect = {
    lectureId?: boolean
    day?: boolean
    startH?: boolean
    startM?: boolean
    endH?: boolean
    endM?: boolean
    lecture?: boolean | LectureArgs
  }

  export type PeriodInclude = {
    lecture?: boolean | LectureArgs
  }

  export type PeriodGetPayload<
    S extends boolean | null | undefined | PeriodArgs,
    U = keyof S
      > = S extends true
        ? Period
    : S extends undefined
    ? never
    : S extends PeriodArgs | PeriodFindManyArgs
    ?'include' extends U
    ? Period  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'lecture'
        ? LectureGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Period ?Period [P]
  : 
          P extends 'lecture'
        ? LectureGetPayload<S['select'][P]> : never
  } 
    : Period
  : Period


  type PeriodCountArgs = Merge<
    Omit<PeriodFindManyArgs, 'select' | 'include'> & {
      select?: PeriodCountAggregateInputType | true
    }
  >

  export interface PeriodDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Period that matches the filter.
     * @param {PeriodFindUniqueArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PeriodFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PeriodFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Period'> extends True ? CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>> : CheckSelect<T, Prisma__PeriodClient<Period | null >, Prisma__PeriodClient<PeriodGetPayload<T> | null >>

    /**
     * Find the first Period that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodFindFirstArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PeriodFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PeriodFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Period'> extends True ? CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>> : CheckSelect<T, Prisma__PeriodClient<Period | null >, Prisma__PeriodClient<PeriodGetPayload<T> | null >>

    /**
     * Find zero or more Periods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Periods
     * const periods = await prisma.period.findMany()
     * 
     * // Get first 10 Periods
     * const periods = await prisma.period.findMany({ take: 10 })
     * 
     * // Only select the `lectureId`
     * const periodWithLectureIdOnly = await prisma.period.findMany({ select: { lectureId: true } })
     * 
    **/
    findMany<T extends PeriodFindManyArgs>(
      args?: SelectSubset<T, PeriodFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Period>>, PrismaPromise<Array<PeriodGetPayload<T>>>>

    /**
     * Create a Period.
     * @param {PeriodCreateArgs} args - Arguments to create a Period.
     * @example
     * // Create one Period
     * const Period = await prisma.period.create({
     *   data: {
     *     // ... data to create a Period
     *   }
     * })
     * 
    **/
    create<T extends PeriodCreateArgs>(
      args: SelectSubset<T, PeriodCreateArgs>
    ): CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>>

    /**
     * Create many Periods.
     *     @param {PeriodCreateManyArgs} args - Arguments to create many Periods.
     *     @example
     *     // Create many Periods
     *     const period = await prisma.period.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PeriodCreateManyArgs>(
      args?: SelectSubset<T, PeriodCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Period.
     * @param {PeriodDeleteArgs} args - Arguments to delete one Period.
     * @example
     * // Delete one Period
     * const Period = await prisma.period.delete({
     *   where: {
     *     // ... filter to delete one Period
     *   }
     * })
     * 
    **/
    delete<T extends PeriodDeleteArgs>(
      args: SelectSubset<T, PeriodDeleteArgs>
    ): CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>>

    /**
     * Update one Period.
     * @param {PeriodUpdateArgs} args - Arguments to update one Period.
     * @example
     * // Update one Period
     * const period = await prisma.period.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PeriodUpdateArgs>(
      args: SelectSubset<T, PeriodUpdateArgs>
    ): CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>>

    /**
     * Delete zero or more Periods.
     * @param {PeriodDeleteManyArgs} args - Arguments to filter Periods to delete.
     * @example
     * // Delete a few Periods
     * const { count } = await prisma.period.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PeriodDeleteManyArgs>(
      args?: SelectSubset<T, PeriodDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Periods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Periods
     * const period = await prisma.period.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PeriodUpdateManyArgs>(
      args: SelectSubset<T, PeriodUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Period.
     * @param {PeriodUpsertArgs} args - Arguments to update or create a Period.
     * @example
     * // Update or create a Period
     * const period = await prisma.period.upsert({
     *   create: {
     *     // ... data to create a Period
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Period we want to update
     *   }
     * })
    **/
    upsert<T extends PeriodUpsertArgs>(
      args: SelectSubset<T, PeriodUpsertArgs>
    ): CheckSelect<T, Prisma__PeriodClient<Period>, Prisma__PeriodClient<PeriodGetPayload<T>>>

    /**
     * Count the number of Periods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodCountArgs} args - Arguments to filter Periods to count.
     * @example
     * // Count the number of Periods
     * const count = await prisma.period.count({
     *   where: {
     *     // ... the filter for the Periods we want to count
     *   }
     * })
    **/
    count<T extends PeriodCountArgs>(
      args?: Subset<T, PeriodCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Period.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeriodAggregateArgs>(args: Subset<T, PeriodAggregateArgs>): PrismaPromise<GetPeriodAggregateType<T>>

    /**
     * Group by Period.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PeriodGroupByArgs['orderBy'] }
        : { orderBy?: PeriodGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeriodGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Period.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PeriodClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    lecture<T extends LectureArgs = {}>(args?: Subset<T, LectureArgs>): CheckSelect<T, Prisma__LectureClient<Lecture | null >, Prisma__LectureClient<LectureGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Period findUnique
   */
  export type PeriodFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * Throw an Error if a Period can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Period to fetch.
    **/
    where: PeriodWhereUniqueInput
  }


  /**
   * Period findFirst
   */
  export type PeriodFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * Throw an Error if a Period can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Period to fetch.
    **/
    where?: PeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Periods to fetch.
    **/
    orderBy?: Enumerable<PeriodOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Periods.
    **/
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Periods.
    **/
    distinct?: Enumerable<PeriodScalarFieldEnum>
  }


  /**
   * Period findMany
   */
  export type PeriodFindManyArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * Filter, which Periods to fetch.
    **/
    where?: PeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Periods to fetch.
    **/
    orderBy?: Enumerable<PeriodOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Periods.
    **/
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
    **/
    skip?: number
    distinct?: Enumerable<PeriodScalarFieldEnum>
  }


  /**
   * Period create
   */
  export type PeriodCreateArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * The data needed to create a Period.
    **/
    data: XOR<PeriodCreateInput, PeriodUncheckedCreateInput>
  }


  /**
   * Period createMany
   */
  export type PeriodCreateManyArgs = {
    data: Enumerable<PeriodCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Period update
   */
  export type PeriodUpdateArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * The data needed to update a Period.
    **/
    data: XOR<PeriodUpdateInput, PeriodUncheckedUpdateInput>
    /**
     * Choose, which Period to update.
    **/
    where: PeriodWhereUniqueInput
  }


  /**
   * Period updateMany
   */
  export type PeriodUpdateManyArgs = {
    data: XOR<PeriodUpdateManyMutationInput, PeriodUncheckedUpdateManyInput>
    where?: PeriodWhereInput
  }


  /**
   * Period upsert
   */
  export type PeriodUpsertArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * The filter to search for the Period to update in case it exists.
    **/
    where: PeriodWhereUniqueInput
    /**
     * In case the Period found by the `where` argument doesn't exist, create a new Period with this data.
    **/
    create: XOR<PeriodCreateInput, PeriodUncheckedCreateInput>
    /**
     * In case the Period was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PeriodUpdateInput, PeriodUncheckedUpdateInput>
  }


  /**
   * Period delete
   */
  export type PeriodDeleteArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
    /**
     * Filter which Period to delete.
    **/
    where: PeriodWhereUniqueInput
  }


  /**
   * Period deleteMany
   */
  export type PeriodDeleteManyArgs = {
    where?: PeriodWhereInput
  }


  /**
   * Period without action
   */
  export type PeriodArgs = {
    /**
     * Select specific fields to fetch from the Period
    **/
    select?: PeriodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PeriodInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    count: UserCountAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number
    point: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number
    point: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number
    portalId: string | null
    password: string | null
    nickname: string | null
    randomNickname: string | null
    point: number | null
    joinedAt: Date | null
    refreshToken: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number
    portalId: string | null
    password: string | null
    nickname: string | null
    randomNickname: string | null
    point: number | null
    joinedAt: Date | null
    refreshToken: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    portalId: number | null
    password: number | null
    nickname: number | null
    randomNickname: number | null
    point: number | null
    joinedAt: number | null
    refreshToken: number | null
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    point?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    point?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    point?: true
    joinedAt?: true
    refreshToken?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    point?: true
    joinedAt?: true
    refreshToken?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    portalId?: true
    password?: true
    nickname?: true
    randomNickname?: true
    point?: true
    joinedAt?: true
    refreshToken?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: UserCountAggregateInputType | true
    avg?: UserAvgAggregateInputType
    sum?: UserSumAggregateInputType
    min?: UserMinAggregateInputType
    max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point: number | null
    joinedAt: Date
    refreshToken: string | null
    count: UserCountAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<Array<
    PickArray<UserGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof UserGroupByOutputType))]: GetScalarType<T[P], UserGroupByOutputType[P]>
    }
  >>
    

  export type UserSelect = {
    id?: boolean
    portalId?: boolean
    password?: boolean
    nickname?: boolean
    randomNickname?: boolean
    point?: boolean
    joinedAt?: boolean
    refreshToken?: boolean
    admin?: boolean | AdminArgs
    changePassword?: boolean | ChangePasswordArgs
    communityBoards?: boolean | CommunityBoardFindManyArgs
    communityBoardCandidates?: boolean | CommunityBoardCandidateFindManyArgs
    communityBoardCandidateVotes?: boolean | CommunityBoardCandidateVoteFindManyArgs
    communityBoardPins?: boolean | CommunityBoardPinFindManyArgs
    communityComments?: boolean | CommunityCommentFindManyArgs
    communityPosts?: boolean | CommunityPostFindManyArgs
    communityPostBookmarks?: boolean | CommunityPostBookmarkFindManyArgs
    communityPostLikes?: boolean | CommunityPostLikeFindManyArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    liveChats?: boolean | LiveChatFindManyArgs
    noticeNotificationsSubscriptions?: boolean | NoticeNotificationsSubscriptionFindManyArgs
    reportComments?: boolean | ReportCommentFindManyArgs
    reportPosts?: boolean | ReportPostFindManyArgs
    reportSubcomments?: boolean | ReportSubcommentFindManyArgs
    telegrams?: boolean | TelegramFindManyArgs
  }

  export type UserInclude = {
    admin?: boolean | AdminArgs
    changePassword?: boolean | ChangePasswordArgs
    communityBoards?: boolean | CommunityBoardFindManyArgs
    communityBoardCandidates?: boolean | CommunityBoardCandidateFindManyArgs
    communityBoardCandidateVotes?: boolean | CommunityBoardCandidateVoteFindManyArgs
    communityBoardPins?: boolean | CommunityBoardPinFindManyArgs
    communityComments?: boolean | CommunityCommentFindManyArgs
    communityPosts?: boolean | CommunityPostFindManyArgs
    communityPostBookmarks?: boolean | CommunityPostBookmarkFindManyArgs
    communityPostLikes?: boolean | CommunityPostLikeFindManyArgs
    communitySubcomments?: boolean | CommunitySubcommentFindManyArgs
    liveChats?: boolean | LiveChatFindManyArgs
    noticeNotificationsSubscriptions?: boolean | NoticeNotificationsSubscriptionFindManyArgs
    reportComments?: boolean | ReportCommentFindManyArgs
    reportPosts?: boolean | ReportPostFindManyArgs
    reportSubcomments?: boolean | ReportSubcommentFindManyArgs
    telegrams?: boolean | TelegramFindManyArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'admin'
        ? AdminGetPayload<S['include'][P]> | null :
        P extends 'changePassword'
        ? ChangePasswordGetPayload<S['include'][P]> | null :
        P extends 'communityBoards'
        ? Array < CommunityBoardGetPayload<S['include'][P]>>  :
        P extends 'communityBoardCandidates'
        ? Array < CommunityBoardCandidateGetPayload<S['include'][P]>>  :
        P extends 'communityBoardCandidateVotes'
        ? Array < CommunityBoardCandidateVoteGetPayload<S['include'][P]>>  :
        P extends 'communityBoardPins'
        ? Array < CommunityBoardPinGetPayload<S['include'][P]>>  :
        P extends 'communityComments'
        ? Array < CommunityCommentGetPayload<S['include'][P]>>  :
        P extends 'communityPosts'
        ? Array < CommunityPostGetPayload<S['include'][P]>>  :
        P extends 'communityPostBookmarks'
        ? Array < CommunityPostBookmarkGetPayload<S['include'][P]>>  :
        P extends 'communityPostLikes'
        ? Array < CommunityPostLikeGetPayload<S['include'][P]>>  :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['include'][P]>>  :
        P extends 'liveChats'
        ? Array < LiveChatGetPayload<S['include'][P]>>  :
        P extends 'noticeNotificationsSubscriptions'
        ? Array < NoticeNotificationsSubscriptionGetPayload<S['include'][P]>>  :
        P extends 'reportComments'
        ? Array < ReportCommentGetPayload<S['include'][P]>>  :
        P extends 'reportPosts'
        ? Array < ReportPostGetPayload<S['include'][P]>>  :
        P extends 'reportSubcomments'
        ? Array < ReportSubcommentGetPayload<S['include'][P]>>  :
        P extends 'telegrams'
        ? Array < TelegramGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'admin'
        ? AdminGetPayload<S['select'][P]> | null :
        P extends 'changePassword'
        ? ChangePasswordGetPayload<S['select'][P]> | null :
        P extends 'communityBoards'
        ? Array < CommunityBoardGetPayload<S['select'][P]>>  :
        P extends 'communityBoardCandidates'
        ? Array < CommunityBoardCandidateGetPayload<S['select'][P]>>  :
        P extends 'communityBoardCandidateVotes'
        ? Array < CommunityBoardCandidateVoteGetPayload<S['select'][P]>>  :
        P extends 'communityBoardPins'
        ? Array < CommunityBoardPinGetPayload<S['select'][P]>>  :
        P extends 'communityComments'
        ? Array < CommunityCommentGetPayload<S['select'][P]>>  :
        P extends 'communityPosts'
        ? Array < CommunityPostGetPayload<S['select'][P]>>  :
        P extends 'communityPostBookmarks'
        ? Array < CommunityPostBookmarkGetPayload<S['select'][P]>>  :
        P extends 'communityPostLikes'
        ? Array < CommunityPostLikeGetPayload<S['select'][P]>>  :
        P extends 'communitySubcomments'
        ? Array < CommunitySubcommentGetPayload<S['select'][P]>>  :
        P extends 'liveChats'
        ? Array < LiveChatGetPayload<S['select'][P]>>  :
        P extends 'noticeNotificationsSubscriptions'
        ? Array < NoticeNotificationsSubscriptionGetPayload<S['select'][P]>>  :
        P extends 'reportComments'
        ? Array < ReportCommentGetPayload<S['select'][P]>>  :
        P extends 'reportPosts'
        ? Array < ReportPostGetPayload<S['select'][P]>>  :
        P extends 'reportSubcomments'
        ? Array < ReportSubcommentGetPayload<S['select'][P]>>  :
        P extends 'telegrams'
        ? Array < TelegramGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    admin<T extends AdminArgs = {}>(args?: Subset<T, AdminArgs>): CheckSelect<T, Prisma__AdminClient<Admin | null >, Prisma__AdminClient<AdminGetPayload<T> | null >>;

    changePassword<T extends ChangePasswordArgs = {}>(args?: Subset<T, ChangePasswordArgs>): CheckSelect<T, Prisma__ChangePasswordClient<ChangePassword | null >, Prisma__ChangePasswordClient<ChangePasswordGetPayload<T> | null >>;

    communityBoards<T extends CommunityBoardFindManyArgs = {}>(args?: Subset<T, CommunityBoardFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityBoard>>, PrismaPromise<Array<CommunityBoardGetPayload<T>>>>;

    communityBoardCandidates<T extends CommunityBoardCandidateFindManyArgs = {}>(args?: Subset<T, CommunityBoardCandidateFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityBoardCandidate>>, PrismaPromise<Array<CommunityBoardCandidateGetPayload<T>>>>;

    communityBoardCandidateVotes<T extends CommunityBoardCandidateVoteFindManyArgs = {}>(args?: Subset<T, CommunityBoardCandidateVoteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityBoardCandidateVote>>, PrismaPromise<Array<CommunityBoardCandidateVoteGetPayload<T>>>>;

    communityBoardPins<T extends CommunityBoardPinFindManyArgs = {}>(args?: Subset<T, CommunityBoardPinFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityBoardPin>>, PrismaPromise<Array<CommunityBoardPinGetPayload<T>>>>;

    communityComments<T extends CommunityCommentFindManyArgs = {}>(args?: Subset<T, CommunityCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityComment>>, PrismaPromise<Array<CommunityCommentGetPayload<T>>>>;

    communityPosts<T extends CommunityPostFindManyArgs = {}>(args?: Subset<T, CommunityPostFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityPost>>, PrismaPromise<Array<CommunityPostGetPayload<T>>>>;

    communityPostBookmarks<T extends CommunityPostBookmarkFindManyArgs = {}>(args?: Subset<T, CommunityPostBookmarkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityPostBookmark>>, PrismaPromise<Array<CommunityPostBookmarkGetPayload<T>>>>;

    communityPostLikes<T extends CommunityPostLikeFindManyArgs = {}>(args?: Subset<T, CommunityPostLikeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunityPostLike>>, PrismaPromise<Array<CommunityPostLikeGetPayload<T>>>>;

    communitySubcomments<T extends CommunitySubcommentFindManyArgs = {}>(args?: Subset<T, CommunitySubcommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommunitySubcomment>>, PrismaPromise<Array<CommunitySubcommentGetPayload<T>>>>;

    liveChats<T extends LiveChatFindManyArgs = {}>(args?: Subset<T, LiveChatFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LiveChat>>, PrismaPromise<Array<LiveChatGetPayload<T>>>>;

    noticeNotificationsSubscriptions<T extends NoticeNotificationsSubscriptionFindManyArgs = {}>(args?: Subset<T, NoticeNotificationsSubscriptionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<NoticeNotificationsSubscription>>, PrismaPromise<Array<NoticeNotificationsSubscriptionGetPayload<T>>>>;

    reportComments<T extends ReportCommentFindManyArgs = {}>(args?: Subset<T, ReportCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReportComment>>, PrismaPromise<Array<ReportCommentGetPayload<T>>>>;

    reportPosts<T extends ReportPostFindManyArgs = {}>(args?: Subset<T, ReportPostFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReportPost>>, PrismaPromise<Array<ReportPostGetPayload<T>>>>;

    reportSubcomments<T extends ReportSubcommentFindManyArgs = {}>(args?: Subset<T, ReportSubcommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ReportSubcomment>>, PrismaPromise<Array<ReportSubcommentGetPayload<T>>>>;

    telegrams<T extends TelegramFindManyArgs = {}>(args?: Subset<T, TelegramFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Telegram>>, PrismaPromise<Array<TelegramGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
  }



  /**
   * Model ReportComment
   */


  export type AggregateReportComment = {
    count: ReportCommentCountAggregateOutputType | null
    avg: ReportCommentAvgAggregateOutputType | null
    sum: ReportCommentSumAggregateOutputType | null
    min: ReportCommentMinAggregateOutputType | null
    max: ReportCommentMaxAggregateOutputType | null
  }

  export type ReportCommentAvgAggregateOutputType = {
    id: number
    commentId: number
    userId: number
  }

  export type ReportCommentSumAggregateOutputType = {
    id: number
    commentId: number
    userId: number
  }

  export type ReportCommentMinAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportCommentMaxAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportCommentCountAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    title: number | null
    body: number | null
    reportedAt: number | null
    _all: number
  }


  export type ReportCommentAvgAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type ReportCommentSumAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type ReportCommentMinAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportCommentMaxAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportCommentCountAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
    _all?: true
  }

  export type ReportCommentAggregateArgs = {
    /**
     * Filter which ReportComment to aggregate.
    **/
    where?: ReportCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportComments to fetch.
    **/
    orderBy?: Enumerable<ReportCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ReportCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportComments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportComments
    **/
    count?: true | ReportCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ReportCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ReportCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ReportCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ReportCommentMaxAggregateInputType
  }

  export type GetReportCommentAggregateType<T extends ReportCommentAggregateArgs> = {
    [P in keyof T & keyof AggregateReportComment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportComment[P]>
      : GetScalarType<T[P], AggregateReportComment[P]>
  }


    
    
  export type ReportCommentGroupByArgs = {
    where?: ReportCommentWhereInput
    orderBy?: Enumerable<ReportCommentOrderByInput>
    by: Array<ReportCommentScalarFieldEnum>
    having?: ReportCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: ReportCommentCountAggregateInputType | true
    avg?: ReportCommentAvgAggregateInputType
    sum?: ReportCommentSumAggregateInputType
    min?: ReportCommentMinAggregateInputType
    max?: ReportCommentMaxAggregateInputType
  }


  export type ReportCommentGroupByOutputType = {
    id: number
    commentId: number
    userId: number
    title: string
    body: string | null
    reportedAt: Date
    count: ReportCommentCountAggregateOutputType | null
    avg: ReportCommentAvgAggregateOutputType | null
    sum: ReportCommentSumAggregateOutputType | null
    min: ReportCommentMinAggregateOutputType | null
    max: ReportCommentMaxAggregateOutputType | null
  }

  type GetReportCommentGroupByPayload<T extends ReportCommentGroupByArgs> = Promise<Array<
    PickArray<ReportCommentGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof ReportCommentGroupByOutputType))]: GetScalarType<T[P], ReportCommentGroupByOutputType[P]>
    }
  >>
    

  export type ReportCommentSelect = {
    id?: boolean
    commentId?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    reportedAt?: boolean
    communityComment?: boolean | CommunityCommentArgs
    user?: boolean | UserArgs
  }

  export type ReportCommentInclude = {
    communityComment?: boolean | CommunityCommentArgs
    user?: boolean | UserArgs
  }

  export type ReportCommentGetPayload<
    S extends boolean | null | undefined | ReportCommentArgs,
    U = keyof S
      > = S extends true
        ? ReportComment
    : S extends undefined
    ? never
    : S extends ReportCommentArgs | ReportCommentFindManyArgs
    ?'include' extends U
    ? ReportComment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityComment'
        ? CommunityCommentGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ReportComment ?ReportComment [P]
  : 
          P extends 'communityComment'
        ? CommunityCommentGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ReportComment
  : ReportComment


  type ReportCommentCountArgs = Merge<
    Omit<ReportCommentFindManyArgs, 'select' | 'include'> & {
      select?: ReportCommentCountAggregateInputType | true
    }
  >

  export interface ReportCommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReportComment that matches the filter.
     * @param {ReportCommentFindUniqueArgs} args - Arguments to find a ReportComment
     * @example
     * // Get one ReportComment
     * const reportComment = await prisma.reportComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReportCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReportComment'> extends True ? CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>> : CheckSelect<T, Prisma__ReportCommentClient<ReportComment | null >, Prisma__ReportCommentClient<ReportCommentGetPayload<T> | null >>

    /**
     * Find the first ReportComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCommentFindFirstArgs} args - Arguments to find a ReportComment
     * @example
     * // Get one ReportComment
     * const reportComment = await prisma.reportComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReportCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReportComment'> extends True ? CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>> : CheckSelect<T, Prisma__ReportCommentClient<ReportComment | null >, Prisma__ReportCommentClient<ReportCommentGetPayload<T> | null >>

    /**
     * Find zero or more ReportComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportComments
     * const reportComments = await prisma.reportComment.findMany()
     * 
     * // Get first 10 ReportComments
     * const reportComments = await prisma.reportComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportCommentWithIdOnly = await prisma.reportComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportCommentFindManyArgs>(
      args?: SelectSubset<T, ReportCommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ReportComment>>, PrismaPromise<Array<ReportCommentGetPayload<T>>>>

    /**
     * Create a ReportComment.
     * @param {ReportCommentCreateArgs} args - Arguments to create a ReportComment.
     * @example
     * // Create one ReportComment
     * const ReportComment = await prisma.reportComment.create({
     *   data: {
     *     // ... data to create a ReportComment
     *   }
     * })
     * 
    **/
    create<T extends ReportCommentCreateArgs>(
      args: SelectSubset<T, ReportCommentCreateArgs>
    ): CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>>

    /**
     * Create many ReportComments.
     *     @param {ReportCommentCreateManyArgs} args - Arguments to create many ReportComments.
     *     @example
     *     // Create many ReportComments
     *     const reportComment = await prisma.reportComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportCommentCreateManyArgs>(
      args?: SelectSubset<T, ReportCommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ReportComment.
     * @param {ReportCommentDeleteArgs} args - Arguments to delete one ReportComment.
     * @example
     * // Delete one ReportComment
     * const ReportComment = await prisma.reportComment.delete({
     *   where: {
     *     // ... filter to delete one ReportComment
     *   }
     * })
     * 
    **/
    delete<T extends ReportCommentDeleteArgs>(
      args: SelectSubset<T, ReportCommentDeleteArgs>
    ): CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>>

    /**
     * Update one ReportComment.
     * @param {ReportCommentUpdateArgs} args - Arguments to update one ReportComment.
     * @example
     * // Update one ReportComment
     * const reportComment = await prisma.reportComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportCommentUpdateArgs>(
      args: SelectSubset<T, ReportCommentUpdateArgs>
    ): CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>>

    /**
     * Delete zero or more ReportComments.
     * @param {ReportCommentDeleteManyArgs} args - Arguments to filter ReportComments to delete.
     * @example
     * // Delete a few ReportComments
     * const { count } = await prisma.reportComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportCommentDeleteManyArgs>(
      args?: SelectSubset<T, ReportCommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportComments
     * const reportComment = await prisma.reportComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportCommentUpdateManyArgs>(
      args: SelectSubset<T, ReportCommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportComment.
     * @param {ReportCommentUpsertArgs} args - Arguments to update or create a ReportComment.
     * @example
     * // Update or create a ReportComment
     * const reportComment = await prisma.reportComment.upsert({
     *   create: {
     *     // ... data to create a ReportComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportComment we want to update
     *   }
     * })
    **/
    upsert<T extends ReportCommentUpsertArgs>(
      args: SelectSubset<T, ReportCommentUpsertArgs>
    ): CheckSelect<T, Prisma__ReportCommentClient<ReportComment>, Prisma__ReportCommentClient<ReportCommentGetPayload<T>>>

    /**
     * Count the number of ReportComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCommentCountArgs} args - Arguments to filter ReportComments to count.
     * @example
     * // Count the number of ReportComments
     * const count = await prisma.reportComment.count({
     *   where: {
     *     // ... the filter for the ReportComments we want to count
     *   }
     * })
    **/
    count<T extends ReportCommentCountArgs>(
      args?: Subset<T, ReportCommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportCommentAggregateArgs>(args: Subset<T, ReportCommentAggregateArgs>): PrismaPromise<GetReportCommentAggregateType<T>>

    /**
     * Group by ReportComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportCommentGroupByArgs['orderBy'] }
        : { orderBy?: ReportCommentGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportCommentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportCommentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityComment<T extends CommunityCommentArgs = {}>(args?: Subset<T, CommunityCommentArgs>): CheckSelect<T, Prisma__CommunityCommentClient<CommunityComment | null >, Prisma__CommunityCommentClient<CommunityCommentGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReportComment findUnique
   */
  export type ReportCommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * Throw an Error if a ReportComment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportComment to fetch.
    **/
    where: ReportCommentWhereUniqueInput
  }


  /**
   * ReportComment findFirst
   */
  export type ReportCommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * Throw an Error if a ReportComment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportComment to fetch.
    **/
    where?: ReportCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportComments to fetch.
    **/
    orderBy?: Enumerable<ReportCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportComments.
    **/
    cursor?: ReportCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportComments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportComments.
    **/
    distinct?: Enumerable<ReportCommentScalarFieldEnum>
  }


  /**
   * ReportComment findMany
   */
  export type ReportCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * Filter, which ReportComments to fetch.
    **/
    where?: ReportCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportComments to fetch.
    **/
    orderBy?: Enumerable<ReportCommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportComments.
    **/
    cursor?: ReportCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportComments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportComments.
    **/
    skip?: number
    distinct?: Enumerable<ReportCommentScalarFieldEnum>
  }


  /**
   * ReportComment create
   */
  export type ReportCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * The data needed to create a ReportComment.
    **/
    data: XOR<ReportCommentCreateInput, ReportCommentUncheckedCreateInput>
  }


  /**
   * ReportComment createMany
   */
  export type ReportCommentCreateManyArgs = {
    data: Enumerable<ReportCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReportComment update
   */
  export type ReportCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * The data needed to update a ReportComment.
    **/
    data: XOR<ReportCommentUpdateInput, ReportCommentUncheckedUpdateInput>
    /**
     * Choose, which ReportComment to update.
    **/
    where: ReportCommentWhereUniqueInput
  }


  /**
   * ReportComment updateMany
   */
  export type ReportCommentUpdateManyArgs = {
    data: XOR<ReportCommentUpdateManyMutationInput, ReportCommentUncheckedUpdateManyInput>
    where?: ReportCommentWhereInput
  }


  /**
   * ReportComment upsert
   */
  export type ReportCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * The filter to search for the ReportComment to update in case it exists.
    **/
    where: ReportCommentWhereUniqueInput
    /**
     * In case the ReportComment found by the `where` argument doesn't exist, create a new ReportComment with this data.
    **/
    create: XOR<ReportCommentCreateInput, ReportCommentUncheckedCreateInput>
    /**
     * In case the ReportComment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ReportCommentUpdateInput, ReportCommentUncheckedUpdateInput>
  }


  /**
   * ReportComment delete
   */
  export type ReportCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
    /**
     * Filter which ReportComment to delete.
    **/
    where: ReportCommentWhereUniqueInput
  }


  /**
   * ReportComment deleteMany
   */
  export type ReportCommentDeleteManyArgs = {
    where?: ReportCommentWhereInput
  }


  /**
   * ReportComment without action
   */
  export type ReportCommentArgs = {
    /**
     * Select specific fields to fetch from the ReportComment
    **/
    select?: ReportCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportCommentInclude | null
  }



  /**
   * Model ReportPost
   */


  export type AggregateReportPost = {
    count: ReportPostCountAggregateOutputType | null
    avg: ReportPostAvgAggregateOutputType | null
    sum: ReportPostSumAggregateOutputType | null
    min: ReportPostMinAggregateOutputType | null
    max: ReportPostMaxAggregateOutputType | null
  }

  export type ReportPostAvgAggregateOutputType = {
    id: number
    postId: number
    userId: number
  }

  export type ReportPostSumAggregateOutputType = {
    id: number
    postId: number
    userId: number
  }

  export type ReportPostMinAggregateOutputType = {
    id: number
    postId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportPostMaxAggregateOutputType = {
    id: number
    postId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportPostCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    title: number | null
    body: number | null
    reportedAt: number | null
    _all: number
  }


  export type ReportPostAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type ReportPostSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type ReportPostMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportPostMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportPostCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
    _all?: true
  }

  export type ReportPostAggregateArgs = {
    /**
     * Filter which ReportPost to aggregate.
    **/
    where?: ReportPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportPosts to fetch.
    **/
    orderBy?: Enumerable<ReportPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ReportPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPosts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportPosts
    **/
    count?: true | ReportPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ReportPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ReportPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ReportPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ReportPostMaxAggregateInputType
  }

  export type GetReportPostAggregateType<T extends ReportPostAggregateArgs> = {
    [P in keyof T & keyof AggregateReportPost]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportPost[P]>
      : GetScalarType<T[P], AggregateReportPost[P]>
  }


    
    
  export type ReportPostGroupByArgs = {
    where?: ReportPostWhereInput
    orderBy?: Enumerable<ReportPostOrderByInput>
    by: Array<ReportPostScalarFieldEnum>
    having?: ReportPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: ReportPostCountAggregateInputType | true
    avg?: ReportPostAvgAggregateInputType
    sum?: ReportPostSumAggregateInputType
    min?: ReportPostMinAggregateInputType
    max?: ReportPostMaxAggregateInputType
  }


  export type ReportPostGroupByOutputType = {
    id: number
    postId: number
    userId: number
    title: string
    body: string | null
    reportedAt: Date
    count: ReportPostCountAggregateOutputType | null
    avg: ReportPostAvgAggregateOutputType | null
    sum: ReportPostSumAggregateOutputType | null
    min: ReportPostMinAggregateOutputType | null
    max: ReportPostMaxAggregateOutputType | null
  }

  type GetReportPostGroupByPayload<T extends ReportPostGroupByArgs> = Promise<Array<
    PickArray<ReportPostGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof ReportPostGroupByOutputType))]: GetScalarType<T[P], ReportPostGroupByOutputType[P]>
    }
  >>
    

  export type ReportPostSelect = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    reportedAt?: boolean
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type ReportPostInclude = {
    communityPost?: boolean | CommunityPostArgs
    user?: boolean | UserArgs
  }

  export type ReportPostGetPayload<
    S extends boolean | null | undefined | ReportPostArgs,
    U = keyof S
      > = S extends true
        ? ReportPost
    : S extends undefined
    ? never
    : S extends ReportPostArgs | ReportPostFindManyArgs
    ?'include' extends U
    ? ReportPost  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ReportPost ?ReportPost [P]
  : 
          P extends 'communityPost'
        ? CommunityPostGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ReportPost
  : ReportPost


  type ReportPostCountArgs = Merge<
    Omit<ReportPostFindManyArgs, 'select' | 'include'> & {
      select?: ReportPostCountAggregateInputType | true
    }
  >

  export interface ReportPostDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReportPost that matches the filter.
     * @param {ReportPostFindUniqueArgs} args - Arguments to find a ReportPost
     * @example
     * // Get one ReportPost
     * const reportPost = await prisma.reportPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReportPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReportPost'> extends True ? CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>> : CheckSelect<T, Prisma__ReportPostClient<ReportPost | null >, Prisma__ReportPostClient<ReportPostGetPayload<T> | null >>

    /**
     * Find the first ReportPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPostFindFirstArgs} args - Arguments to find a ReportPost
     * @example
     * // Get one ReportPost
     * const reportPost = await prisma.reportPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReportPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReportPost'> extends True ? CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>> : CheckSelect<T, Prisma__ReportPostClient<ReportPost | null >, Prisma__ReportPostClient<ReportPostGetPayload<T> | null >>

    /**
     * Find zero or more ReportPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportPosts
     * const reportPosts = await prisma.reportPost.findMany()
     * 
     * // Get first 10 ReportPosts
     * const reportPosts = await prisma.reportPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportPostWithIdOnly = await prisma.reportPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportPostFindManyArgs>(
      args?: SelectSubset<T, ReportPostFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ReportPost>>, PrismaPromise<Array<ReportPostGetPayload<T>>>>

    /**
     * Create a ReportPost.
     * @param {ReportPostCreateArgs} args - Arguments to create a ReportPost.
     * @example
     * // Create one ReportPost
     * const ReportPost = await prisma.reportPost.create({
     *   data: {
     *     // ... data to create a ReportPost
     *   }
     * })
     * 
    **/
    create<T extends ReportPostCreateArgs>(
      args: SelectSubset<T, ReportPostCreateArgs>
    ): CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>>

    /**
     * Create many ReportPosts.
     *     @param {ReportPostCreateManyArgs} args - Arguments to create many ReportPosts.
     *     @example
     *     // Create many ReportPosts
     *     const reportPost = await prisma.reportPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportPostCreateManyArgs>(
      args?: SelectSubset<T, ReportPostCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ReportPost.
     * @param {ReportPostDeleteArgs} args - Arguments to delete one ReportPost.
     * @example
     * // Delete one ReportPost
     * const ReportPost = await prisma.reportPost.delete({
     *   where: {
     *     // ... filter to delete one ReportPost
     *   }
     * })
     * 
    **/
    delete<T extends ReportPostDeleteArgs>(
      args: SelectSubset<T, ReportPostDeleteArgs>
    ): CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>>

    /**
     * Update one ReportPost.
     * @param {ReportPostUpdateArgs} args - Arguments to update one ReportPost.
     * @example
     * // Update one ReportPost
     * const reportPost = await prisma.reportPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportPostUpdateArgs>(
      args: SelectSubset<T, ReportPostUpdateArgs>
    ): CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>>

    /**
     * Delete zero or more ReportPosts.
     * @param {ReportPostDeleteManyArgs} args - Arguments to filter ReportPosts to delete.
     * @example
     * // Delete a few ReportPosts
     * const { count } = await prisma.reportPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportPostDeleteManyArgs>(
      args?: SelectSubset<T, ReportPostDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportPosts
     * const reportPost = await prisma.reportPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportPostUpdateManyArgs>(
      args: SelectSubset<T, ReportPostUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportPost.
     * @param {ReportPostUpsertArgs} args - Arguments to update or create a ReportPost.
     * @example
     * // Update or create a ReportPost
     * const reportPost = await prisma.reportPost.upsert({
     *   create: {
     *     // ... data to create a ReportPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportPost we want to update
     *   }
     * })
    **/
    upsert<T extends ReportPostUpsertArgs>(
      args: SelectSubset<T, ReportPostUpsertArgs>
    ): CheckSelect<T, Prisma__ReportPostClient<ReportPost>, Prisma__ReportPostClient<ReportPostGetPayload<T>>>

    /**
     * Count the number of ReportPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPostCountArgs} args - Arguments to filter ReportPosts to count.
     * @example
     * // Count the number of ReportPosts
     * const count = await prisma.reportPost.count({
     *   where: {
     *     // ... the filter for the ReportPosts we want to count
     *   }
     * })
    **/
    count<T extends ReportPostCountArgs>(
      args?: Subset<T, ReportPostCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportPostAggregateArgs>(args: Subset<T, ReportPostAggregateArgs>): PrismaPromise<GetReportPostAggregateType<T>>

    /**
     * Group by ReportPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportPostGroupByArgs['orderBy'] }
        : { orderBy?: ReportPostGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportPostGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportPostClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communityPost<T extends CommunityPostArgs = {}>(args?: Subset<T, CommunityPostArgs>): CheckSelect<T, Prisma__CommunityPostClient<CommunityPost | null >, Prisma__CommunityPostClient<CommunityPostGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReportPost findUnique
   */
  export type ReportPostFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * Throw an Error if a ReportPost can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportPost to fetch.
    **/
    where: ReportPostWhereUniqueInput
  }


  /**
   * ReportPost findFirst
   */
  export type ReportPostFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * Throw an Error if a ReportPost can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportPost to fetch.
    **/
    where?: ReportPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportPosts to fetch.
    **/
    orderBy?: Enumerable<ReportPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportPosts.
    **/
    cursor?: ReportPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPosts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportPosts.
    **/
    distinct?: Enumerable<ReportPostScalarFieldEnum>
  }


  /**
   * ReportPost findMany
   */
  export type ReportPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * Filter, which ReportPosts to fetch.
    **/
    where?: ReportPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportPosts to fetch.
    **/
    orderBy?: Enumerable<ReportPostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportPosts.
    **/
    cursor?: ReportPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPosts.
    **/
    skip?: number
    distinct?: Enumerable<ReportPostScalarFieldEnum>
  }


  /**
   * ReportPost create
   */
  export type ReportPostCreateArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * The data needed to create a ReportPost.
    **/
    data: XOR<ReportPostCreateInput, ReportPostUncheckedCreateInput>
  }


  /**
   * ReportPost createMany
   */
  export type ReportPostCreateManyArgs = {
    data: Enumerable<ReportPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReportPost update
   */
  export type ReportPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * The data needed to update a ReportPost.
    **/
    data: XOR<ReportPostUpdateInput, ReportPostUncheckedUpdateInput>
    /**
     * Choose, which ReportPost to update.
    **/
    where: ReportPostWhereUniqueInput
  }


  /**
   * ReportPost updateMany
   */
  export type ReportPostUpdateManyArgs = {
    data: XOR<ReportPostUpdateManyMutationInput, ReportPostUncheckedUpdateManyInput>
    where?: ReportPostWhereInput
  }


  /**
   * ReportPost upsert
   */
  export type ReportPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * The filter to search for the ReportPost to update in case it exists.
    **/
    where: ReportPostWhereUniqueInput
    /**
     * In case the ReportPost found by the `where` argument doesn't exist, create a new ReportPost with this data.
    **/
    create: XOR<ReportPostCreateInput, ReportPostUncheckedCreateInput>
    /**
     * In case the ReportPost was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ReportPostUpdateInput, ReportPostUncheckedUpdateInput>
  }


  /**
   * ReportPost delete
   */
  export type ReportPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
    /**
     * Filter which ReportPost to delete.
    **/
    where: ReportPostWhereUniqueInput
  }


  /**
   * ReportPost deleteMany
   */
  export type ReportPostDeleteManyArgs = {
    where?: ReportPostWhereInput
  }


  /**
   * ReportPost without action
   */
  export type ReportPostArgs = {
    /**
     * Select specific fields to fetch from the ReportPost
    **/
    select?: ReportPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportPostInclude | null
  }



  /**
   * Model ReportSubcomment
   */


  export type AggregateReportSubcomment = {
    count: ReportSubcommentCountAggregateOutputType | null
    avg: ReportSubcommentAvgAggregateOutputType | null
    sum: ReportSubcommentSumAggregateOutputType | null
    min: ReportSubcommentMinAggregateOutputType | null
    max: ReportSubcommentMaxAggregateOutputType | null
  }

  export type ReportSubcommentAvgAggregateOutputType = {
    id: number
    subcommentId: number
    userId: number
  }

  export type ReportSubcommentSumAggregateOutputType = {
    id: number
    subcommentId: number
    userId: number
  }

  export type ReportSubcommentMinAggregateOutputType = {
    id: number
    subcommentId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportSubcommentMaxAggregateOutputType = {
    id: number
    subcommentId: number
    userId: number
    title: string | null
    body: string | null
    reportedAt: Date | null
  }

  export type ReportSubcommentCountAggregateOutputType = {
    id: number
    subcommentId: number
    userId: number
    title: number | null
    body: number | null
    reportedAt: number | null
    _all: number
  }


  export type ReportSubcommentAvgAggregateInputType = {
    id?: true
    subcommentId?: true
    userId?: true
  }

  export type ReportSubcommentSumAggregateInputType = {
    id?: true
    subcommentId?: true
    userId?: true
  }

  export type ReportSubcommentMinAggregateInputType = {
    id?: true
    subcommentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportSubcommentMaxAggregateInputType = {
    id?: true
    subcommentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
  }

  export type ReportSubcommentCountAggregateInputType = {
    id?: true
    subcommentId?: true
    userId?: true
    title?: true
    body?: true
    reportedAt?: true
    _all?: true
  }

  export type ReportSubcommentAggregateArgs = {
    /**
     * Filter which ReportSubcomment to aggregate.
    **/
    where?: ReportSubcommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportSubcomments to fetch.
    **/
    orderBy?: Enumerable<ReportSubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ReportSubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSubcomments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportSubcomments
    **/
    count?: true | ReportSubcommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ReportSubcommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ReportSubcommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ReportSubcommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ReportSubcommentMaxAggregateInputType
  }

  export type GetReportSubcommentAggregateType<T extends ReportSubcommentAggregateArgs> = {
    [P in keyof T & keyof AggregateReportSubcomment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportSubcomment[P]>
      : GetScalarType<T[P], AggregateReportSubcomment[P]>
  }


    
    
  export type ReportSubcommentGroupByArgs = {
    where?: ReportSubcommentWhereInput
    orderBy?: Enumerable<ReportSubcommentOrderByInput>
    by: Array<ReportSubcommentScalarFieldEnum>
    having?: ReportSubcommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: ReportSubcommentCountAggregateInputType | true
    avg?: ReportSubcommentAvgAggregateInputType
    sum?: ReportSubcommentSumAggregateInputType
    min?: ReportSubcommentMinAggregateInputType
    max?: ReportSubcommentMaxAggregateInputType
  }


  export type ReportSubcommentGroupByOutputType = {
    id: number
    subcommentId: number
    userId: number
    title: string
    body: string | null
    reportedAt: Date
    count: ReportSubcommentCountAggregateOutputType | null
    avg: ReportSubcommentAvgAggregateOutputType | null
    sum: ReportSubcommentSumAggregateOutputType | null
    min: ReportSubcommentMinAggregateOutputType | null
    max: ReportSubcommentMaxAggregateOutputType | null
  }

  type GetReportSubcommentGroupByPayload<T extends ReportSubcommentGroupByArgs> = Promise<Array<
    PickArray<ReportSubcommentGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof ReportSubcommentGroupByOutputType))]: GetScalarType<T[P], ReportSubcommentGroupByOutputType[P]>
    }
  >>
    

  export type ReportSubcommentSelect = {
    id?: boolean
    subcommentId?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    reportedAt?: boolean
    communitySubcomment?: boolean | CommunitySubcommentArgs
    user?: boolean | UserArgs
  }

  export type ReportSubcommentInclude = {
    communitySubcomment?: boolean | CommunitySubcommentArgs
    user?: boolean | UserArgs
  }

  export type ReportSubcommentGetPayload<
    S extends boolean | null | undefined | ReportSubcommentArgs,
    U = keyof S
      > = S extends true
        ? ReportSubcomment
    : S extends undefined
    ? never
    : S extends ReportSubcommentArgs | ReportSubcommentFindManyArgs
    ?'include' extends U
    ? ReportSubcomment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'communitySubcomment'
        ? CommunitySubcommentGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ReportSubcomment ?ReportSubcomment [P]
  : 
          P extends 'communitySubcomment'
        ? CommunitySubcommentGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ReportSubcomment
  : ReportSubcomment


  type ReportSubcommentCountArgs = Merge<
    Omit<ReportSubcommentFindManyArgs, 'select' | 'include'> & {
      select?: ReportSubcommentCountAggregateInputType | true
    }
  >

  export interface ReportSubcommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReportSubcomment that matches the filter.
     * @param {ReportSubcommentFindUniqueArgs} args - Arguments to find a ReportSubcomment
     * @example
     * // Get one ReportSubcomment
     * const reportSubcomment = await prisma.reportSubcomment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportSubcommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReportSubcommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReportSubcomment'> extends True ? CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>> : CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment | null >, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T> | null >>

    /**
     * Find the first ReportSubcomment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSubcommentFindFirstArgs} args - Arguments to find a ReportSubcomment
     * @example
     * // Get one ReportSubcomment
     * const reportSubcomment = await prisma.reportSubcomment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportSubcommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReportSubcommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReportSubcomment'> extends True ? CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>> : CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment | null >, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T> | null >>

    /**
     * Find zero or more ReportSubcomments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSubcommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportSubcomments
     * const reportSubcomments = await prisma.reportSubcomment.findMany()
     * 
     * // Get first 10 ReportSubcomments
     * const reportSubcomments = await prisma.reportSubcomment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportSubcommentWithIdOnly = await prisma.reportSubcomment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportSubcommentFindManyArgs>(
      args?: SelectSubset<T, ReportSubcommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ReportSubcomment>>, PrismaPromise<Array<ReportSubcommentGetPayload<T>>>>

    /**
     * Create a ReportSubcomment.
     * @param {ReportSubcommentCreateArgs} args - Arguments to create a ReportSubcomment.
     * @example
     * // Create one ReportSubcomment
     * const ReportSubcomment = await prisma.reportSubcomment.create({
     *   data: {
     *     // ... data to create a ReportSubcomment
     *   }
     * })
     * 
    **/
    create<T extends ReportSubcommentCreateArgs>(
      args: SelectSubset<T, ReportSubcommentCreateArgs>
    ): CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>>

    /**
     * Create many ReportSubcomments.
     *     @param {ReportSubcommentCreateManyArgs} args - Arguments to create many ReportSubcomments.
     *     @example
     *     // Create many ReportSubcomments
     *     const reportSubcomment = await prisma.reportSubcomment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportSubcommentCreateManyArgs>(
      args?: SelectSubset<T, ReportSubcommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ReportSubcomment.
     * @param {ReportSubcommentDeleteArgs} args - Arguments to delete one ReportSubcomment.
     * @example
     * // Delete one ReportSubcomment
     * const ReportSubcomment = await prisma.reportSubcomment.delete({
     *   where: {
     *     // ... filter to delete one ReportSubcomment
     *   }
     * })
     * 
    **/
    delete<T extends ReportSubcommentDeleteArgs>(
      args: SelectSubset<T, ReportSubcommentDeleteArgs>
    ): CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>>

    /**
     * Update one ReportSubcomment.
     * @param {ReportSubcommentUpdateArgs} args - Arguments to update one ReportSubcomment.
     * @example
     * // Update one ReportSubcomment
     * const reportSubcomment = await prisma.reportSubcomment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportSubcommentUpdateArgs>(
      args: SelectSubset<T, ReportSubcommentUpdateArgs>
    ): CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>>

    /**
     * Delete zero or more ReportSubcomments.
     * @param {ReportSubcommentDeleteManyArgs} args - Arguments to filter ReportSubcomments to delete.
     * @example
     * // Delete a few ReportSubcomments
     * const { count } = await prisma.reportSubcomment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportSubcommentDeleteManyArgs>(
      args?: SelectSubset<T, ReportSubcommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportSubcomments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSubcommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportSubcomments
     * const reportSubcomment = await prisma.reportSubcomment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportSubcommentUpdateManyArgs>(
      args: SelectSubset<T, ReportSubcommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportSubcomment.
     * @param {ReportSubcommentUpsertArgs} args - Arguments to update or create a ReportSubcomment.
     * @example
     * // Update or create a ReportSubcomment
     * const reportSubcomment = await prisma.reportSubcomment.upsert({
     *   create: {
     *     // ... data to create a ReportSubcomment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportSubcomment we want to update
     *   }
     * })
    **/
    upsert<T extends ReportSubcommentUpsertArgs>(
      args: SelectSubset<T, ReportSubcommentUpsertArgs>
    ): CheckSelect<T, Prisma__ReportSubcommentClient<ReportSubcomment>, Prisma__ReportSubcommentClient<ReportSubcommentGetPayload<T>>>

    /**
     * Count the number of ReportSubcomments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSubcommentCountArgs} args - Arguments to filter ReportSubcomments to count.
     * @example
     * // Count the number of ReportSubcomments
     * const count = await prisma.reportSubcomment.count({
     *   where: {
     *     // ... the filter for the ReportSubcomments we want to count
     *   }
     * })
    **/
    count<T extends ReportSubcommentCountArgs>(
      args?: Subset<T, ReportSubcommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportSubcommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportSubcomment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSubcommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportSubcommentAggregateArgs>(args: Subset<T, ReportSubcommentAggregateArgs>): PrismaPromise<GetReportSubcommentAggregateType<T>>

    /**
     * Group by ReportSubcomment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportSubcommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportSubcommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportSubcommentGroupByArgs['orderBy'] }
        : { orderBy?: ReportSubcommentGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportSubcommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportSubcommentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportSubcomment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportSubcommentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    communitySubcomment<T extends CommunitySubcommentArgs = {}>(args?: Subset<T, CommunitySubcommentArgs>): CheckSelect<T, Prisma__CommunitySubcommentClient<CommunitySubcomment | null >, Prisma__CommunitySubcommentClient<CommunitySubcommentGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReportSubcomment findUnique
   */
  export type ReportSubcommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * Throw an Error if a ReportSubcomment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportSubcomment to fetch.
    **/
    where: ReportSubcommentWhereUniqueInput
  }


  /**
   * ReportSubcomment findFirst
   */
  export type ReportSubcommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * Throw an Error if a ReportSubcomment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReportSubcomment to fetch.
    **/
    where?: ReportSubcommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportSubcomments to fetch.
    **/
    orderBy?: Enumerable<ReportSubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportSubcomments.
    **/
    cursor?: ReportSubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSubcomments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportSubcomments.
    **/
    distinct?: Enumerable<ReportSubcommentScalarFieldEnum>
  }


  /**
   * ReportSubcomment findMany
   */
  export type ReportSubcommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * Filter, which ReportSubcomments to fetch.
    **/
    where?: ReportSubcommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportSubcomments to fetch.
    **/
    orderBy?: Enumerable<ReportSubcommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportSubcomments.
    **/
    cursor?: ReportSubcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportSubcomments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportSubcomments.
    **/
    skip?: number
    distinct?: Enumerable<ReportSubcommentScalarFieldEnum>
  }


  /**
   * ReportSubcomment create
   */
  export type ReportSubcommentCreateArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * The data needed to create a ReportSubcomment.
    **/
    data: XOR<ReportSubcommentCreateInput, ReportSubcommentUncheckedCreateInput>
  }


  /**
   * ReportSubcomment createMany
   */
  export type ReportSubcommentCreateManyArgs = {
    data: Enumerable<ReportSubcommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReportSubcomment update
   */
  export type ReportSubcommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * The data needed to update a ReportSubcomment.
    **/
    data: XOR<ReportSubcommentUpdateInput, ReportSubcommentUncheckedUpdateInput>
    /**
     * Choose, which ReportSubcomment to update.
    **/
    where: ReportSubcommentWhereUniqueInput
  }


  /**
   * ReportSubcomment updateMany
   */
  export type ReportSubcommentUpdateManyArgs = {
    data: XOR<ReportSubcommentUpdateManyMutationInput, ReportSubcommentUncheckedUpdateManyInput>
    where?: ReportSubcommentWhereInput
  }


  /**
   * ReportSubcomment upsert
   */
  export type ReportSubcommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * The filter to search for the ReportSubcomment to update in case it exists.
    **/
    where: ReportSubcommentWhereUniqueInput
    /**
     * In case the ReportSubcomment found by the `where` argument doesn't exist, create a new ReportSubcomment with this data.
    **/
    create: XOR<ReportSubcommentCreateInput, ReportSubcommentUncheckedCreateInput>
    /**
     * In case the ReportSubcomment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ReportSubcommentUpdateInput, ReportSubcommentUncheckedUpdateInput>
  }


  /**
   * ReportSubcomment delete
   */
  export type ReportSubcommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
    /**
     * Filter which ReportSubcomment to delete.
    **/
    where: ReportSubcommentWhereUniqueInput
  }


  /**
   * ReportSubcomment deleteMany
   */
  export type ReportSubcommentDeleteManyArgs = {
    where?: ReportSubcommentWhereInput
  }


  /**
   * ReportSubcomment without action
   */
  export type ReportSubcommentArgs = {
    /**
     * Select specific fields to fetch from the ReportSubcomment
    **/
    select?: ReportSubcommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportSubcommentInclude | null
  }



  /**
   * Model Telegram
   */


  export type AggregateTelegram = {
    count: TelegramCountAggregateOutputType | null
    avg: TelegramAvgAggregateOutputType | null
    sum: TelegramSumAggregateOutputType | null
    min: TelegramMinAggregateOutputType | null
    max: TelegramMaxAggregateOutputType | null
  }

  export type TelegramAvgAggregateOutputType = {
    userId: number
    chatId: number
  }

  export type TelegramSumAggregateOutputType = {
    userId: number
    chatId: number
  }

  export type TelegramMinAggregateOutputType = {
    userId: number
    chatId: number
  }

  export type TelegramMaxAggregateOutputType = {
    userId: number
    chatId: number
  }

  export type TelegramCountAggregateOutputType = {
    userId: number
    chatId: number
    _all: number
  }


  export type TelegramAvgAggregateInputType = {
    userId?: true
    chatId?: true
  }

  export type TelegramSumAggregateInputType = {
    userId?: true
    chatId?: true
  }

  export type TelegramMinAggregateInputType = {
    userId?: true
    chatId?: true
  }

  export type TelegramMaxAggregateInputType = {
    userId?: true
    chatId?: true
  }

  export type TelegramCountAggregateInputType = {
    userId?: true
    chatId?: true
    _all?: true
  }

  export type TelegramAggregateArgs = {
    /**
     * Filter which Telegram to aggregate.
    **/
    where?: TelegramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Telegrams to fetch.
    **/
    orderBy?: Enumerable<TelegramOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TelegramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Telegrams from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Telegrams.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Telegrams
    **/
    count?: true | TelegramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TelegramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TelegramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TelegramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TelegramMaxAggregateInputType
  }

  export type GetTelegramAggregateType<T extends TelegramAggregateArgs> = {
    [P in keyof T & keyof AggregateTelegram]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelegram[P]>
      : GetScalarType<T[P], AggregateTelegram[P]>
  }


    
    
  export type TelegramGroupByArgs = {
    where?: TelegramWhereInput
    orderBy?: Enumerable<TelegramOrderByInput>
    by: Array<TelegramScalarFieldEnum>
    having?: TelegramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: TelegramCountAggregateInputType | true
    avg?: TelegramAvgAggregateInputType
    sum?: TelegramSumAggregateInputType
    min?: TelegramMinAggregateInputType
    max?: TelegramMaxAggregateInputType
  }


  export type TelegramGroupByOutputType = {
    userId: number
    chatId: number
    count: TelegramCountAggregateOutputType | null
    avg: TelegramAvgAggregateOutputType | null
    sum: TelegramSumAggregateOutputType | null
    min: TelegramMinAggregateOutputType | null
    max: TelegramMaxAggregateOutputType | null
  }

  type GetTelegramGroupByPayload<T extends TelegramGroupByArgs> = Promise<Array<
    PickArray<TelegramGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof TelegramGroupByOutputType))]: GetScalarType<T[P], TelegramGroupByOutputType[P]>
    }
  >>
    

  export type TelegramSelect = {
    userId?: boolean
    chatId?: boolean
    user?: boolean | UserArgs
  }

  export type TelegramInclude = {
    user?: boolean | UserArgs
  }

  export type TelegramGetPayload<
    S extends boolean | null | undefined | TelegramArgs,
    U = keyof S
      > = S extends true
        ? Telegram
    : S extends undefined
    ? never
    : S extends TelegramArgs | TelegramFindManyArgs
    ?'include' extends U
    ? Telegram  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Telegram ?Telegram [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Telegram
  : Telegram


  type TelegramCountArgs = Merge<
    Omit<TelegramFindManyArgs, 'select' | 'include'> & {
      select?: TelegramCountAggregateInputType | true
    }
  >

  export interface TelegramDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Telegram that matches the filter.
     * @param {TelegramFindUniqueArgs} args - Arguments to find a Telegram
     * @example
     * // Get one Telegram
     * const telegram = await prisma.telegram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TelegramFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TelegramFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Telegram'> extends True ? CheckSelect<T, Prisma__TelegramClient<Telegram>, Prisma__TelegramClient<TelegramGetPayload<T>>> : CheckSelect<T, Prisma__TelegramClient<Telegram | null >, Prisma__TelegramClient<TelegramGetPayload<T> | null >>

    /**
     * Find the first Telegram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramFindFirstArgs} args - Arguments to find a Telegram
     * @example
     * // Get one Telegram
     * const telegram = await prisma.telegram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TelegramFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TelegramFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Telegram'> extends True ? CheckSelect<T, Prisma__TelegramClient<Telegram>, Prisma__TelegramClient<TelegramGetPayload<T>>> : CheckSelect<T, Prisma__TelegramClient<Telegram | null >, Prisma__TelegramClient<TelegramGetPayload<T> | null >>

    /**
     * Find zero or more Telegrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Telegrams
     * const telegrams = await prisma.telegram.findMany()
     * 
     * // Get first 10 Telegrams
     * const telegrams = await prisma.telegram.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const telegramWithUserIdOnly = await prisma.telegram.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends TelegramFindManyArgs>(
      args?: SelectSubset<T, TelegramFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Telegram>>, PrismaPromise<Array<TelegramGetPayload<T>>>>

    /**
     * Create a Telegram.
     * @param {TelegramCreateArgs} args - Arguments to create a Telegram.
     * @example
     * // Create one Telegram
     * const Telegram = await prisma.telegram.create({
     *   data: {
     *     // ... data to create a Telegram
     *   }
     * })
     * 
    **/
    create<T extends TelegramCreateArgs>(
      args: SelectSubset<T, TelegramCreateArgs>
    ): CheckSelect<T, Prisma__TelegramClient<Telegram>, Prisma__TelegramClient<TelegramGetPayload<T>>>

    /**
     * Create many Telegrams.
     *     @param {TelegramCreateManyArgs} args - Arguments to create many Telegrams.
     *     @example
     *     // Create many Telegrams
     *     const telegram = await prisma.telegram.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TelegramCreateManyArgs>(
      args?: SelectSubset<T, TelegramCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Telegram.
     * @param {TelegramDeleteArgs} args - Arguments to delete one Telegram.
     * @example
     * // Delete one Telegram
     * const Telegram = await prisma.telegram.delete({
     *   where: {
     *     // ... filter to delete one Telegram
     *   }
     * })
     * 
    **/
    delete<T extends TelegramDeleteArgs>(
      args: SelectSubset<T, TelegramDeleteArgs>
    ): CheckSelect<T, Prisma__TelegramClient<Telegram>, Prisma__TelegramClient<TelegramGetPayload<T>>>

    /**
     * Update one Telegram.
     * @param {TelegramUpdateArgs} args - Arguments to update one Telegram.
     * @example
     * // Update one Telegram
     * const telegram = await prisma.telegram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TelegramUpdateArgs>(
      args: SelectSubset<T, TelegramUpdateArgs>
    ): CheckSelect<T, Prisma__TelegramClient<Telegram>, Prisma__TelegramClient<TelegramGetPayload<T>>>

    /**
     * Delete zero or more Telegrams.
     * @param {TelegramDeleteManyArgs} args - Arguments to filter Telegrams to delete.
     * @example
     * // Delete a few Telegrams
     * const { count } = await prisma.telegram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TelegramDeleteManyArgs>(
      args?: SelectSubset<T, TelegramDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Telegrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Telegrams
     * const telegram = await prisma.telegram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TelegramUpdateManyArgs>(
      args: SelectSubset<T, TelegramUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Telegram.
     * @param {TelegramUpsertArgs} args - Arguments to update or create a Telegram.
     * @example
     * // Update or create a Telegram
     * const telegram = await prisma.telegram.upsert({
     *   create: {
     *     // ... data to create a Telegram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Telegram we want to update
     *   }
     * })
    **/
    upsert<T extends TelegramUpsertArgs>(
      args: SelectSubset<T, TelegramUpsertArgs>
    ): CheckSelect<T, Prisma__TelegramClient<Telegram>, Prisma__TelegramClient<TelegramGetPayload<T>>>

    /**
     * Count the number of Telegrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramCountArgs} args - Arguments to filter Telegrams to count.
     * @example
     * // Count the number of Telegrams
     * const count = await prisma.telegram.count({
     *   where: {
     *     // ... the filter for the Telegrams we want to count
     *   }
     * })
    **/
    count<T extends TelegramCountArgs>(
      args?: Subset<T, TelegramCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelegramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Telegram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelegramAggregateArgs>(args: Subset<T, TelegramAggregateArgs>): PrismaPromise<GetTelegramAggregateType<T>>

    /**
     * Group by Telegram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelegramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelegramGroupByArgs['orderBy'] }
        : { orderBy?: TelegramGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelegramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelegramGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Telegram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TelegramClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Telegram findUnique
   */
  export type TelegramFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Telegram
    **/
    select?: TelegramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TelegramInclude | null
    /**
     * Throw an Error if a Telegram can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Telegram to fetch.
    **/
    where: TelegramWhereUniqueInput
  }


  /**
   * Telegram findFirst
   */
  export type TelegramFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Telegram
    **/
    select?: TelegramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TelegramInclude | null
    /**
     * Throw an Error if a Telegram can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Telegram to fetch.
    **/
    where?: TelegramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Telegrams to fetch.
    **/
    orderBy?: Enumerable<TelegramOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Telegrams.
    **/
    cursor?: TelegramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Telegrams from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Telegrams.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Telegrams.
    **/
    distinct?: Enumerable<TelegramScalarFieldEnum>
  }


  /**
   * Telegram findMany
   */
  export type TelegramFindManyArgs = {
    /**
     * Select specific fields to fetch from the Telegram
    **/
    select?: TelegramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TelegramInclude | null
    /**
     * Filter, which Telegrams to fetch.
    **/
    where?: TelegramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Telegrams to fetch.
    **/
    orderBy?: Enumerable<TelegramOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Telegrams.
    **/
    cursor?: TelegramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Telegrams from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Telegrams.
    **/
    skip?: number
    distinct?: Enumerable<TelegramScalarFieldEnum>
  }


  /**
   * Telegram create
   */
  export type TelegramCreateArgs = {
    /**
     * Select specific fields to fetch from the Telegram
    **/
    select?: TelegramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TelegramInclude | null
    /**
     * The data needed to create a Telegram.
    **/
    data: XOR<TelegramCreateInput, TelegramUncheckedCreateInput>
  }


  /**
   * Telegram createMany
   */
  export type TelegramCreateManyArgs = {
    data: Enumerable<TelegramCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Telegram update
   */
  export type TelegramUpdateArgs = {
    /**
     * Select specific fields to fetch from the Telegram
    **/
    select?: TelegramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TelegramInclude | null
    /**
     * The data needed to update a Telegram.
    **/
    data: XOR<TelegramUpdateInput, TelegramUncheckedUpdateInput>
    /**
     * Choose, which Telegram to update.
    **/
    where: TelegramWhereUniqueInput
  }


  /**
   * Telegram updateMany
   */
  export type TelegramUpdateManyArgs = {
    data: XOR<TelegramUpdateManyMutationInput, TelegramUncheckedUpdateManyInput>
    where?: TelegramWhereInput
  }


  /**
   * Telegram upsert
   */
  export type TelegramUpsertArgs = {
    /**
     * Select specific fields to fetch from the Telegram
    **/
    select?: TelegramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TelegramInclude | null
    /**
     * The filter to search for the Telegram to update in case it exists.
    **/
    where: TelegramWhereUniqueInput
    /**
     * In case the Telegram found by the `where` argument doesn't exist, create a new Telegram with this data.
    **/
    create: XOR<TelegramCreateInput, TelegramUncheckedCreateInput>
    /**
     * In case the Telegram was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TelegramUpdateInput, TelegramUncheckedUpdateInput>
  }


  /**
   * Telegram delete
   */
  export type TelegramDeleteArgs = {
    /**
     * Select specific fields to fetch from the Telegram
    **/
    select?: TelegramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TelegramInclude | null
    /**
     * Filter which Telegram to delete.
    **/
    where: TelegramWhereUniqueInput
  }


  /**
   * Telegram deleteMany
   */
  export type TelegramDeleteManyArgs = {
    where?: TelegramWhereInput
  }


  /**
   * Telegram without action
   */
  export type TelegramArgs = {
    /**
     * Select specific fields to fetch from the Telegram
    **/
    select?: TelegramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TelegramInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AdminScalarFieldEnum: {
    userId: 'userId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const CafeteriaMenuScalarFieldEnum: {
    campus: 'campus',
    servedAt: 'servedAt',
    data: 'data'
  };

  export type CafeteriaMenuScalarFieldEnum = (typeof CafeteriaMenuScalarFieldEnum)[keyof typeof CafeteriaMenuScalarFieldEnum]


  export const ChangePasswordScalarFieldEnum: {
    userId: 'userId',
    token: 'token',
    requestedAt: 'requestedAt'
  };

  export type ChangePasswordScalarFieldEnum = (typeof ChangePasswordScalarFieldEnum)[keyof typeof ChangePasswordScalarFieldEnum]


  export const CommunityBoardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    priority: 'priority',
    isDeleted: 'isDeleted',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    activeAt: 'activeAt'
  };

  export type CommunityBoardScalarFieldEnum = (typeof CommunityBoardScalarFieldEnum)[keyof typeof CommunityBoardScalarFieldEnum]


  export const CommunityBoardCandidateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type CommunityBoardCandidateScalarFieldEnum = (typeof CommunityBoardCandidateScalarFieldEnum)[keyof typeof CommunityBoardCandidateScalarFieldEnum]


  export const CommunityBoardCandidateVoteScalarFieldEnum: {
    boardCandidateId: 'boardCandidateId',
    userId: 'userId'
  };

  export type CommunityBoardCandidateVoteScalarFieldEnum = (typeof CommunityBoardCandidateVoteScalarFieldEnum)[keyof typeof CommunityBoardCandidateVoteScalarFieldEnum]


  export const CommunityBoardPinScalarFieldEnum: {
    userId: 'userId',
    boardId: 'boardId'
  };

  export type CommunityBoardPinScalarFieldEnum = (typeof CommunityBoardPinScalarFieldEnum)[keyof typeof CommunityBoardPinScalarFieldEnum]


  export const CommunityCommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    randomNickname: 'randomNickname',
    body: 'body',
    commentedAt: 'commentedAt',
    isDeleted: 'isDeleted'
  };

  export type CommunityCommentScalarFieldEnum = (typeof CommunityCommentScalarFieldEnum)[keyof typeof CommunityCommentScalarFieldEnum]


  export const CommunityPostScalarFieldEnum: {
    id: 'id',
    boardId: 'boardId',
    userId: 'userId',
    title: 'title',
    body: 'body',
    randomNickname: 'randomNickname',
    likesCount: 'likesCount',
    commentsCount: 'commentsCount',
    bookmarksCount: 'bookmarksCount',
    postedAt: 'postedAt',
    editedAt: 'editedAt',
    isDeleted: 'isDeleted'
  };

  export type CommunityPostScalarFieldEnum = (typeof CommunityPostScalarFieldEnum)[keyof typeof CommunityPostScalarFieldEnum]


  export const CommunityPostBookmarkScalarFieldEnum: {
    userId: 'userId',
    postId: 'postId'
  };

  export type CommunityPostBookmarkScalarFieldEnum = (typeof CommunityPostBookmarkScalarFieldEnum)[keyof typeof CommunityPostBookmarkScalarFieldEnum]


  export const CommunityPostLikeScalarFieldEnum: {
    userId: 'userId',
    postId: 'postId'
  };

  export type CommunityPostLikeScalarFieldEnum = (typeof CommunityPostLikeScalarFieldEnum)[keyof typeof CommunityPostLikeScalarFieldEnum]


  export const CommunitySubcommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    postId: 'postId',
    commentId: 'commentId',
    randomNickname: 'randomNickname',
    body: 'body',
    subcommentedAt: 'subcommentedAt',
    isDeleted: 'isDeleted'
  };

  export type CommunitySubcommentScalarFieldEnum = (typeof CommunitySubcommentScalarFieldEnum)[keyof typeof CommunitySubcommentScalarFieldEnum]


  export const CoverageMajorScalarFieldEnum: {
    coverageCollege: 'coverageCollege',
    name: 'name',
    code: 'code'
  };

  export type CoverageMajorScalarFieldEnum = (typeof CoverageMajorScalarFieldEnum)[keyof typeof CoverageMajorScalarFieldEnum]


  export const CoverageMajorLectureScalarFieldEnum: {
    lectureId: 'lectureId',
    majorCode: 'majorCode'
  };

  export type CoverageMajorLectureScalarFieldEnum = (typeof CoverageMajorLectureScalarFieldEnum)[keyof typeof CoverageMajorLectureScalarFieldEnum]


  export const LectureScalarFieldEnum: {
    id: 'id',
    year: 'year',
    semester: 'semester',
    campus: 'campus',
    college: 'college',
    major: 'major',
    grade: 'grade',
    credit: 'credit',
    course: 'course',
    section: 'section',
    code: 'code',
    name: 'name',
    professor: 'professor',
    schedule: 'schedule',
    building: 'building',
    room: 'room',
    note: 'note'
  };

  export type LectureScalarFieldEnum = (typeof LectureScalarFieldEnum)[keyof typeof LectureScalarFieldEnum]


  export const LiveChatScalarFieldEnum: {
    id: 'id',
    message: 'message',
    createdAt: 'createdAt',
    userId: 'userId',
    randomNickname: 'randomNickname'
  };

  export type LiveChatScalarFieldEnum = (typeof LiveChatScalarFieldEnum)[keyof typeof LiveChatScalarFieldEnum]


  export const NoticeNotificationsSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    noticeKey: 'noticeKey',
    subscribedAt: 'subscribedAt'
  };

  export type NoticeNotificationsSubscriptionScalarFieldEnum = (typeof NoticeNotificationsSubscriptionScalarFieldEnum)[keyof typeof NoticeNotificationsSubscriptionScalarFieldEnum]


  export const PendingUserScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    password: 'password',
    nickname: 'nickname',
    randomNickname: 'randomNickname',
    joinedAt: 'joinedAt',
    token: 'token'
  };

  export type PendingUserScalarFieldEnum = (typeof PendingUserScalarFieldEnum)[keyof typeof PendingUserScalarFieldEnum]


  export const PeriodScalarFieldEnum: {
    lectureId: 'lectureId',
    day: 'day',
    startH: 'startH',
    startM: 'startM',
    endH: 'endH',
    endM: 'endM'
  };

  export type PeriodScalarFieldEnum = (typeof PeriodScalarFieldEnum)[keyof typeof PeriodScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    password: 'password',
    nickname: 'nickname',
    randomNickname: 'randomNickname',
    point: 'point',
    joinedAt: 'joinedAt',
    refreshToken: 'refreshToken'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ReportCommentScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    userId: 'userId',
    title: 'title',
    body: 'body',
    reportedAt: 'reportedAt'
  };

  export type ReportCommentScalarFieldEnum = (typeof ReportCommentScalarFieldEnum)[keyof typeof ReportCommentScalarFieldEnum]


  export const ReportPostScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    title: 'title',
    body: 'body',
    reportedAt: 'reportedAt'
  };

  export type ReportPostScalarFieldEnum = (typeof ReportPostScalarFieldEnum)[keyof typeof ReportPostScalarFieldEnum]


  export const ReportSubcommentScalarFieldEnum: {
    id: 'id',
    subcommentId: 'subcommentId',
    userId: 'userId',
    title: 'title',
    body: 'body',
    reportedAt: 'reportedAt'
  };

  export type ReportSubcommentScalarFieldEnum = (typeof ReportSubcommentScalarFieldEnum)[keyof typeof ReportSubcommentScalarFieldEnum]


  export const TelegramScalarFieldEnum: {
    userId: 'userId',
    chatId: 'chatId'
  };

  export type TelegramScalarFieldEnum = (typeof TelegramScalarFieldEnum)[keyof typeof TelegramScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: Enumerable<AdminWhereInput>
    OR?: Enumerable<AdminWhereInput>
    NOT?: Enumerable<AdminWhereInput>
    userId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdminOrderByInput = {
    userId?: SortOrder
  }

  export type AdminWhereUniqueInput = {
    userId?: number
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdminScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdminScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdminScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
  }

  export type CafeteriaMenuWhereInput = {
    AND?: Enumerable<CafeteriaMenuWhereInput>
    OR?: Enumerable<CafeteriaMenuWhereInput>
    NOT?: Enumerable<CafeteriaMenuWhereInput>
    campus?: StringFilter | string
    servedAt?: DateTimeFilter | Date | string
    data?: JsonNullableFilter
  }

  export type CafeteriaMenuOrderByInput = {
    campus?: SortOrder
    servedAt?: SortOrder
    data?: SortOrder
  }

  export type CafeteriaMenuWhereUniqueInput = {
    campus_servedAt?: CafeteriaMenuCampusServedAtCompoundUniqueInput
  }

  export type CafeteriaMenuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeteriaMenuScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeteriaMenuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeteriaMenuScalarWhereWithAggregatesInput>
    campus?: StringWithAggregatesFilter | string
    servedAt?: DateTimeWithAggregatesFilter | Date | string
    data?: JsonNullableWithAggregatesFilter
  }

  export type ChangePasswordWhereInput = {
    AND?: Enumerable<ChangePasswordWhereInput>
    OR?: Enumerable<ChangePasswordWhereInput>
    NOT?: Enumerable<ChangePasswordWhereInput>
    userId?: IntFilter | number
    token?: StringFilter | string
    requestedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChangePasswordOrderByInput = {
    userId?: SortOrder
    token?: SortOrder
    requestedAt?: SortOrder
  }

  export type ChangePasswordWhereUniqueInput = {
    userId?: number
    token?: string
  }

  export type ChangePasswordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChangePasswordScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChangePasswordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChangePasswordScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    token?: StringWithAggregatesFilter | string
    requestedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CommunityBoardWhereInput = {
    AND?: Enumerable<CommunityBoardWhereInput>
    OR?: Enumerable<CommunityBoardWhereInput>
    NOT?: Enumerable<CommunityBoardWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    priority?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    createdBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    activeAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    communityBoardPins?: CommunityBoardPinListRelationFilter
    communityPosts?: CommunityPostListRelationFilter
  }

  export type CommunityBoardOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    isDeleted?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    activeAt?: SortOrder
  }

  export type CommunityBoardWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type CommunityBoardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommunityBoardScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommunityBoardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommunityBoardScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    priority?: IntWithAggregatesFilter | number
    isDeleted?: BoolWithAggregatesFilter | boolean
    createdBy?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    activeAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CommunityBoardCandidateWhereInput = {
    AND?: Enumerable<CommunityBoardCandidateWhereInput>
    OR?: Enumerable<CommunityBoardCandidateWhereInput>
    NOT?: Enumerable<CommunityBoardCandidateWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteListRelationFilter
  }

  export type CommunityBoardCandidateOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityBoardCandidateWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type CommunityBoardCandidateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommunityBoardCandidateScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommunityBoardCandidateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommunityBoardCandidateScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    createdBy?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CommunityBoardCandidateVoteWhereInput = {
    AND?: Enumerable<CommunityBoardCandidateVoteWhereInput>
    OR?: Enumerable<CommunityBoardCandidateVoteWhereInput>
    NOT?: Enumerable<CommunityBoardCandidateVoteWhereInput>
    boardCandidateId?: IntFilter | number
    userId?: IntFilter | number
    communityBoardCandidate?: XOR<CommunityBoardCandidateRelationFilter, CommunityBoardCandidateWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommunityBoardCandidateVoteOrderByInput = {
    boardCandidateId?: SortOrder
    userId?: SortOrder
  }

  export type CommunityBoardCandidateVoteWhereUniqueInput = {
    boardCandidateId_userId?: CommunityBoardCandidateVoteBoardCandidateIdUserIdCompoundUniqueInput
  }

  export type CommunityBoardCandidateVoteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommunityBoardCandidateVoteScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommunityBoardCandidateVoteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommunityBoardCandidateVoteScalarWhereWithAggregatesInput>
    boardCandidateId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
  }

  export type CommunityBoardPinWhereInput = {
    AND?: Enumerable<CommunityBoardPinWhereInput>
    OR?: Enumerable<CommunityBoardPinWhereInput>
    NOT?: Enumerable<CommunityBoardPinWhereInput>
    userId?: IntFilter | number
    boardId?: IntFilter | number
    communityBoard?: XOR<CommunityBoardRelationFilter, CommunityBoardWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommunityBoardPinOrderByInput = {
    userId?: SortOrder
    boardId?: SortOrder
  }

  export type CommunityBoardPinWhereUniqueInput = {
    userId_boardId?: CommunityBoardPinUserIdBoardIdCompoundUniqueInput
  }

  export type CommunityBoardPinScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommunityBoardPinScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommunityBoardPinScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommunityBoardPinScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    boardId?: IntWithAggregatesFilter | number
  }

  export type CommunityCommentWhereInput = {
    AND?: Enumerable<CommunityCommentWhereInput>
    OR?: Enumerable<CommunityCommentWhereInput>
    NOT?: Enumerable<CommunityCommentWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    userId?: IntFilter | number
    randomNickname?: StringFilter | string
    body?: StringFilter | string
    commentedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    communityPost?: XOR<CommunityPostRelationFilter, CommunityPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    communitySubcomments?: CommunitySubcommentListRelationFilter
    reportComments?: ReportCommentListRelationFilter
  }

  export type CommunityCommentOrderByInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    randomNickname?: SortOrder
    body?: SortOrder
    commentedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type CommunityCommentWhereUniqueInput = {
    id?: number
  }

  export type CommunityCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommunityCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommunityCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommunityCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    randomNickname?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    commentedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type CommunityPostWhereInput = {
    AND?: Enumerable<CommunityPostWhereInput>
    OR?: Enumerable<CommunityPostWhereInput>
    NOT?: Enumerable<CommunityPostWhereInput>
    id?: IntFilter | number
    boardId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringFilter | string
    randomNickname?: StringFilter | string
    likesCount?: IntFilter | number
    commentsCount?: IntFilter | number
    bookmarksCount?: IntFilter | number
    postedAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeNullableFilter | Date | string | null
    isDeleted?: BoolFilter | boolean
    communityBoard?: XOR<CommunityBoardRelationFilter, CommunityBoardWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    communityComments?: CommunityCommentListRelationFilter
    communityPostBookmarks?: CommunityPostBookmarkListRelationFilter
    communityPostLikes?: CommunityPostLikeListRelationFilter
    communitySubcomments?: CommunitySubcommentListRelationFilter
    reportPosts?: ReportPostListRelationFilter
  }

  export type CommunityPostOrderByInput = {
    id?: SortOrder
    boardId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    randomNickname?: SortOrder
    likesCount?: SortOrder
    commentsCount?: SortOrder
    bookmarksCount?: SortOrder
    postedAt?: SortOrder
    editedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type CommunityPostWhereUniqueInput = {
    id?: number
  }

  export type CommunityPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommunityPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommunityPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommunityPostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    boardId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    randomNickname?: StringWithAggregatesFilter | string
    likesCount?: IntWithAggregatesFilter | number
    commentsCount?: IntWithAggregatesFilter | number
    bookmarksCount?: IntWithAggregatesFilter | number
    postedAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type CommunityPostBookmarkWhereInput = {
    AND?: Enumerable<CommunityPostBookmarkWhereInput>
    OR?: Enumerable<CommunityPostBookmarkWhereInput>
    NOT?: Enumerable<CommunityPostBookmarkWhereInput>
    userId?: IntFilter | number
    postId?: IntFilter | number
    communityPost?: XOR<CommunityPostRelationFilter, CommunityPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommunityPostBookmarkOrderByInput = {
    userId?: SortOrder
    postId?: SortOrder
  }

  export type CommunityPostBookmarkWhereUniqueInput = {
    userId_postId?: CommunityPostBookmarkUserIdPostIdCompoundUniqueInput
  }

  export type CommunityPostBookmarkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommunityPostBookmarkScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommunityPostBookmarkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommunityPostBookmarkScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
  }

  export type CommunityPostLikeWhereInput = {
    AND?: Enumerable<CommunityPostLikeWhereInput>
    OR?: Enumerable<CommunityPostLikeWhereInput>
    NOT?: Enumerable<CommunityPostLikeWhereInput>
    userId?: IntFilter | number
    postId?: IntFilter | number
    communityPost?: XOR<CommunityPostRelationFilter, CommunityPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommunityPostLikeOrderByInput = {
    userId?: SortOrder
    postId?: SortOrder
  }

  export type CommunityPostLikeWhereUniqueInput = {
    userId_postId?: CommunityPostLikeUserIdPostIdCompoundUniqueInput
  }

  export type CommunityPostLikeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommunityPostLikeScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommunityPostLikeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommunityPostLikeScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
  }

  export type CommunitySubcommentWhereInput = {
    AND?: Enumerable<CommunitySubcommentWhereInput>
    OR?: Enumerable<CommunitySubcommentWhereInput>
    NOT?: Enumerable<CommunitySubcommentWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    postId?: IntFilter | number
    commentId?: IntFilter | number
    randomNickname?: StringFilter | string
    body?: StringFilter | string
    subcommentedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    communityComment?: XOR<CommunityCommentRelationFilter, CommunityCommentWhereInput>
    communityPost?: XOR<CommunityPostRelationFilter, CommunityPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    reportSubcomments?: ReportSubcommentListRelationFilter
  }

  export type CommunitySubcommentOrderByInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    randomNickname?: SortOrder
    body?: SortOrder
    subcommentedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type CommunitySubcommentWhereUniqueInput = {
    id?: number
  }

  export type CommunitySubcommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommunitySubcommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommunitySubcommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommunitySubcommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    commentId?: IntWithAggregatesFilter | number
    randomNickname?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    subcommentedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type CoverageMajorWhereInput = {
    AND?: Enumerable<CoverageMajorWhereInput>
    OR?: Enumerable<CoverageMajorWhereInput>
    NOT?: Enumerable<CoverageMajorWhereInput>
    coverageCollege?: StringNullableFilter | string | null
    name?: StringFilter | string
    code?: StringFilter | string
    coverageMajorLectures?: CoverageMajorLectureListRelationFilter
  }

  export type CoverageMajorOrderByInput = {
    coverageCollege?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type CoverageMajorWhereUniqueInput = {
    code?: string
  }

  export type CoverageMajorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CoverageMajorScalarWhereWithAggregatesInput>
    OR?: Enumerable<CoverageMajorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CoverageMajorScalarWhereWithAggregatesInput>
    coverageCollege?: StringNullableWithAggregatesFilter | string | null
    name?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
  }

  export type CoverageMajorLectureWhereInput = {
    AND?: Enumerable<CoverageMajorLectureWhereInput>
    OR?: Enumerable<CoverageMajorLectureWhereInput>
    NOT?: Enumerable<CoverageMajorLectureWhereInput>
    lectureId?: StringFilter | string
    majorCode?: StringFilter | string
    lecture?: XOR<LectureRelationFilter, LectureWhereInput>
    coverageMajor?: XOR<CoverageMajorRelationFilter, CoverageMajorWhereInput>
  }

  export type CoverageMajorLectureOrderByInput = {
    lectureId?: SortOrder
    majorCode?: SortOrder
  }

  export type CoverageMajorLectureWhereUniqueInput = {
    lectureId_majorCode?: CoverageMajorLectureLectureIdMajorCodeCompoundUniqueInput
  }

  export type CoverageMajorLectureScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CoverageMajorLectureScalarWhereWithAggregatesInput>
    OR?: Enumerable<CoverageMajorLectureScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CoverageMajorLectureScalarWhereWithAggregatesInput>
    lectureId?: StringWithAggregatesFilter | string
    majorCode?: StringWithAggregatesFilter | string
  }

  export type LectureWhereInput = {
    AND?: Enumerable<LectureWhereInput>
    OR?: Enumerable<LectureWhereInput>
    NOT?: Enumerable<LectureWhereInput>
    id?: StringFilter | string
    year?: IntNullableFilter | number | null
    semester?: StringNullableFilter | string | null
    campus?: StringNullableFilter | string | null
    college?: StringNullableFilter | string | null
    major?: StringNullableFilter | string | null
    grade?: IntNullableFilter | number | null
    credit?: IntNullableFilter | number | null
    course?: StringNullableFilter | string | null
    section?: StringNullableFilter | string | null
    code?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    professor?: StringNullableFilter | string | null
    schedule?: StringNullableFilter | string | null
    building?: IntNullableFilter | number | null
    room?: StringNullableFilter | string | null
    note?: StringNullableFilter | string | null
    coverageMajorLectures?: CoverageMajorLectureListRelationFilter
    periods?: PeriodListRelationFilter
  }

  export type LectureOrderByInput = {
    id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    campus?: SortOrder
    college?: SortOrder
    major?: SortOrder
    grade?: SortOrder
    credit?: SortOrder
    course?: SortOrder
    section?: SortOrder
    code?: SortOrder
    name?: SortOrder
    professor?: SortOrder
    schedule?: SortOrder
    building?: SortOrder
    room?: SortOrder
    note?: SortOrder
  }

  export type LectureWhereUniqueInput = {
    id?: string
  }

  export type LectureScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LectureScalarWhereWithAggregatesInput>
    OR?: Enumerable<LectureScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LectureScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    year?: IntNullableWithAggregatesFilter | number | null
    semester?: StringNullableWithAggregatesFilter | string | null
    campus?: StringNullableWithAggregatesFilter | string | null
    college?: StringNullableWithAggregatesFilter | string | null
    major?: StringNullableWithAggregatesFilter | string | null
    grade?: IntNullableWithAggregatesFilter | number | null
    credit?: IntNullableWithAggregatesFilter | number | null
    course?: StringNullableWithAggregatesFilter | string | null
    section?: StringNullableWithAggregatesFilter | string | null
    code?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    professor?: StringNullableWithAggregatesFilter | string | null
    schedule?: StringNullableWithAggregatesFilter | string | null
    building?: IntNullableWithAggregatesFilter | number | null
    room?: StringNullableWithAggregatesFilter | string | null
    note?: StringNullableWithAggregatesFilter | string | null
  }

  export type LiveChatWhereInput = {
    AND?: Enumerable<LiveChatWhereInput>
    OR?: Enumerable<LiveChatWhereInput>
    NOT?: Enumerable<LiveChatWhereInput>
    id?: IntFilter | number
    message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    randomNickname?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LiveChatOrderByInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    randomNickname?: SortOrder
  }

  export type LiveChatWhereUniqueInput = {
    id_userId?: LiveChatIdUserIdCompoundUniqueInput
  }

  export type LiveChatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LiveChatScalarWhereWithAggregatesInput>
    OR?: Enumerable<LiveChatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LiveChatScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    message?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: IntWithAggregatesFilter | number
    randomNickname?: StringWithAggregatesFilter | string
  }

  export type NoticeNotificationsSubscriptionWhereInput = {
    AND?: Enumerable<NoticeNotificationsSubscriptionWhereInput>
    OR?: Enumerable<NoticeNotificationsSubscriptionWhereInput>
    NOT?: Enumerable<NoticeNotificationsSubscriptionWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    noticeKey?: StringFilter | string
    subscribedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NoticeNotificationsSubscriptionOrderByInput = {
    id?: SortOrder
    userId?: SortOrder
    noticeKey?: SortOrder
    subscribedAt?: SortOrder
  }

  export type NoticeNotificationsSubscriptionWhereUniqueInput = {
    id?: number
  }

  export type NoticeNotificationsSubscriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NoticeNotificationsSubscriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<NoticeNotificationsSubscriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NoticeNotificationsSubscriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    noticeKey?: StringWithAggregatesFilter | string
    subscribedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PendingUserWhereInput = {
    AND?: Enumerable<PendingUserWhereInput>
    OR?: Enumerable<PendingUserWhereInput>
    NOT?: Enumerable<PendingUserWhereInput>
    id?: IntFilter | number
    portalId?: StringFilter | string
    password?: StringFilter | string
    nickname?: StringFilter | string
    randomNickname?: StringFilter | string
    joinedAt?: DateTimeFilter | Date | string
    token?: StringFilter | string
  }

  export type PendingUserOrderByInput = {
    id?: SortOrder
    portalId?: SortOrder
    password?: SortOrder
    nickname?: SortOrder
    randomNickname?: SortOrder
    joinedAt?: SortOrder
    token?: SortOrder
  }

  export type PendingUserWhereUniqueInput = {
    id?: number
    portalId?: string
    nickname?: string
    token?: string
  }

  export type PendingUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PendingUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<PendingUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PendingUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    portalId?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    nickname?: StringWithAggregatesFilter | string
    randomNickname?: StringWithAggregatesFilter | string
    joinedAt?: DateTimeWithAggregatesFilter | Date | string
    token?: StringWithAggregatesFilter | string
  }

  export type PeriodWhereInput = {
    AND?: Enumerable<PeriodWhereInput>
    OR?: Enumerable<PeriodWhereInput>
    NOT?: Enumerable<PeriodWhereInput>
    lectureId?: StringFilter | string
    day?: StringFilter | string
    startH?: IntFilter | number
    startM?: IntFilter | number
    endH?: IntFilter | number
    endM?: IntFilter | number
    lecture?: XOR<LectureRelationFilter, LectureWhereInput>
  }

  export type PeriodOrderByInput = {
    lectureId?: SortOrder
    day?: SortOrder
    startH?: SortOrder
    startM?: SortOrder
    endH?: SortOrder
    endM?: SortOrder
  }

  export type PeriodWhereUniqueInput = {
    lectureId_day_startH_startM_endH_endM?: PeriodLectureIdDayStartHStartMEndHEndMCompoundUniqueInput
  }

  export type PeriodScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PeriodScalarWhereWithAggregatesInput>
    OR?: Enumerable<PeriodScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PeriodScalarWhereWithAggregatesInput>
    lectureId?: StringWithAggregatesFilter | string
    day?: StringWithAggregatesFilter | string
    startH?: IntWithAggregatesFilter | number
    startM?: IntWithAggregatesFilter | number
    endH?: IntWithAggregatesFilter | number
    endM?: IntWithAggregatesFilter | number
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    portalId?: StringFilter | string
    password?: StringFilter | string
    nickname?: StringFilter | string
    randomNickname?: StringFilter | string
    point?: IntNullableFilter | number | null
    joinedAt?: DateTimeFilter | Date | string
    refreshToken?: StringNullableFilter | string | null
    admin?: XOR<AdminRelationFilter, AdminWhereInput> | null
    changePassword?: XOR<ChangePasswordRelationFilter, ChangePasswordWhereInput> | null
    communityBoards?: CommunityBoardListRelationFilter
    communityBoardCandidates?: CommunityBoardCandidateListRelationFilter
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteListRelationFilter
    communityBoardPins?: CommunityBoardPinListRelationFilter
    communityComments?: CommunityCommentListRelationFilter
    communityPosts?: CommunityPostListRelationFilter
    communityPostBookmarks?: CommunityPostBookmarkListRelationFilter
    communityPostLikes?: CommunityPostLikeListRelationFilter
    communitySubcomments?: CommunitySubcommentListRelationFilter
    liveChats?: LiveChatListRelationFilter
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionListRelationFilter
    reportComments?: ReportCommentListRelationFilter
    reportPosts?: ReportPostListRelationFilter
    reportSubcomments?: ReportSubcommentListRelationFilter
    telegrams?: TelegramListRelationFilter
  }

  export type UserOrderByInput = {
    id?: SortOrder
    portalId?: SortOrder
    password?: SortOrder
    nickname?: SortOrder
    randomNickname?: SortOrder
    point?: SortOrder
    joinedAt?: SortOrder
    refreshToken?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: number
    portalId?: string
    nickname?: string
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    portalId?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    nickname?: StringWithAggregatesFilter | string
    randomNickname?: StringWithAggregatesFilter | string
    point?: IntNullableWithAggregatesFilter | number | null
    joinedAt?: DateTimeWithAggregatesFilter | Date | string
    refreshToken?: StringNullableWithAggregatesFilter | string | null
  }

  export type ReportCommentWhereInput = {
    AND?: Enumerable<ReportCommentWhereInput>
    OR?: Enumerable<ReportCommentWhereInput>
    NOT?: Enumerable<ReportCommentWhereInput>
    id?: IntFilter | number
    commentId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
    communityComment?: XOR<CommunityCommentRelationFilter, CommunityCommentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReportCommentOrderByInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    reportedAt?: SortOrder
  }

  export type ReportCommentWhereUniqueInput = {
    id?: number
  }

  export type ReportCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReportCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReportCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReportCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    commentId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    body?: StringNullableWithAggregatesFilter | string | null
    reportedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ReportPostWhereInput = {
    AND?: Enumerable<ReportPostWhereInput>
    OR?: Enumerable<ReportPostWhereInput>
    NOT?: Enumerable<ReportPostWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
    communityPost?: XOR<CommunityPostRelationFilter, CommunityPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReportPostOrderByInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    reportedAt?: SortOrder
  }

  export type ReportPostWhereUniqueInput = {
    id?: number
  }

  export type ReportPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReportPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReportPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReportPostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    body?: StringNullableWithAggregatesFilter | string | null
    reportedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ReportSubcommentWhereInput = {
    AND?: Enumerable<ReportSubcommentWhereInput>
    OR?: Enumerable<ReportSubcommentWhereInput>
    NOT?: Enumerable<ReportSubcommentWhereInput>
    id?: IntFilter | number
    subcommentId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
    communitySubcomment?: XOR<CommunitySubcommentRelationFilter, CommunitySubcommentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReportSubcommentOrderByInput = {
    id?: SortOrder
    subcommentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    reportedAt?: SortOrder
  }

  export type ReportSubcommentWhereUniqueInput = {
    id?: number
  }

  export type ReportSubcommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReportSubcommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReportSubcommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReportSubcommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    subcommentId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    body?: StringNullableWithAggregatesFilter | string | null
    reportedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TelegramWhereInput = {
    AND?: Enumerable<TelegramWhereInput>
    OR?: Enumerable<TelegramWhereInput>
    NOT?: Enumerable<TelegramWhereInput>
    userId?: IntFilter | number
    chatId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TelegramOrderByInput = {
    userId?: SortOrder
    chatId?: SortOrder
  }

  export type TelegramWhereUniqueInput = {
    userId_chatId?: TelegramUserIdChatIdCompoundUniqueInput
  }

  export type TelegramScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TelegramScalarWhereWithAggregatesInput>
    OR?: Enumerable<TelegramScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TelegramScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    chatId?: IntWithAggregatesFilter | number
  }

  export type AdminCreateInput = {
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    userId: number
  }

  export type AdminUpdateInput = {
    user?: UserUpdateOneRequiredWithoutAdminInput
  }

  export type AdminUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AdminCreateManyInput = {
    userId: number
  }

  export type AdminUpdateManyMutationInput = {

  }

  export type AdminUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeteriaMenuCreateInput = {
    campus: string
    servedAt: Date | string
    data?: InputJsonValue | null
  }

  export type CafeteriaMenuUncheckedCreateInput = {
    campus: string
    servedAt: Date | string
    data?: InputJsonValue | null
  }

  export type CafeteriaMenuUpdateInput = {
    campus?: StringFieldUpdateOperationsInput | string
    servedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: InputJsonValue | null
  }

  export type CafeteriaMenuUncheckedUpdateInput = {
    campus?: StringFieldUpdateOperationsInput | string
    servedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: InputJsonValue | null
  }

  export type CafeteriaMenuCreateManyInput = {
    campus: string
    servedAt: Date | string
    data?: InputJsonValue | null
  }

  export type CafeteriaMenuUpdateManyMutationInput = {
    campus?: StringFieldUpdateOperationsInput | string
    servedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: InputJsonValue | null
  }

  export type CafeteriaMenuUncheckedUpdateManyInput = {
    campus?: StringFieldUpdateOperationsInput | string
    servedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: InputJsonValue | null
  }

  export type ChangePasswordCreateInput = {
    token: string
    requestedAt: Date | string
    user: UserCreateNestedOneWithoutChangePasswordInput
  }

  export type ChangePasswordUncheckedCreateInput = {
    userId: number
    token: string
    requestedAt: Date | string
  }

  export type ChangePasswordUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChangePasswordInput
  }

  export type ChangePasswordUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangePasswordCreateManyInput = {
    userId: number
    token: string
    requestedAt: Date | string
  }

  export type ChangePasswordUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangePasswordUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBoardCreateInput = {
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdAt: Date | string
    activeAt?: Date | string | null
    user: UserCreateNestedOneWithoutCommunityBoardsInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedCreateInput = {
    id?: number
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdBy: number
    createdAt: Date | string
    activeAt?: Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCommunityBoardsInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardCreateManyInput = {
    id?: number
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdBy: number
    createdAt: Date | string
    activeAt?: Date | string | null
  }

  export type CommunityBoardUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityBoardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityBoardCandidateCreateInput = {
    name?: string
    description?: string | null
    createdAt: Date | string
    user: UserCreateNestedOneWithoutCommunityBoardCandidatesInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUncheckedCreateInput = {
    id?: number
    name?: string
    description?: string | null
    createdBy: number
    createdAt: Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommunityBoardCandidatesInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateCreateManyInput = {
    id?: number
    name?: string
    description?: string | null
    createdBy: number
    createdAt: Date | string
  }

  export type CommunityBoardCandidateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBoardCandidateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBoardCandidateVoteCreateInput = {
    communityBoardCandidate: CommunityBoardCandidateCreateNestedOneWithoutCommunityBoardCandidateVotesInput
    user: UserCreateNestedOneWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedCreateInput = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardCandidateVoteUpdateInput = {
    communityBoardCandidate?: CommunityBoardCandidateUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput
    user?: UserUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateInput = {
    boardCandidateId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardCandidateVoteCreateManyInput = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardCandidateVoteUpdateManyMutationInput = {

  }

  export type CommunityBoardCandidateVoteUncheckedUpdateManyInput = {
    boardCandidateId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardPinCreateInput = {
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityBoardPinsInput
    user: UserCreateNestedOneWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedCreateInput = {
    userId: number
    boardId: number
  }

  export type CommunityBoardPinUpdateInput = {
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityBoardPinsInput
    user?: UserUpdateOneRequiredWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardPinCreateManyInput = {
    userId: number
    boardId: number
  }

  export type CommunityBoardPinUpdateManyMutationInput = {

  }

  export type CommunityBoardPinUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityCommentCreateInput = {
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communityPost: CommunityPostCreateNestedOneWithoutCommunityCommentsInput
    user: UserCreateNestedOneWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUpdateInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityCommentsInput
    user?: UserUpdateOneRequiredWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentCreateManyInput = {
    id?: number
    postId: number
    userId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
  }

  export type CommunityCommentUpdateManyMutationInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityPostCreateInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateManyInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type CommunityPostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityPostBookmarkCreateInput = {
    communityPost: CommunityPostCreateNestedOneWithoutCommunityPostBookmarksInput
    user: UserCreateNestedOneWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedCreateInput = {
    userId: number
    postId: number
  }

  export type CommunityPostBookmarkUpdateInput = {
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityPostBookmarksInput
    user?: UserUpdateOneRequiredWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostBookmarkCreateManyInput = {
    userId: number
    postId: number
  }

  export type CommunityPostBookmarkUpdateManyMutationInput = {

  }

  export type CommunityPostBookmarkUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostLikeCreateInput = {
    communityPost: CommunityPostCreateNestedOneWithoutCommunityPostLikesInput
    user: UserCreateNestedOneWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedCreateInput = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeUpdateInput = {
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityPostLikesInput
    user?: UserUpdateOneRequiredWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostLikeCreateManyInput = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeUpdateManyMutationInput = {

  }

  export type CommunityPostLikeUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunitySubcommentCreateInput = {
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    communityComment: CommunityCommentCreateNestedOneWithoutCommunitySubcommentsInput
    communityPost: CommunityPostCreateNestedOneWithoutCommunitySubcommentsInput
    user: UserCreateNestedOneWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedCreateInput = {
    id?: number
    userId: number
    postId: number
    commentId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUpdateInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComment?: CommunityCommentUpdateOneRequiredWithoutCommunitySubcommentsInput
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunitySubcommentsInput
    user?: UserUpdateOneRequiredWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentCreateManyInput = {
    id?: number
    userId: number
    postId: number
    commentId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
  }

  export type CommunitySubcommentUpdateManyMutationInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunitySubcommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CoverageMajorCreateInput = {
    coverageCollege?: string | null
    name: string
    code: string
    coverageMajorLectures?: CoverageMajorLectureCreateNestedManyWithoutCoverageMajorInput
  }

  export type CoverageMajorUncheckedCreateInput = {
    coverageCollege?: string | null
    name: string
    code: string
    coverageMajorLectures?: CoverageMajorLectureUncheckedCreateNestedManyWithoutCoverageMajorInput
  }

  export type CoverageMajorUpdateInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    coverageMajorLectures?: CoverageMajorLectureUpdateManyWithoutCoverageMajorInput
  }

  export type CoverageMajorUncheckedUpdateInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    coverageMajorLectures?: CoverageMajorLectureUncheckedUpdateManyWithoutCoverageMajorInput
  }

  export type CoverageMajorCreateManyInput = {
    coverageCollege?: string | null
    name: string
    code: string
  }

  export type CoverageMajorUpdateManyMutationInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorUncheckedUpdateManyInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorLectureCreateInput = {
    lecture: LectureCreateNestedOneWithoutCoverageMajorLecturesInput
    coverageMajor: CoverageMajorCreateNestedOneWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedCreateInput = {
    lectureId: string
    majorCode: string
  }

  export type CoverageMajorLectureUpdateInput = {
    lecture?: LectureUpdateOneRequiredWithoutCoverageMajorLecturesInput
    coverageMajor?: CoverageMajorUpdateOneRequiredWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedUpdateInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
    majorCode?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorLectureCreateManyInput = {
    lectureId: string
    majorCode: string
  }

  export type CoverageMajorLectureUpdateManyMutationInput = {

  }

  export type CoverageMajorLectureUncheckedUpdateManyInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
    majorCode?: StringFieldUpdateOperationsInput | string
  }

  export type LectureCreateInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    coverageMajorLectures?: CoverageMajorLectureCreateNestedManyWithoutLectureInput
    periods?: PeriodCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    coverageMajorLectures?: CoverageMajorLectureUncheckedCreateNestedManyWithoutLectureInput
    periods?: PeriodUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    coverageMajorLectures?: CoverageMajorLectureUpdateManyWithoutLectureInput
    periods?: PeriodUpdateManyWithoutLectureInput
  }

  export type LectureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    coverageMajorLectures?: CoverageMajorLectureUncheckedUpdateManyWithoutLectureInput
    periods?: PeriodUncheckedUpdateManyWithoutLectureInput
  }

  export type LectureCreateManyInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
  }

  export type LectureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LectureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiveChatCreateInput = {
    id?: number
    message: string
    createdAt: Date | string
    randomNickname: string
    user: UserCreateNestedOneWithoutLiveChatsInput
  }

  export type LiveChatUncheckedCreateInput = {
    id?: number
    message: string
    createdAt: Date | string
    userId: number
    randomNickname: string
  }

  export type LiveChatUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLiveChatsInput
  }

  export type LiveChatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type LiveChatCreateManyInput = {
    id?: number
    message: string
    createdAt: Date | string
    userId: number
    randomNickname: string
  }

  export type LiveChatUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type LiveChatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type NoticeNotificationsSubscriptionCreateInput = {
    noticeKey: string
    subscribedAt: Date | string
    user: UserCreateNestedOneWithoutNoticeNotificationsSubscriptionsInput
  }

  export type NoticeNotificationsSubscriptionUncheckedCreateInput = {
    id?: number
    userId: number
    noticeKey: string
    subscribedAt: Date | string
  }

  export type NoticeNotificationsSubscriptionUpdateInput = {
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNoticeNotificationsSubscriptionsInput
  }

  export type NoticeNotificationsSubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeNotificationsSubscriptionCreateManyInput = {
    id?: number
    userId: number
    noticeKey: string
    subscribedAt: Date | string
  }

  export type NoticeNotificationsSubscriptionUpdateManyMutationInput = {
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeNotificationsSubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingUserCreateInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    token: string
  }

  export type PendingUserUncheckedCreateInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    token: string
  }

  export type PendingUserUpdateInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type PendingUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type PendingUserCreateManyInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    joinedAt: Date | string
    token: string
  }

  export type PendingUserUpdateManyMutationInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type PendingUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type PeriodCreateInput = {
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
    lecture: LectureCreateNestedOneWithoutPeriodsInput
  }

  export type PeriodUncheckedCreateInput = {
    lectureId: string
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodUpdateInput = {
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
    lecture?: LectureUpdateOneRequiredWithoutPeriodsInput
  }

  export type PeriodUncheckedUpdateInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type PeriodCreateManyInput = {
    lectureId: string
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodUpdateManyMutationInput = {
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type PeriodUncheckedUpdateManyInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
  }

  export type UserUpdateManyMutationInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCommentCreateInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communityComment: CommunityCommentCreateNestedOneWithoutReportCommentsInput
    user: UserCreateNestedOneWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedCreateInput = {
    id?: number
    commentId: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportCommentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityComment?: CommunityCommentUpdateOneRequiredWithoutReportCommentsInput
    user?: UserUpdateOneRequiredWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCommentCreateManyInput = {
    id?: number
    commentId: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportCommentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPostCreateInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communityPost: CommunityPostCreateNestedOneWithoutReportPostsInput
    user: UserCreateNestedOneWithoutReportPostsInput
  }

  export type ReportPostUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportPostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityPost?: CommunityPostUpdateOneRequiredWithoutReportPostsInput
    user?: UserUpdateOneRequiredWithoutReportPostsInput
  }

  export type ReportPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPostCreateManyInput = {
    id?: number
    postId: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportPostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentCreateInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communitySubcomment: CommunitySubcommentCreateNestedOneWithoutReportSubcommentsInput
    user: UserCreateNestedOneWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedCreateInput = {
    id?: number
    subcommentId: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportSubcommentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communitySubcomment?: CommunitySubcommentUpdateOneRequiredWithoutReportSubcommentsInput
    user?: UserUpdateOneRequiredWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subcommentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentCreateManyInput = {
    id?: number
    subcommentId: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportSubcommentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subcommentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramCreateInput = {
    chatId: number
    user: UserCreateNestedOneWithoutTelegramsInput
  }

  export type TelegramUncheckedCreateInput = {
    userId: number
    chatId: number
  }

  export type TelegramUpdateInput = {
    chatId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutTelegramsInput
  }

  export type TelegramUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
  }

  export type TelegramCreateManyInput = {
    userId: number
    chatId: number
  }

  export type TelegramUpdateManyMutationInput = {
    chatId?: IntFieldUpdateOperationsInput | number
  }

  export type TelegramUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type JsonNullableFilter = {
    equals?: InputJsonValue | null
    not?: InputJsonValue | null
  }

  export type CafeteriaMenuCampusServedAtCompoundUniqueInput = {
    campus: string
    servedAt: Date | string
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type JsonNullableWithAggregatesFilter = {
    equals?: InputJsonValue | null
    not?: InputJsonValue | null
    count?: NestedIntNullableFilter
    min?: NestedJsonNullableFilter
    max?: NestedJsonNullableFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type CommunityBoardPinListRelationFilter = {
    every?: CommunityBoardPinWhereInput
    some?: CommunityBoardPinWhereInput
    none?: CommunityBoardPinWhereInput
  }

  export type CommunityPostListRelationFilter = {
    every?: CommunityPostWhereInput
    some?: CommunityPostWhereInput
    none?: CommunityPostWhereInput
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    count?: NestedIntNullableFilter
    min?: NestedStringNullableFilter
    max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    count?: NestedIntFilter
    min?: NestedBoolFilter
    max?: NestedBoolFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    count?: NestedIntNullableFilter
    min?: NestedDateTimeNullableFilter
    max?: NestedDateTimeNullableFilter
  }

  export type CommunityBoardCandidateVoteListRelationFilter = {
    every?: CommunityBoardCandidateVoteWhereInput
    some?: CommunityBoardCandidateVoteWhereInput
    none?: CommunityBoardCandidateVoteWhereInput
  }

  export type CommunityBoardCandidateRelationFilter = {
    is?: CommunityBoardCandidateWhereInput
    isNot?: CommunityBoardCandidateWhereInput
  }

  export type CommunityBoardCandidateVoteBoardCandidateIdUserIdCompoundUniqueInput = {
    boardCandidateId: number
    userId: number
  }

  export type CommunityBoardRelationFilter = {
    is?: CommunityBoardWhereInput
    isNot?: CommunityBoardWhereInput
  }

  export type CommunityBoardPinUserIdBoardIdCompoundUniqueInput = {
    userId: number
    boardId: number
  }

  export type CommunityPostRelationFilter = {
    is?: CommunityPostWhereInput
    isNot?: CommunityPostWhereInput
  }

  export type CommunitySubcommentListRelationFilter = {
    every?: CommunitySubcommentWhereInput
    some?: CommunitySubcommentWhereInput
    none?: CommunitySubcommentWhereInput
  }

  export type ReportCommentListRelationFilter = {
    every?: ReportCommentWhereInput
    some?: ReportCommentWhereInput
    none?: ReportCommentWhereInput
  }

  export type CommunityCommentListRelationFilter = {
    every?: CommunityCommentWhereInput
    some?: CommunityCommentWhereInput
    none?: CommunityCommentWhereInput
  }

  export type CommunityPostBookmarkListRelationFilter = {
    every?: CommunityPostBookmarkWhereInput
    some?: CommunityPostBookmarkWhereInput
    none?: CommunityPostBookmarkWhereInput
  }

  export type CommunityPostLikeListRelationFilter = {
    every?: CommunityPostLikeWhereInput
    some?: CommunityPostLikeWhereInput
    none?: CommunityPostLikeWhereInput
  }

  export type ReportPostListRelationFilter = {
    every?: ReportPostWhereInput
    some?: ReportPostWhereInput
    none?: ReportPostWhereInput
  }

  export type CommunityPostBookmarkUserIdPostIdCompoundUniqueInput = {
    userId: number
    postId: number
  }

  export type CommunityPostLikeUserIdPostIdCompoundUniqueInput = {
    userId: number
    postId: number
  }

  export type CommunityCommentRelationFilter = {
    is?: CommunityCommentWhereInput
    isNot?: CommunityCommentWhereInput
  }

  export type ReportSubcommentListRelationFilter = {
    every?: ReportSubcommentWhereInput
    some?: ReportSubcommentWhereInput
    none?: ReportSubcommentWhereInput
  }

  export type CoverageMajorLectureListRelationFilter = {
    every?: CoverageMajorLectureWhereInput
    some?: CoverageMajorLectureWhereInput
    none?: CoverageMajorLectureWhereInput
  }

  export type LectureRelationFilter = {
    is?: LectureWhereInput
    isNot?: LectureWhereInput
  }

  export type CoverageMajorRelationFilter = {
    is?: CoverageMajorWhereInput
    isNot?: CoverageMajorWhereInput
  }

  export type CoverageMajorLectureLectureIdMajorCodeCompoundUniqueInput = {
    lectureId: string
    majorCode: string
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type PeriodListRelationFilter = {
    every?: PeriodWhereInput
    some?: PeriodWhereInput
    none?: PeriodWhereInput
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedIntNullableFilter
    min?: NestedIntNullableFilter
    max?: NestedIntNullableFilter
  }

  export type LiveChatIdUserIdCompoundUniqueInput = {
    id: number
    userId: number
  }

  export type PeriodLectureIdDayStartHStartMEndHEndMCompoundUniqueInput = {
    lectureId: string
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type AdminRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type ChangePasswordRelationFilter = {
    is?: ChangePasswordWhereInput | null
    isNot?: ChangePasswordWhereInput | null
  }

  export type CommunityBoardListRelationFilter = {
    every?: CommunityBoardWhereInput
    some?: CommunityBoardWhereInput
    none?: CommunityBoardWhereInput
  }

  export type CommunityBoardCandidateListRelationFilter = {
    every?: CommunityBoardCandidateWhereInput
    some?: CommunityBoardCandidateWhereInput
    none?: CommunityBoardCandidateWhereInput
  }

  export type LiveChatListRelationFilter = {
    every?: LiveChatWhereInput
    some?: LiveChatWhereInput
    none?: LiveChatWhereInput
  }

  export type NoticeNotificationsSubscriptionListRelationFilter = {
    every?: NoticeNotificationsSubscriptionWhereInput
    some?: NoticeNotificationsSubscriptionWhereInput
    none?: NoticeNotificationsSubscriptionWhereInput
  }

  export type TelegramListRelationFilter = {
    every?: TelegramWhereInput
    some?: TelegramWhereInput
    none?: TelegramWhereInput
  }

  export type CommunitySubcommentRelationFilter = {
    is?: CommunitySubcommentWhereInput
    isNot?: CommunitySubcommentWhereInput
  }

  export type TelegramUserIdChatIdCompoundUniqueInput = {
    userId: number
    chatId: number
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserCreateNestedOneWithoutChangePasswordInput = {
    create?: XOR<UserCreateWithoutChangePasswordInput, UserUncheckedCreateWithoutChangePasswordInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangePasswordInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChangePasswordInput = {
    create?: XOR<UserCreateWithoutChangePasswordInput, UserUncheckedCreateWithoutChangePasswordInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangePasswordInput
    upsert?: UserUpsertWithoutChangePasswordInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutChangePasswordInput, UserUncheckedUpdateWithoutChangePasswordInput>
  }

  export type UserCreateNestedOneWithoutCommunityBoardsInput = {
    create?: XOR<UserCreateWithoutCommunityBoardsInput, UserUncheckedCreateWithoutCommunityBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityBoardsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityBoardPinCreateNestedManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityBoardPinCreateWithoutCommunityBoardInput>, Enumerable<CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutCommunityBoardInput>
    createMany?: CommunityBoardPinCreateManyCommunityBoardInputEnvelope
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
  }

  export type CommunityPostCreateNestedManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityPostCreateWithoutCommunityBoardInput>, Enumerable<CommunityPostUncheckedCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutCommunityBoardInput>
    createMany?: CommunityPostCreateManyCommunityBoardInputEnvelope
    connect?: Enumerable<CommunityPostWhereUniqueInput>
  }

  export type CommunityBoardPinUncheckedCreateNestedManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityBoardPinCreateWithoutCommunityBoardInput>, Enumerable<CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutCommunityBoardInput>
    createMany?: CommunityBoardPinCreateManyCommunityBoardInputEnvelope
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
  }

  export type CommunityPostUncheckedCreateNestedManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityPostCreateWithoutCommunityBoardInput>, Enumerable<CommunityPostUncheckedCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutCommunityBoardInput>
    createMany?: CommunityPostCreateManyCommunityBoardInputEnvelope
    connect?: Enumerable<CommunityPostWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutCommunityBoardsInput = {
    create?: XOR<UserCreateWithoutCommunityBoardsInput, UserUncheckedCreateWithoutCommunityBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityBoardsInput
    upsert?: UserUpsertWithoutCommunityBoardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommunityBoardsInput, UserUncheckedUpdateWithoutCommunityBoardsInput>
  }

  export type CommunityBoardPinUpdateManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityBoardPinCreateWithoutCommunityBoardInput>, Enumerable<CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutCommunityBoardInput>
    upsert?: Enumerable<CommunityBoardPinUpsertWithWhereUniqueWithoutCommunityBoardInput>
    createMany?: CommunityBoardPinCreateManyCommunityBoardInputEnvelope
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    set?: Enumerable<CommunityBoardPinWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    delete?: Enumerable<CommunityBoardPinWhereUniqueInput>
    update?: Enumerable<CommunityBoardPinUpdateWithWhereUniqueWithoutCommunityBoardInput>
    updateMany?: Enumerable<CommunityBoardPinUpdateManyWithWhereWithoutCommunityBoardInput>
    deleteMany?: Enumerable<CommunityBoardPinScalarWhereInput>
  }

  export type CommunityPostUpdateManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityPostCreateWithoutCommunityBoardInput>, Enumerable<CommunityPostUncheckedCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutCommunityBoardInput>
    upsert?: Enumerable<CommunityPostUpsertWithWhereUniqueWithoutCommunityBoardInput>
    createMany?: CommunityPostCreateManyCommunityBoardInputEnvelope
    connect?: Enumerable<CommunityPostWhereUniqueInput>
    set?: Enumerable<CommunityPostWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostWhereUniqueInput>
    delete?: Enumerable<CommunityPostWhereUniqueInput>
    update?: Enumerable<CommunityPostUpdateWithWhereUniqueWithoutCommunityBoardInput>
    updateMany?: Enumerable<CommunityPostUpdateManyWithWhereWithoutCommunityBoardInput>
    deleteMany?: Enumerable<CommunityPostScalarWhereInput>
  }

  export type CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityBoardPinCreateWithoutCommunityBoardInput>, Enumerable<CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutCommunityBoardInput>
    upsert?: Enumerable<CommunityBoardPinUpsertWithWhereUniqueWithoutCommunityBoardInput>
    createMany?: CommunityBoardPinCreateManyCommunityBoardInputEnvelope
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    set?: Enumerable<CommunityBoardPinWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    delete?: Enumerable<CommunityBoardPinWhereUniqueInput>
    update?: Enumerable<CommunityBoardPinUpdateWithWhereUniqueWithoutCommunityBoardInput>
    updateMany?: Enumerable<CommunityBoardPinUpdateManyWithWhereWithoutCommunityBoardInput>
    deleteMany?: Enumerable<CommunityBoardPinScalarWhereInput>
  }

  export type CommunityPostUncheckedUpdateManyWithoutCommunityBoardInput = {
    create?: XOR<Enumerable<CommunityPostCreateWithoutCommunityBoardInput>, Enumerable<CommunityPostUncheckedCreateWithoutCommunityBoardInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutCommunityBoardInput>
    upsert?: Enumerable<CommunityPostUpsertWithWhereUniqueWithoutCommunityBoardInput>
    createMany?: CommunityPostCreateManyCommunityBoardInputEnvelope
    connect?: Enumerable<CommunityPostWhereUniqueInput>
    set?: Enumerable<CommunityPostWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostWhereUniqueInput>
    delete?: Enumerable<CommunityPostWhereUniqueInput>
    update?: Enumerable<CommunityPostUpdateWithWhereUniqueWithoutCommunityBoardInput>
    updateMany?: Enumerable<CommunityPostUpdateManyWithWhereWithoutCommunityBoardInput>
    deleteMany?: Enumerable<CommunityPostScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCommunityBoardCandidatesInput = {
    create?: XOR<UserCreateWithoutCommunityBoardCandidatesInput, UserUncheckedCreateWithoutCommunityBoardCandidatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityBoardCandidatesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityBoardCandidateVoteCreateNestedManyWithoutCommunityBoardCandidateInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput>, Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutCommunityBoardCandidateInput>
    createMany?: CommunityBoardCandidateVoteCreateManyCommunityBoardCandidateInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
  }

  export type CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutCommunityBoardCandidateInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput>, Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutCommunityBoardCandidateInput>
    createMany?: CommunityBoardCandidateVoteCreateManyCommunityBoardCandidateInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityBoardCandidatesInput = {
    create?: XOR<UserCreateWithoutCommunityBoardCandidatesInput, UserUncheckedCreateWithoutCommunityBoardCandidatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityBoardCandidatesInput
    upsert?: UserUpsertWithoutCommunityBoardCandidatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommunityBoardCandidatesInput, UserUncheckedUpdateWithoutCommunityBoardCandidatesInput>
  }

  export type CommunityBoardCandidateVoteUpdateManyWithoutCommunityBoardCandidateInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput>, Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutCommunityBoardCandidateInput>
    upsert?: Enumerable<CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutCommunityBoardCandidateInput>
    createMany?: CommunityBoardCandidateVoteCreateManyCommunityBoardCandidateInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutCommunityBoardCandidateInput>
    updateMany?: Enumerable<CommunityBoardCandidateVoteUpdateManyWithWhereWithoutCommunityBoardCandidateInput>
    deleteMany?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput>, Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutCommunityBoardCandidateInput>
    upsert?: Enumerable<CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutCommunityBoardCandidateInput>
    createMany?: CommunityBoardCandidateVoteCreateManyCommunityBoardCandidateInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutCommunityBoardCandidateInput>
    updateMany?: Enumerable<CommunityBoardCandidateVoteUpdateManyWithWhereWithoutCommunityBoardCandidateInput>
    deleteMany?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
  }

  export type CommunityBoardCandidateCreateNestedOneWithoutCommunityBoardCandidateVotesInput = {
    create?: XOR<CommunityBoardCandidateCreateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateUncheckedCreateWithoutCommunityBoardCandidateVotesInput>
    connectOrCreate?: CommunityBoardCandidateCreateOrConnectWithoutCommunityBoardCandidateVotesInput
    connect?: CommunityBoardCandidateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityBoardCandidateVotesInput = {
    create?: XOR<UserCreateWithoutCommunityBoardCandidateVotesInput, UserUncheckedCreateWithoutCommunityBoardCandidateVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityBoardCandidateVotesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityBoardCandidateUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput = {
    create?: XOR<CommunityBoardCandidateCreateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateUncheckedCreateWithoutCommunityBoardCandidateVotesInput>
    connectOrCreate?: CommunityBoardCandidateCreateOrConnectWithoutCommunityBoardCandidateVotesInput
    upsert?: CommunityBoardCandidateUpsertWithoutCommunityBoardCandidateVotesInput
    connect?: CommunityBoardCandidateWhereUniqueInput
    update?: XOR<CommunityBoardCandidateUpdateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateUncheckedUpdateWithoutCommunityBoardCandidateVotesInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput = {
    create?: XOR<UserCreateWithoutCommunityBoardCandidateVotesInput, UserUncheckedCreateWithoutCommunityBoardCandidateVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityBoardCandidateVotesInput
    upsert?: UserUpsertWithoutCommunityBoardCandidateVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommunityBoardCandidateVotesInput, UserUncheckedUpdateWithoutCommunityBoardCandidateVotesInput>
  }

  export type CommunityBoardCreateNestedOneWithoutCommunityBoardPinsInput = {
    create?: XOR<CommunityBoardCreateWithoutCommunityBoardPinsInput, CommunityBoardUncheckedCreateWithoutCommunityBoardPinsInput>
    connectOrCreate?: CommunityBoardCreateOrConnectWithoutCommunityBoardPinsInput
    connect?: CommunityBoardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityBoardPinsInput = {
    create?: XOR<UserCreateWithoutCommunityBoardPinsInput, UserUncheckedCreateWithoutCommunityBoardPinsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityBoardPinsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityBoardUpdateOneRequiredWithoutCommunityBoardPinsInput = {
    create?: XOR<CommunityBoardCreateWithoutCommunityBoardPinsInput, CommunityBoardUncheckedCreateWithoutCommunityBoardPinsInput>
    connectOrCreate?: CommunityBoardCreateOrConnectWithoutCommunityBoardPinsInput
    upsert?: CommunityBoardUpsertWithoutCommunityBoardPinsInput
    connect?: CommunityBoardWhereUniqueInput
    update?: XOR<CommunityBoardUpdateWithoutCommunityBoardPinsInput, CommunityBoardUncheckedUpdateWithoutCommunityBoardPinsInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityBoardPinsInput = {
    create?: XOR<UserCreateWithoutCommunityBoardPinsInput, UserUncheckedCreateWithoutCommunityBoardPinsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityBoardPinsInput
    upsert?: UserUpsertWithoutCommunityBoardPinsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommunityBoardPinsInput, UserUncheckedUpdateWithoutCommunityBoardPinsInput>
  }

  export type CommunityPostCreateNestedOneWithoutCommunityCommentsInput = {
    create?: XOR<CommunityPostCreateWithoutCommunityCommentsInput, CommunityPostUncheckedCreateWithoutCommunityCommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunityCommentsInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityCommentsInput = {
    create?: XOR<UserCreateWithoutCommunityCommentsInput, UserUncheckedCreateWithoutCommunityCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunitySubcommentCreateNestedManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutCommunityCommentInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutCommunityCommentInput>
    createMany?: CommunitySubcommentCreateManyCommunityCommentInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type ReportCommentCreateNestedManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<ReportCommentCreateWithoutCommunityCommentInput>, Enumerable<ReportCommentUncheckedCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutCommunityCommentInput>
    createMany?: ReportCommentCreateManyCommunityCommentInputEnvelope
    connect?: Enumerable<ReportCommentWhereUniqueInput>
  }

  export type CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutCommunityCommentInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutCommunityCommentInput>
    createMany?: CommunitySubcommentCreateManyCommunityCommentInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type ReportCommentUncheckedCreateNestedManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<ReportCommentCreateWithoutCommunityCommentInput>, Enumerable<ReportCommentUncheckedCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutCommunityCommentInput>
    createMany?: ReportCommentCreateManyCommunityCommentInputEnvelope
    connect?: Enumerable<ReportCommentWhereUniqueInput>
  }

  export type CommunityPostUpdateOneRequiredWithoutCommunityCommentsInput = {
    create?: XOR<CommunityPostCreateWithoutCommunityCommentsInput, CommunityPostUncheckedCreateWithoutCommunityCommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunityCommentsInput
    upsert?: CommunityPostUpsertWithoutCommunityCommentsInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<CommunityPostUpdateWithoutCommunityCommentsInput, CommunityPostUncheckedUpdateWithoutCommunityCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityCommentsInput = {
    create?: XOR<UserCreateWithoutCommunityCommentsInput, UserUncheckedCreateWithoutCommunityCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityCommentsInput
    upsert?: UserUpsertWithoutCommunityCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommunityCommentsInput, UserUncheckedUpdateWithoutCommunityCommentsInput>
  }

  export type CommunitySubcommentUpdateManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutCommunityCommentInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutCommunityCommentInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityCommentInput>
    createMany?: CommunitySubcommentCreateManyCommunityCommentInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityCommentInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutCommunityCommentInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type ReportCommentUpdateManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<ReportCommentCreateWithoutCommunityCommentInput>, Enumerable<ReportCommentUncheckedCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutCommunityCommentInput>
    upsert?: Enumerable<ReportCommentUpsertWithWhereUniqueWithoutCommunityCommentInput>
    createMany?: ReportCommentCreateManyCommunityCommentInputEnvelope
    connect?: Enumerable<ReportCommentWhereUniqueInput>
    set?: Enumerable<ReportCommentWhereUniqueInput>
    disconnect?: Enumerable<ReportCommentWhereUniqueInput>
    delete?: Enumerable<ReportCommentWhereUniqueInput>
    update?: Enumerable<ReportCommentUpdateWithWhereUniqueWithoutCommunityCommentInput>
    updateMany?: Enumerable<ReportCommentUpdateManyWithWhereWithoutCommunityCommentInput>
    deleteMany?: Enumerable<ReportCommentScalarWhereInput>
  }

  export type CommunitySubcommentUncheckedUpdateManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutCommunityCommentInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutCommunityCommentInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityCommentInput>
    createMany?: CommunitySubcommentCreateManyCommunityCommentInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityCommentInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutCommunityCommentInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type ReportCommentUncheckedUpdateManyWithoutCommunityCommentInput = {
    create?: XOR<Enumerable<ReportCommentCreateWithoutCommunityCommentInput>, Enumerable<ReportCommentUncheckedCreateWithoutCommunityCommentInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutCommunityCommentInput>
    upsert?: Enumerable<ReportCommentUpsertWithWhereUniqueWithoutCommunityCommentInput>
    createMany?: ReportCommentCreateManyCommunityCommentInputEnvelope
    connect?: Enumerable<ReportCommentWhereUniqueInput>
    set?: Enumerable<ReportCommentWhereUniqueInput>
    disconnect?: Enumerable<ReportCommentWhereUniqueInput>
    delete?: Enumerable<ReportCommentWhereUniqueInput>
    update?: Enumerable<ReportCommentUpdateWithWhereUniqueWithoutCommunityCommentInput>
    updateMany?: Enumerable<ReportCommentUpdateManyWithWhereWithoutCommunityCommentInput>
    deleteMany?: Enumerable<ReportCommentScalarWhereInput>
  }

  export type CommunityBoardCreateNestedOneWithoutCommunityPostsInput = {
    create?: XOR<CommunityBoardCreateWithoutCommunityPostsInput, CommunityBoardUncheckedCreateWithoutCommunityPostsInput>
    connectOrCreate?: CommunityBoardCreateOrConnectWithoutCommunityPostsInput
    connect?: CommunityBoardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityPostsInput = {
    create?: XOR<UserCreateWithoutCommunityPostsInput, UserUncheckedCreateWithoutCommunityPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityPostsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityCommentCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityCommentCreateWithoutCommunityPostInput>, Enumerable<CommunityCommentUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutCommunityPostInput>
    createMany?: CommunityCommentCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
  }

  export type CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkCreateWithoutCommunityPostInput>, Enumerable<CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutCommunityPostInput>
    createMany?: CommunityPostBookmarkCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
  }

  export type CommunityPostLikeCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostLikeCreateWithoutCommunityPostInput>, Enumerable<CommunityPostLikeUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutCommunityPostInput>
    createMany?: CommunityPostLikeCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
  }

  export type CommunitySubcommentCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutCommunityPostInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutCommunityPostInput>
    createMany?: CommunitySubcommentCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type ReportPostCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<ReportPostCreateWithoutCommunityPostInput>, Enumerable<ReportPostUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutCommunityPostInput>
    createMany?: ReportPostCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<ReportPostWhereUniqueInput>
  }

  export type CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityCommentCreateWithoutCommunityPostInput>, Enumerable<CommunityCommentUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutCommunityPostInput>
    createMany?: CommunityCommentCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
  }

  export type CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkCreateWithoutCommunityPostInput>, Enumerable<CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutCommunityPostInput>
    createMany?: CommunityPostBookmarkCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
  }

  export type CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostLikeCreateWithoutCommunityPostInput>, Enumerable<CommunityPostLikeUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutCommunityPostInput>
    createMany?: CommunityPostLikeCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
  }

  export type CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutCommunityPostInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutCommunityPostInput>
    createMany?: CommunitySubcommentCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<ReportPostCreateWithoutCommunityPostInput>, Enumerable<ReportPostUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutCommunityPostInput>
    createMany?: ReportPostCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<ReportPostWhereUniqueInput>
  }

  export type CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput = {
    create?: XOR<CommunityBoardCreateWithoutCommunityPostsInput, CommunityBoardUncheckedCreateWithoutCommunityPostsInput>
    connectOrCreate?: CommunityBoardCreateOrConnectWithoutCommunityPostsInput
    upsert?: CommunityBoardUpsertWithoutCommunityPostsInput
    connect?: CommunityBoardWhereUniqueInput
    update?: XOR<CommunityBoardUpdateWithoutCommunityPostsInput, CommunityBoardUncheckedUpdateWithoutCommunityPostsInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityPostsInput = {
    create?: XOR<UserCreateWithoutCommunityPostsInput, UserUncheckedCreateWithoutCommunityPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityPostsInput
    upsert?: UserUpsertWithoutCommunityPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommunityPostsInput, UserUncheckedUpdateWithoutCommunityPostsInput>
  }

  export type CommunityCommentUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityCommentCreateWithoutCommunityPostInput>, Enumerable<CommunityCommentUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutCommunityPostInput>
    upsert?: Enumerable<CommunityCommentUpsertWithWhereUniqueWithoutCommunityPostInput>
    createMany?: CommunityCommentCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
    set?: Enumerable<CommunityCommentWhereUniqueInput>
    disconnect?: Enumerable<CommunityCommentWhereUniqueInput>
    delete?: Enumerable<CommunityCommentWhereUniqueInput>
    update?: Enumerable<CommunityCommentUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityCommentUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityCommentScalarWhereInput>
  }

  export type CommunityPostBookmarkUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkCreateWithoutCommunityPostInput>, Enumerable<CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutCommunityPostInput>
    upsert?: Enumerable<CommunityPostBookmarkUpsertWithWhereUniqueWithoutCommunityPostInput>
    createMany?: CommunityPostBookmarkCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    set?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    delete?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    update?: Enumerable<CommunityPostBookmarkUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityPostBookmarkUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityPostBookmarkScalarWhereInput>
  }

  export type CommunityPostLikeUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostLikeCreateWithoutCommunityPostInput>, Enumerable<CommunityPostLikeUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutCommunityPostInput>
    upsert?: Enumerable<CommunityPostLikeUpsertWithWhereUniqueWithoutCommunityPostInput>
    createMany?: CommunityPostLikeCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    set?: Enumerable<CommunityPostLikeWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    delete?: Enumerable<CommunityPostLikeWhereUniqueInput>
    update?: Enumerable<CommunityPostLikeUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityPostLikeUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityPostLikeScalarWhereInput>
  }

  export type CommunitySubcommentUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutCommunityPostInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutCommunityPostInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityPostInput>
    createMany?: CommunitySubcommentCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type ReportPostUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<ReportPostCreateWithoutCommunityPostInput>, Enumerable<ReportPostUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutCommunityPostInput>
    upsert?: Enumerable<ReportPostUpsertWithWhereUniqueWithoutCommunityPostInput>
    createMany?: ReportPostCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<ReportPostWhereUniqueInput>
    set?: Enumerable<ReportPostWhereUniqueInput>
    disconnect?: Enumerable<ReportPostWhereUniqueInput>
    delete?: Enumerable<ReportPostWhereUniqueInput>
    update?: Enumerable<ReportPostUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<ReportPostUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<ReportPostScalarWhereInput>
  }

  export type CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityCommentCreateWithoutCommunityPostInput>, Enumerable<CommunityCommentUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutCommunityPostInput>
    upsert?: Enumerable<CommunityCommentUpsertWithWhereUniqueWithoutCommunityPostInput>
    createMany?: CommunityCommentCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
    set?: Enumerable<CommunityCommentWhereUniqueInput>
    disconnect?: Enumerable<CommunityCommentWhereUniqueInput>
    delete?: Enumerable<CommunityCommentWhereUniqueInput>
    update?: Enumerable<CommunityCommentUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityCommentUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityCommentScalarWhereInput>
  }

  export type CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkCreateWithoutCommunityPostInput>, Enumerable<CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutCommunityPostInput>
    upsert?: Enumerable<CommunityPostBookmarkUpsertWithWhereUniqueWithoutCommunityPostInput>
    createMany?: CommunityPostBookmarkCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    set?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    delete?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    update?: Enumerable<CommunityPostBookmarkUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityPostBookmarkUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityPostBookmarkScalarWhereInput>
  }

  export type CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunityPostLikeCreateWithoutCommunityPostInput>, Enumerable<CommunityPostLikeUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutCommunityPostInput>
    upsert?: Enumerable<CommunityPostLikeUpsertWithWhereUniqueWithoutCommunityPostInput>
    createMany?: CommunityPostLikeCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    set?: Enumerable<CommunityPostLikeWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    delete?: Enumerable<CommunityPostLikeWhereUniqueInput>
    update?: Enumerable<CommunityPostLikeUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunityPostLikeUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunityPostLikeScalarWhereInput>
  }

  export type CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutCommunityPostInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutCommunityPostInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityPostInput>
    createMany?: CommunitySubcommentCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type ReportPostUncheckedUpdateManyWithoutCommunityPostInput = {
    create?: XOR<Enumerable<ReportPostCreateWithoutCommunityPostInput>, Enumerable<ReportPostUncheckedCreateWithoutCommunityPostInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutCommunityPostInput>
    upsert?: Enumerable<ReportPostUpsertWithWhereUniqueWithoutCommunityPostInput>
    createMany?: ReportPostCreateManyCommunityPostInputEnvelope
    connect?: Enumerable<ReportPostWhereUniqueInput>
    set?: Enumerable<ReportPostWhereUniqueInput>
    disconnect?: Enumerable<ReportPostWhereUniqueInput>
    delete?: Enumerable<ReportPostWhereUniqueInput>
    update?: Enumerable<ReportPostUpdateWithWhereUniqueWithoutCommunityPostInput>
    updateMany?: Enumerable<ReportPostUpdateManyWithWhereWithoutCommunityPostInput>
    deleteMany?: Enumerable<ReportPostScalarWhereInput>
  }

  export type CommunityPostCreateNestedOneWithoutCommunityPostBookmarksInput = {
    create?: XOR<CommunityPostCreateWithoutCommunityPostBookmarksInput, CommunityPostUncheckedCreateWithoutCommunityPostBookmarksInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunityPostBookmarksInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityPostBookmarksInput = {
    create?: XOR<UserCreateWithoutCommunityPostBookmarksInput, UserUncheckedCreateWithoutCommunityPostBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityPostBookmarksInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityPostUpdateOneRequiredWithoutCommunityPostBookmarksInput = {
    create?: XOR<CommunityPostCreateWithoutCommunityPostBookmarksInput, CommunityPostUncheckedCreateWithoutCommunityPostBookmarksInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunityPostBookmarksInput
    upsert?: CommunityPostUpsertWithoutCommunityPostBookmarksInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<CommunityPostUpdateWithoutCommunityPostBookmarksInput, CommunityPostUncheckedUpdateWithoutCommunityPostBookmarksInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityPostBookmarksInput = {
    create?: XOR<UserCreateWithoutCommunityPostBookmarksInput, UserUncheckedCreateWithoutCommunityPostBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityPostBookmarksInput
    upsert?: UserUpsertWithoutCommunityPostBookmarksInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommunityPostBookmarksInput, UserUncheckedUpdateWithoutCommunityPostBookmarksInput>
  }

  export type CommunityPostCreateNestedOneWithoutCommunityPostLikesInput = {
    create?: XOR<CommunityPostCreateWithoutCommunityPostLikesInput, CommunityPostUncheckedCreateWithoutCommunityPostLikesInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunityPostLikesInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityPostLikesInput = {
    create?: XOR<UserCreateWithoutCommunityPostLikesInput, UserUncheckedCreateWithoutCommunityPostLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityPostLikesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityPostUpdateOneRequiredWithoutCommunityPostLikesInput = {
    create?: XOR<CommunityPostCreateWithoutCommunityPostLikesInput, CommunityPostUncheckedCreateWithoutCommunityPostLikesInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunityPostLikesInput
    upsert?: CommunityPostUpsertWithoutCommunityPostLikesInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<CommunityPostUpdateWithoutCommunityPostLikesInput, CommunityPostUncheckedUpdateWithoutCommunityPostLikesInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityPostLikesInput = {
    create?: XOR<UserCreateWithoutCommunityPostLikesInput, UserUncheckedCreateWithoutCommunityPostLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityPostLikesInput
    upsert?: UserUpsertWithoutCommunityPostLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommunityPostLikesInput, UserUncheckedUpdateWithoutCommunityPostLikesInput>
  }

  export type CommunityCommentCreateNestedOneWithoutCommunitySubcommentsInput = {
    create?: XOR<CommunityCommentCreateWithoutCommunitySubcommentsInput, CommunityCommentUncheckedCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutCommunitySubcommentsInput
    connect?: CommunityCommentWhereUniqueInput
  }

  export type CommunityPostCreateNestedOneWithoutCommunitySubcommentsInput = {
    create?: XOR<CommunityPostCreateWithoutCommunitySubcommentsInput, CommunityPostUncheckedCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunitySubcommentsInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunitySubcommentsInput = {
    create?: XOR<UserCreateWithoutCommunitySubcommentsInput, UserUncheckedCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunitySubcommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ReportSubcommentCreateNestedManyWithoutCommunitySubcommentInput = {
    create?: XOR<Enumerable<ReportSubcommentCreateWithoutCommunitySubcommentInput>, Enumerable<ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutCommunitySubcommentInput>
    createMany?: ReportSubcommentCreateManyCommunitySubcommentInputEnvelope
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
  }

  export type ReportSubcommentUncheckedCreateNestedManyWithoutCommunitySubcommentInput = {
    create?: XOR<Enumerable<ReportSubcommentCreateWithoutCommunitySubcommentInput>, Enumerable<ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutCommunitySubcommentInput>
    createMany?: ReportSubcommentCreateManyCommunitySubcommentInputEnvelope
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
  }

  export type CommunityCommentUpdateOneRequiredWithoutCommunitySubcommentsInput = {
    create?: XOR<CommunityCommentCreateWithoutCommunitySubcommentsInput, CommunityCommentUncheckedCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutCommunitySubcommentsInput
    upsert?: CommunityCommentUpsertWithoutCommunitySubcommentsInput
    connect?: CommunityCommentWhereUniqueInput
    update?: XOR<CommunityCommentUpdateWithoutCommunitySubcommentsInput, CommunityCommentUncheckedUpdateWithoutCommunitySubcommentsInput>
  }

  export type CommunityPostUpdateOneRequiredWithoutCommunitySubcommentsInput = {
    create?: XOR<CommunityPostCreateWithoutCommunitySubcommentsInput, CommunityPostUncheckedCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunitySubcommentsInput
    upsert?: CommunityPostUpsertWithoutCommunitySubcommentsInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<CommunityPostUpdateWithoutCommunitySubcommentsInput, CommunityPostUncheckedUpdateWithoutCommunitySubcommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommunitySubcommentsInput = {
    create?: XOR<UserCreateWithoutCommunitySubcommentsInput, UserUncheckedCreateWithoutCommunitySubcommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunitySubcommentsInput
    upsert?: UserUpsertWithoutCommunitySubcommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommunitySubcommentsInput, UserUncheckedUpdateWithoutCommunitySubcommentsInput>
  }

  export type ReportSubcommentUpdateManyWithoutCommunitySubcommentInput = {
    create?: XOR<Enumerable<ReportSubcommentCreateWithoutCommunitySubcommentInput>, Enumerable<ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutCommunitySubcommentInput>
    upsert?: Enumerable<ReportSubcommentUpsertWithWhereUniqueWithoutCommunitySubcommentInput>
    createMany?: ReportSubcommentCreateManyCommunitySubcommentInputEnvelope
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
    set?: Enumerable<ReportSubcommentWhereUniqueInput>
    disconnect?: Enumerable<ReportSubcommentWhereUniqueInput>
    delete?: Enumerable<ReportSubcommentWhereUniqueInput>
    update?: Enumerable<ReportSubcommentUpdateWithWhereUniqueWithoutCommunitySubcommentInput>
    updateMany?: Enumerable<ReportSubcommentUpdateManyWithWhereWithoutCommunitySubcommentInput>
    deleteMany?: Enumerable<ReportSubcommentScalarWhereInput>
  }

  export type ReportSubcommentUncheckedUpdateManyWithoutCommunitySubcommentInput = {
    create?: XOR<Enumerable<ReportSubcommentCreateWithoutCommunitySubcommentInput>, Enumerable<ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutCommunitySubcommentInput>
    upsert?: Enumerable<ReportSubcommentUpsertWithWhereUniqueWithoutCommunitySubcommentInput>
    createMany?: ReportSubcommentCreateManyCommunitySubcommentInputEnvelope
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
    set?: Enumerable<ReportSubcommentWhereUniqueInput>
    disconnect?: Enumerable<ReportSubcommentWhereUniqueInput>
    delete?: Enumerable<ReportSubcommentWhereUniqueInput>
    update?: Enumerable<ReportSubcommentUpdateWithWhereUniqueWithoutCommunitySubcommentInput>
    updateMany?: Enumerable<ReportSubcommentUpdateManyWithWhereWithoutCommunitySubcommentInput>
    deleteMany?: Enumerable<ReportSubcommentScalarWhereInput>
  }

  export type CoverageMajorLectureCreateNestedManyWithoutCoverageMajorInput = {
    create?: XOR<Enumerable<CoverageMajorLectureCreateWithoutCoverageMajorInput>, Enumerable<CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutCoverageMajorInput>
    createMany?: CoverageMajorLectureCreateManyCoverageMajorInputEnvelope
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
  }

  export type CoverageMajorLectureUncheckedCreateNestedManyWithoutCoverageMajorInput = {
    create?: XOR<Enumerable<CoverageMajorLectureCreateWithoutCoverageMajorInput>, Enumerable<CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutCoverageMajorInput>
    createMany?: CoverageMajorLectureCreateManyCoverageMajorInputEnvelope
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
  }

  export type CoverageMajorLectureUpdateManyWithoutCoverageMajorInput = {
    create?: XOR<Enumerable<CoverageMajorLectureCreateWithoutCoverageMajorInput>, Enumerable<CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutCoverageMajorInput>
    upsert?: Enumerable<CoverageMajorLectureUpsertWithWhereUniqueWithoutCoverageMajorInput>
    createMany?: CoverageMajorLectureCreateManyCoverageMajorInputEnvelope
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    set?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    disconnect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    delete?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    update?: Enumerable<CoverageMajorLectureUpdateWithWhereUniqueWithoutCoverageMajorInput>
    updateMany?: Enumerable<CoverageMajorLectureUpdateManyWithWhereWithoutCoverageMajorInput>
    deleteMany?: Enumerable<CoverageMajorLectureScalarWhereInput>
  }

  export type CoverageMajorLectureUncheckedUpdateManyWithoutCoverageMajorInput = {
    create?: XOR<Enumerable<CoverageMajorLectureCreateWithoutCoverageMajorInput>, Enumerable<CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutCoverageMajorInput>
    upsert?: Enumerable<CoverageMajorLectureUpsertWithWhereUniqueWithoutCoverageMajorInput>
    createMany?: CoverageMajorLectureCreateManyCoverageMajorInputEnvelope
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    set?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    disconnect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    delete?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    update?: Enumerable<CoverageMajorLectureUpdateWithWhereUniqueWithoutCoverageMajorInput>
    updateMany?: Enumerable<CoverageMajorLectureUpdateManyWithWhereWithoutCoverageMajorInput>
    deleteMany?: Enumerable<CoverageMajorLectureScalarWhereInput>
  }

  export type LectureCreateNestedOneWithoutCoverageMajorLecturesInput = {
    create?: XOR<LectureCreateWithoutCoverageMajorLecturesInput, LectureUncheckedCreateWithoutCoverageMajorLecturesInput>
    connectOrCreate?: LectureCreateOrConnectWithoutCoverageMajorLecturesInput
    connect?: LectureWhereUniqueInput
  }

  export type CoverageMajorCreateNestedOneWithoutCoverageMajorLecturesInput = {
    create?: XOR<CoverageMajorCreateWithoutCoverageMajorLecturesInput, CoverageMajorUncheckedCreateWithoutCoverageMajorLecturesInput>
    connectOrCreate?: CoverageMajorCreateOrConnectWithoutCoverageMajorLecturesInput
    connect?: CoverageMajorWhereUniqueInput
  }

  export type LectureUpdateOneRequiredWithoutCoverageMajorLecturesInput = {
    create?: XOR<LectureCreateWithoutCoverageMajorLecturesInput, LectureUncheckedCreateWithoutCoverageMajorLecturesInput>
    connectOrCreate?: LectureCreateOrConnectWithoutCoverageMajorLecturesInput
    upsert?: LectureUpsertWithoutCoverageMajorLecturesInput
    connect?: LectureWhereUniqueInput
    update?: XOR<LectureUpdateWithoutCoverageMajorLecturesInput, LectureUncheckedUpdateWithoutCoverageMajorLecturesInput>
  }

  export type CoverageMajorUpdateOneRequiredWithoutCoverageMajorLecturesInput = {
    create?: XOR<CoverageMajorCreateWithoutCoverageMajorLecturesInput, CoverageMajorUncheckedCreateWithoutCoverageMajorLecturesInput>
    connectOrCreate?: CoverageMajorCreateOrConnectWithoutCoverageMajorLecturesInput
    upsert?: CoverageMajorUpsertWithoutCoverageMajorLecturesInput
    connect?: CoverageMajorWhereUniqueInput
    update?: XOR<CoverageMajorUpdateWithoutCoverageMajorLecturesInput, CoverageMajorUncheckedUpdateWithoutCoverageMajorLecturesInput>
  }

  export type CoverageMajorLectureCreateNestedManyWithoutLectureInput = {
    create?: XOR<Enumerable<CoverageMajorLectureCreateWithoutLectureInput>, Enumerable<CoverageMajorLectureUncheckedCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutLectureInput>
    createMany?: CoverageMajorLectureCreateManyLectureInputEnvelope
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
  }

  export type PeriodCreateNestedManyWithoutLectureInput = {
    create?: XOR<Enumerable<PeriodCreateWithoutLectureInput>, Enumerable<PeriodUncheckedCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<PeriodCreateOrConnectWithoutLectureInput>
    createMany?: PeriodCreateManyLectureInputEnvelope
    connect?: Enumerable<PeriodWhereUniqueInput>
  }

  export type CoverageMajorLectureUncheckedCreateNestedManyWithoutLectureInput = {
    create?: XOR<Enumerable<CoverageMajorLectureCreateWithoutLectureInput>, Enumerable<CoverageMajorLectureUncheckedCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutLectureInput>
    createMany?: CoverageMajorLectureCreateManyLectureInputEnvelope
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
  }

  export type PeriodUncheckedCreateNestedManyWithoutLectureInput = {
    create?: XOR<Enumerable<PeriodCreateWithoutLectureInput>, Enumerable<PeriodUncheckedCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<PeriodCreateOrConnectWithoutLectureInput>
    createMany?: PeriodCreateManyLectureInputEnvelope
    connect?: Enumerable<PeriodWhereUniqueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CoverageMajorLectureUpdateManyWithoutLectureInput = {
    create?: XOR<Enumerable<CoverageMajorLectureCreateWithoutLectureInput>, Enumerable<CoverageMajorLectureUncheckedCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutLectureInput>
    upsert?: Enumerable<CoverageMajorLectureUpsertWithWhereUniqueWithoutLectureInput>
    createMany?: CoverageMajorLectureCreateManyLectureInputEnvelope
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    set?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    disconnect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    delete?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    update?: Enumerable<CoverageMajorLectureUpdateWithWhereUniqueWithoutLectureInput>
    updateMany?: Enumerable<CoverageMajorLectureUpdateManyWithWhereWithoutLectureInput>
    deleteMany?: Enumerable<CoverageMajorLectureScalarWhereInput>
  }

  export type PeriodUpdateManyWithoutLectureInput = {
    create?: XOR<Enumerable<PeriodCreateWithoutLectureInput>, Enumerable<PeriodUncheckedCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<PeriodCreateOrConnectWithoutLectureInput>
    upsert?: Enumerable<PeriodUpsertWithWhereUniqueWithoutLectureInput>
    createMany?: PeriodCreateManyLectureInputEnvelope
    connect?: Enumerable<PeriodWhereUniqueInput>
    set?: Enumerable<PeriodWhereUniqueInput>
    disconnect?: Enumerable<PeriodWhereUniqueInput>
    delete?: Enumerable<PeriodWhereUniqueInput>
    update?: Enumerable<PeriodUpdateWithWhereUniqueWithoutLectureInput>
    updateMany?: Enumerable<PeriodUpdateManyWithWhereWithoutLectureInput>
    deleteMany?: Enumerable<PeriodScalarWhereInput>
  }

  export type CoverageMajorLectureUncheckedUpdateManyWithoutLectureInput = {
    create?: XOR<Enumerable<CoverageMajorLectureCreateWithoutLectureInput>, Enumerable<CoverageMajorLectureUncheckedCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<CoverageMajorLectureCreateOrConnectWithoutLectureInput>
    upsert?: Enumerable<CoverageMajorLectureUpsertWithWhereUniqueWithoutLectureInput>
    createMany?: CoverageMajorLectureCreateManyLectureInputEnvelope
    connect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    set?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    disconnect?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    delete?: Enumerable<CoverageMajorLectureWhereUniqueInput>
    update?: Enumerable<CoverageMajorLectureUpdateWithWhereUniqueWithoutLectureInput>
    updateMany?: Enumerable<CoverageMajorLectureUpdateManyWithWhereWithoutLectureInput>
    deleteMany?: Enumerable<CoverageMajorLectureScalarWhereInput>
  }

  export type PeriodUncheckedUpdateManyWithoutLectureInput = {
    create?: XOR<Enumerable<PeriodCreateWithoutLectureInput>, Enumerable<PeriodUncheckedCreateWithoutLectureInput>>
    connectOrCreate?: Enumerable<PeriodCreateOrConnectWithoutLectureInput>
    upsert?: Enumerable<PeriodUpsertWithWhereUniqueWithoutLectureInput>
    createMany?: PeriodCreateManyLectureInputEnvelope
    connect?: Enumerable<PeriodWhereUniqueInput>
    set?: Enumerable<PeriodWhereUniqueInput>
    disconnect?: Enumerable<PeriodWhereUniqueInput>
    delete?: Enumerable<PeriodWhereUniqueInput>
    update?: Enumerable<PeriodUpdateWithWhereUniqueWithoutLectureInput>
    updateMany?: Enumerable<PeriodUpdateManyWithWhereWithoutLectureInput>
    deleteMany?: Enumerable<PeriodScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutLiveChatsInput = {
    create?: XOR<UserCreateWithoutLiveChatsInput, UserUncheckedCreateWithoutLiveChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLiveChatsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLiveChatsInput = {
    create?: XOR<UserCreateWithoutLiveChatsInput, UserUncheckedCreateWithoutLiveChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLiveChatsInput
    upsert?: UserUpsertWithoutLiveChatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLiveChatsInput, UserUncheckedUpdateWithoutLiveChatsInput>
  }

  export type UserCreateNestedOneWithoutNoticeNotificationsSubscriptionsInput = {
    create?: XOR<UserCreateWithoutNoticeNotificationsSubscriptionsInput, UserUncheckedCreateWithoutNoticeNotificationsSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoticeNotificationsSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNoticeNotificationsSubscriptionsInput = {
    create?: XOR<UserCreateWithoutNoticeNotificationsSubscriptionsInput, UserUncheckedCreateWithoutNoticeNotificationsSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoticeNotificationsSubscriptionsInput
    upsert?: UserUpsertWithoutNoticeNotificationsSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutNoticeNotificationsSubscriptionsInput, UserUncheckedUpdateWithoutNoticeNotificationsSubscriptionsInput>
  }

  export type LectureCreateNestedOneWithoutPeriodsInput = {
    create?: XOR<LectureCreateWithoutPeriodsInput, LectureUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: LectureCreateOrConnectWithoutPeriodsInput
    connect?: LectureWhereUniqueInput
  }

  export type LectureUpdateOneRequiredWithoutPeriodsInput = {
    create?: XOR<LectureCreateWithoutPeriodsInput, LectureUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: LectureCreateOrConnectWithoutPeriodsInput
    upsert?: LectureUpsertWithoutPeriodsInput
    connect?: LectureWhereUniqueInput
    update?: XOR<LectureUpdateWithoutPeriodsInput, LectureUncheckedUpdateWithoutPeriodsInput>
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type ChangePasswordCreateNestedOneWithoutUserInput = {
    create?: XOR<ChangePasswordCreateWithoutUserInput, ChangePasswordUncheckedCreateWithoutUserInput>
    connectOrCreate?: ChangePasswordCreateOrConnectWithoutUserInput
    connect?: ChangePasswordWhereUniqueInput
  }

  export type CommunityBoardCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCreateWithoutUserInput>, Enumerable<CommunityBoardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCreateOrConnectWithoutUserInput>
    createMany?: CommunityBoardCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardWhereUniqueInput>
  }

  export type CommunityBoardCandidateCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateCreateOrConnectWithoutUserInput>
    createMany?: CommunityBoardCandidateCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
  }

  export type CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutUserInput>
    createMany?: CommunityBoardCandidateVoteCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
  }

  export type CommunityBoardPinCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardPinCreateWithoutUserInput>, Enumerable<CommunityBoardPinUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutUserInput>
    createMany?: CommunityBoardPinCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
  }

  export type CommunityCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityCommentCreateWithoutUserInput>, Enumerable<CommunityCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutUserInput>
    createMany?: CommunityCommentCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
  }

  export type CommunityPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostCreateWithoutUserInput>, Enumerable<CommunityPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutUserInput>
    createMany?: CommunityPostCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostWhereUniqueInput>
  }

  export type CommunityPostBookmarkCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkCreateWithoutUserInput>, Enumerable<CommunityPostBookmarkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutUserInput>
    createMany?: CommunityPostBookmarkCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
  }

  export type CommunityPostLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostLikeCreateWithoutUserInput>, Enumerable<CommunityPostLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutUserInput>
    createMany?: CommunityPostLikeCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
  }

  export type CommunitySubcommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutUserInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutUserInput>
    createMany?: CommunitySubcommentCreateManyUserInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type LiveChatCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LiveChatCreateWithoutUserInput>, Enumerable<LiveChatUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LiveChatCreateOrConnectWithoutUserInput>
    createMany?: LiveChatCreateManyUserInputEnvelope
    connect?: Enumerable<LiveChatWhereUniqueInput>
  }

  export type NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NoticeNotificationsSubscriptionCreateWithoutUserInput>, Enumerable<NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeNotificationsSubscriptionCreateOrConnectWithoutUserInput>
    createMany?: NoticeNotificationsSubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
  }

  export type ReportCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportCommentCreateWithoutUserInput>, Enumerable<ReportCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutUserInput>
    createMany?: ReportCommentCreateManyUserInputEnvelope
    connect?: Enumerable<ReportCommentWhereUniqueInput>
  }

  export type ReportPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportPostCreateWithoutUserInput>, Enumerable<ReportPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutUserInput>
    createMany?: ReportPostCreateManyUserInputEnvelope
    connect?: Enumerable<ReportPostWhereUniqueInput>
  }

  export type ReportSubcommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportSubcommentCreateWithoutUserInput>, Enumerable<ReportSubcommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutUserInput>
    createMany?: ReportSubcommentCreateManyUserInputEnvelope
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
  }

  export type TelegramCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TelegramCreateWithoutUserInput>, Enumerable<TelegramUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TelegramCreateOrConnectWithoutUserInput>
    createMany?: TelegramCreateManyUserInputEnvelope
    connect?: Enumerable<TelegramWhereUniqueInput>
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type ChangePasswordUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ChangePasswordCreateWithoutUserInput, ChangePasswordUncheckedCreateWithoutUserInput>
    connectOrCreate?: ChangePasswordCreateOrConnectWithoutUserInput
    connect?: ChangePasswordWhereUniqueInput
  }

  export type CommunityBoardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCreateWithoutUserInput>, Enumerable<CommunityBoardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCreateOrConnectWithoutUserInput>
    createMany?: CommunityBoardCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardWhereUniqueInput>
  }

  export type CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateCreateOrConnectWithoutUserInput>
    createMany?: CommunityBoardCandidateCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
  }

  export type CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutUserInput>
    createMany?: CommunityBoardCandidateVoteCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
  }

  export type CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardPinCreateWithoutUserInput>, Enumerable<CommunityBoardPinUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutUserInput>
    createMany?: CommunityBoardPinCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
  }

  export type CommunityCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityCommentCreateWithoutUserInput>, Enumerable<CommunityCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutUserInput>
    createMany?: CommunityCommentCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
  }

  export type CommunityPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostCreateWithoutUserInput>, Enumerable<CommunityPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutUserInput>
    createMany?: CommunityPostCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostWhereUniqueInput>
  }

  export type CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkCreateWithoutUserInput>, Enumerable<CommunityPostBookmarkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutUserInput>
    createMany?: CommunityPostBookmarkCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
  }

  export type CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostLikeCreateWithoutUserInput>, Enumerable<CommunityPostLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutUserInput>
    createMany?: CommunityPostLikeCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
  }

  export type CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutUserInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutUserInput>
    createMany?: CommunitySubcommentCreateManyUserInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
  }

  export type LiveChatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LiveChatCreateWithoutUserInput>, Enumerable<LiveChatUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LiveChatCreateOrConnectWithoutUserInput>
    createMany?: LiveChatCreateManyUserInputEnvelope
    connect?: Enumerable<LiveChatWhereUniqueInput>
  }

  export type NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NoticeNotificationsSubscriptionCreateWithoutUserInput>, Enumerable<NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeNotificationsSubscriptionCreateOrConnectWithoutUserInput>
    createMany?: NoticeNotificationsSubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
  }

  export type ReportCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportCommentCreateWithoutUserInput>, Enumerable<ReportCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutUserInput>
    createMany?: ReportCommentCreateManyUserInputEnvelope
    connect?: Enumerable<ReportCommentWhereUniqueInput>
  }

  export type ReportPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportPostCreateWithoutUserInput>, Enumerable<ReportPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutUserInput>
    createMany?: ReportPostCreateManyUserInputEnvelope
    connect?: Enumerable<ReportPostWhereUniqueInput>
  }

  export type ReportSubcommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportSubcommentCreateWithoutUserInput>, Enumerable<ReportSubcommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutUserInput>
    createMany?: ReportSubcommentCreateManyUserInputEnvelope
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
  }

  export type TelegramUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TelegramCreateWithoutUserInput>, Enumerable<TelegramUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TelegramCreateOrConnectWithoutUserInput>
    createMany?: TelegramCreateManyUserInputEnvelope
    connect?: Enumerable<TelegramWhereUniqueInput>
  }

  export type AdminUpdateOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type ChangePasswordUpdateOneWithoutUserInput = {
    create?: XOR<ChangePasswordCreateWithoutUserInput, ChangePasswordUncheckedCreateWithoutUserInput>
    connectOrCreate?: ChangePasswordCreateOrConnectWithoutUserInput
    upsert?: ChangePasswordUpsertWithoutUserInput
    connect?: ChangePasswordWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ChangePasswordUpdateWithoutUserInput, ChangePasswordUncheckedUpdateWithoutUserInput>
  }

  export type CommunityBoardUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCreateWithoutUserInput>, Enumerable<CommunityBoardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityBoardUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityBoardCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardWhereUniqueInput>
    set?: Enumerable<CommunityBoardWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardWhereUniqueInput>
    delete?: Enumerable<CommunityBoardWhereUniqueInput>
    update?: Enumerable<CommunityBoardUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardScalarWhereInput>
  }

  export type CommunityBoardCandidateUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityBoardCandidateUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityBoardCandidateCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardCandidateUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardCandidateScalarWhereInput>
  }

  export type CommunityBoardCandidateVoteUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityBoardCandidateVoteCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardCandidateVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
  }

  export type CommunityBoardPinUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardPinCreateWithoutUserInput>, Enumerable<CommunityBoardPinUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityBoardPinUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityBoardPinCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    set?: Enumerable<CommunityBoardPinWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    delete?: Enumerable<CommunityBoardPinWhereUniqueInput>
    update?: Enumerable<CommunityBoardPinUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardPinUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardPinScalarWhereInput>
  }

  export type CommunityCommentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityCommentCreateWithoutUserInput>, Enumerable<CommunityCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityCommentCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
    set?: Enumerable<CommunityCommentWhereUniqueInput>
    disconnect?: Enumerable<CommunityCommentWhereUniqueInput>
    delete?: Enumerable<CommunityCommentWhereUniqueInput>
    update?: Enumerable<CommunityCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityCommentScalarWhereInput>
  }

  export type CommunityPostUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostCreateWithoutUserInput>, Enumerable<CommunityPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityPostCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostWhereUniqueInput>
    set?: Enumerable<CommunityPostWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostWhereUniqueInput>
    delete?: Enumerable<CommunityPostWhereUniqueInput>
    update?: Enumerable<CommunityPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostScalarWhereInput>
  }

  export type CommunityPostBookmarkUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkCreateWithoutUserInput>, Enumerable<CommunityPostBookmarkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityPostBookmarkUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityPostBookmarkCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    set?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    delete?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    update?: Enumerable<CommunityPostBookmarkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostBookmarkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostBookmarkScalarWhereInput>
  }

  export type CommunityPostLikeUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostLikeCreateWithoutUserInput>, Enumerable<CommunityPostLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityPostLikeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityPostLikeCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    set?: Enumerable<CommunityPostLikeWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    delete?: Enumerable<CommunityPostLikeWhereUniqueInput>
    update?: Enumerable<CommunityPostLikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostLikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostLikeScalarWhereInput>
  }

  export type CommunitySubcommentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutUserInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunitySubcommentCreateManyUserInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type LiveChatUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<LiveChatCreateWithoutUserInput>, Enumerable<LiveChatUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LiveChatCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LiveChatUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LiveChatCreateManyUserInputEnvelope
    connect?: Enumerable<LiveChatWhereUniqueInput>
    set?: Enumerable<LiveChatWhereUniqueInput>
    disconnect?: Enumerable<LiveChatWhereUniqueInput>
    delete?: Enumerable<LiveChatWhereUniqueInput>
    update?: Enumerable<LiveChatUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LiveChatUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LiveChatScalarWhereInput>
  }

  export type NoticeNotificationsSubscriptionUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NoticeNotificationsSubscriptionCreateWithoutUserInput>, Enumerable<NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeNotificationsSubscriptionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NoticeNotificationsSubscriptionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NoticeNotificationsSubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    set?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    disconnect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    delete?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    update?: Enumerable<NoticeNotificationsSubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NoticeNotificationsSubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NoticeNotificationsSubscriptionScalarWhereInput>
  }

  export type ReportCommentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportCommentCreateWithoutUserInput>, Enumerable<ReportCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReportCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReportCommentCreateManyUserInputEnvelope
    connect?: Enumerable<ReportCommentWhereUniqueInput>
    set?: Enumerable<ReportCommentWhereUniqueInput>
    disconnect?: Enumerable<ReportCommentWhereUniqueInput>
    delete?: Enumerable<ReportCommentWhereUniqueInput>
    update?: Enumerable<ReportCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportCommentScalarWhereInput>
  }

  export type ReportPostUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportPostCreateWithoutUserInput>, Enumerable<ReportPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReportPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReportPostCreateManyUserInputEnvelope
    connect?: Enumerable<ReportPostWhereUniqueInput>
    set?: Enumerable<ReportPostWhereUniqueInput>
    disconnect?: Enumerable<ReportPostWhereUniqueInput>
    delete?: Enumerable<ReportPostWhereUniqueInput>
    update?: Enumerable<ReportPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportPostScalarWhereInput>
  }

  export type ReportSubcommentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportSubcommentCreateWithoutUserInput>, Enumerable<ReportSubcommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReportSubcommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReportSubcommentCreateManyUserInputEnvelope
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
    set?: Enumerable<ReportSubcommentWhereUniqueInput>
    disconnect?: Enumerable<ReportSubcommentWhereUniqueInput>
    delete?: Enumerable<ReportSubcommentWhereUniqueInput>
    update?: Enumerable<ReportSubcommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportSubcommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportSubcommentScalarWhereInput>
  }

  export type TelegramUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TelegramCreateWithoutUserInput>, Enumerable<TelegramUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TelegramCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TelegramUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TelegramCreateManyUserInputEnvelope
    connect?: Enumerable<TelegramWhereUniqueInput>
    set?: Enumerable<TelegramWhereUniqueInput>
    disconnect?: Enumerable<TelegramWhereUniqueInput>
    delete?: Enumerable<TelegramWhereUniqueInput>
    update?: Enumerable<TelegramUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TelegramUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TelegramScalarWhereInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type ChangePasswordUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<ChangePasswordCreateWithoutUserInput, ChangePasswordUncheckedCreateWithoutUserInput>
    connectOrCreate?: ChangePasswordCreateOrConnectWithoutUserInput
    upsert?: ChangePasswordUpsertWithoutUserInput
    connect?: ChangePasswordWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ChangePasswordUpdateWithoutUserInput, ChangePasswordUncheckedUpdateWithoutUserInput>
  }

  export type CommunityBoardUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCreateWithoutUserInput>, Enumerable<CommunityBoardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityBoardUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityBoardCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardWhereUniqueInput>
    set?: Enumerable<CommunityBoardWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardWhereUniqueInput>
    delete?: Enumerable<CommunityBoardWhereUniqueInput>
    update?: Enumerable<CommunityBoardUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardScalarWhereInput>
  }

  export type CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityBoardCandidateUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityBoardCandidateCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardCandidateUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardCandidateScalarWhereInput>
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardCandidateVoteCreateWithoutUserInput>, Enumerable<CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardCandidateVoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityBoardCandidateVoteCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    set?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    delete?: Enumerable<CommunityBoardCandidateVoteWhereUniqueInput>
    update?: Enumerable<CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardCandidateVoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
  }

  export type CommunityBoardPinUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityBoardPinCreateWithoutUserInput>, Enumerable<CommunityBoardPinUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityBoardPinCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityBoardPinUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityBoardPinCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    set?: Enumerable<CommunityBoardPinWhereUniqueInput>
    disconnect?: Enumerable<CommunityBoardPinWhereUniqueInput>
    delete?: Enumerable<CommunityBoardPinWhereUniqueInput>
    update?: Enumerable<CommunityBoardPinUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityBoardPinUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityBoardPinScalarWhereInput>
  }

  export type CommunityCommentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityCommentCreateWithoutUserInput>, Enumerable<CommunityCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityCommentCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityCommentWhereUniqueInput>
    set?: Enumerable<CommunityCommentWhereUniqueInput>
    disconnect?: Enumerable<CommunityCommentWhereUniqueInput>
    delete?: Enumerable<CommunityCommentWhereUniqueInput>
    update?: Enumerable<CommunityCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityCommentScalarWhereInput>
  }

  export type CommunityPostUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostCreateWithoutUserInput>, Enumerable<CommunityPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityPostCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostWhereUniqueInput>
    set?: Enumerable<CommunityPostWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostWhereUniqueInput>
    delete?: Enumerable<CommunityPostWhereUniqueInput>
    update?: Enumerable<CommunityPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostScalarWhereInput>
  }

  export type CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostBookmarkCreateWithoutUserInput>, Enumerable<CommunityPostBookmarkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostBookmarkCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityPostBookmarkUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityPostBookmarkCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    set?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    delete?: Enumerable<CommunityPostBookmarkWhereUniqueInput>
    update?: Enumerable<CommunityPostBookmarkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostBookmarkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostBookmarkScalarWhereInput>
  }

  export type CommunityPostLikeUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunityPostLikeCreateWithoutUserInput>, Enumerable<CommunityPostLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunityPostLikeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunityPostLikeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunityPostLikeCreateManyUserInputEnvelope
    connect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    set?: Enumerable<CommunityPostLikeWhereUniqueInput>
    disconnect?: Enumerable<CommunityPostLikeWhereUniqueInput>
    delete?: Enumerable<CommunityPostLikeWhereUniqueInput>
    update?: Enumerable<CommunityPostLikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunityPostLikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunityPostLikeScalarWhereInput>
  }

  export type CommunitySubcommentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommunitySubcommentCreateWithoutUserInput>, Enumerable<CommunitySubcommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommunitySubcommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommunitySubcommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommunitySubcommentCreateManyUserInputEnvelope
    connect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    set?: Enumerable<CommunitySubcommentWhereUniqueInput>
    disconnect?: Enumerable<CommunitySubcommentWhereUniqueInput>
    delete?: Enumerable<CommunitySubcommentWhereUniqueInput>
    update?: Enumerable<CommunitySubcommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommunitySubcommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommunitySubcommentScalarWhereInput>
  }

  export type LiveChatUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<LiveChatCreateWithoutUserInput>, Enumerable<LiveChatUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LiveChatCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LiveChatUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LiveChatCreateManyUserInputEnvelope
    connect?: Enumerable<LiveChatWhereUniqueInput>
    set?: Enumerable<LiveChatWhereUniqueInput>
    disconnect?: Enumerable<LiveChatWhereUniqueInput>
    delete?: Enumerable<LiveChatWhereUniqueInput>
    update?: Enumerable<LiveChatUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LiveChatUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LiveChatScalarWhereInput>
  }

  export type NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NoticeNotificationsSubscriptionCreateWithoutUserInput>, Enumerable<NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeNotificationsSubscriptionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NoticeNotificationsSubscriptionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NoticeNotificationsSubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    set?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    disconnect?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    delete?: Enumerable<NoticeNotificationsSubscriptionWhereUniqueInput>
    update?: Enumerable<NoticeNotificationsSubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NoticeNotificationsSubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NoticeNotificationsSubscriptionScalarWhereInput>
  }

  export type ReportCommentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportCommentCreateWithoutUserInput>, Enumerable<ReportCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReportCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReportCommentCreateManyUserInputEnvelope
    connect?: Enumerable<ReportCommentWhereUniqueInput>
    set?: Enumerable<ReportCommentWhereUniqueInput>
    disconnect?: Enumerable<ReportCommentWhereUniqueInput>
    delete?: Enumerable<ReportCommentWhereUniqueInput>
    update?: Enumerable<ReportCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportCommentScalarWhereInput>
  }

  export type ReportPostUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportPostCreateWithoutUserInput>, Enumerable<ReportPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReportPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReportPostCreateManyUserInputEnvelope
    connect?: Enumerable<ReportPostWhereUniqueInput>
    set?: Enumerable<ReportPostWhereUniqueInput>
    disconnect?: Enumerable<ReportPostWhereUniqueInput>
    delete?: Enumerable<ReportPostWhereUniqueInput>
    update?: Enumerable<ReportPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportPostScalarWhereInput>
  }

  export type ReportSubcommentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReportSubcommentCreateWithoutUserInput>, Enumerable<ReportSubcommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReportSubcommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReportSubcommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReportSubcommentCreateManyUserInputEnvelope
    connect?: Enumerable<ReportSubcommentWhereUniqueInput>
    set?: Enumerable<ReportSubcommentWhereUniqueInput>
    disconnect?: Enumerable<ReportSubcommentWhereUniqueInput>
    delete?: Enumerable<ReportSubcommentWhereUniqueInput>
    update?: Enumerable<ReportSubcommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReportSubcommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReportSubcommentScalarWhereInput>
  }

  export type TelegramUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TelegramCreateWithoutUserInput>, Enumerable<TelegramUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TelegramCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TelegramUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TelegramCreateManyUserInputEnvelope
    connect?: Enumerable<TelegramWhereUniqueInput>
    set?: Enumerable<TelegramWhereUniqueInput>
    disconnect?: Enumerable<TelegramWhereUniqueInput>
    delete?: Enumerable<TelegramWhereUniqueInput>
    update?: Enumerable<TelegramUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TelegramUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TelegramScalarWhereInput>
  }

  export type CommunityCommentCreateNestedOneWithoutReportCommentsInput = {
    create?: XOR<CommunityCommentCreateWithoutReportCommentsInput, CommunityCommentUncheckedCreateWithoutReportCommentsInput>
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutReportCommentsInput
    connect?: CommunityCommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportCommentsInput = {
    create?: XOR<UserCreateWithoutReportCommentsInput, UserUncheckedCreateWithoutReportCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityCommentUpdateOneRequiredWithoutReportCommentsInput = {
    create?: XOR<CommunityCommentCreateWithoutReportCommentsInput, CommunityCommentUncheckedCreateWithoutReportCommentsInput>
    connectOrCreate?: CommunityCommentCreateOrConnectWithoutReportCommentsInput
    upsert?: CommunityCommentUpsertWithoutReportCommentsInput
    connect?: CommunityCommentWhereUniqueInput
    update?: XOR<CommunityCommentUpdateWithoutReportCommentsInput, CommunityCommentUncheckedUpdateWithoutReportCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutReportCommentsInput = {
    create?: XOR<UserCreateWithoutReportCommentsInput, UserUncheckedCreateWithoutReportCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportCommentsInput
    upsert?: UserUpsertWithoutReportCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReportCommentsInput, UserUncheckedUpdateWithoutReportCommentsInput>
  }

  export type CommunityPostCreateNestedOneWithoutReportPostsInput = {
    create?: XOR<CommunityPostCreateWithoutReportPostsInput, CommunityPostUncheckedCreateWithoutReportPostsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutReportPostsInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportPostsInput = {
    create?: XOR<UserCreateWithoutReportPostsInput, UserUncheckedCreateWithoutReportPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportPostsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityPostUpdateOneRequiredWithoutReportPostsInput = {
    create?: XOR<CommunityPostCreateWithoutReportPostsInput, CommunityPostUncheckedCreateWithoutReportPostsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutReportPostsInput
    upsert?: CommunityPostUpsertWithoutReportPostsInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<CommunityPostUpdateWithoutReportPostsInput, CommunityPostUncheckedUpdateWithoutReportPostsInput>
  }

  export type UserUpdateOneRequiredWithoutReportPostsInput = {
    create?: XOR<UserCreateWithoutReportPostsInput, UserUncheckedCreateWithoutReportPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportPostsInput
    upsert?: UserUpsertWithoutReportPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReportPostsInput, UserUncheckedUpdateWithoutReportPostsInput>
  }

  export type CommunitySubcommentCreateNestedOneWithoutReportSubcommentsInput = {
    create?: XOR<CommunitySubcommentCreateWithoutReportSubcommentsInput, CommunitySubcommentUncheckedCreateWithoutReportSubcommentsInput>
    connectOrCreate?: CommunitySubcommentCreateOrConnectWithoutReportSubcommentsInput
    connect?: CommunitySubcommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportSubcommentsInput = {
    create?: XOR<UserCreateWithoutReportSubcommentsInput, UserUncheckedCreateWithoutReportSubcommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportSubcommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunitySubcommentUpdateOneRequiredWithoutReportSubcommentsInput = {
    create?: XOR<CommunitySubcommentCreateWithoutReportSubcommentsInput, CommunitySubcommentUncheckedCreateWithoutReportSubcommentsInput>
    connectOrCreate?: CommunitySubcommentCreateOrConnectWithoutReportSubcommentsInput
    upsert?: CommunitySubcommentUpsertWithoutReportSubcommentsInput
    connect?: CommunitySubcommentWhereUniqueInput
    update?: XOR<CommunitySubcommentUpdateWithoutReportSubcommentsInput, CommunitySubcommentUncheckedUpdateWithoutReportSubcommentsInput>
  }

  export type UserUpdateOneRequiredWithoutReportSubcommentsInput = {
    create?: XOR<UserCreateWithoutReportSubcommentsInput, UserUncheckedCreateWithoutReportSubcommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportSubcommentsInput
    upsert?: UserUpsertWithoutReportSubcommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReportSubcommentsInput, UserUncheckedUpdateWithoutReportSubcommentsInput>
  }

  export type UserCreateNestedOneWithoutTelegramsInput = {
    create?: XOR<UserCreateWithoutTelegramsInput, UserUncheckedCreateWithoutTelegramsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTelegramsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTelegramsInput = {
    create?: XOR<UserCreateWithoutTelegramsInput, UserUncheckedCreateWithoutTelegramsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTelegramsInput
    upsert?: UserUpsertWithoutTelegramsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTelegramsInput, UserUncheckedUpdateWithoutTelegramsInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedJsonNullableFilter = {
    equals?: InputJsonValue | null
    not?: InputJsonValue | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    count?: NestedIntNullableFilter
    min?: NestedStringNullableFilter
    max?: NestedStringNullableFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    count?: NestedIntFilter
    min?: NestedBoolFilter
    max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    count?: NestedIntNullableFilter
    min?: NestedDateTimeNullableFilter
    max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedIntNullableFilter
    min?: NestedIntNullableFilter
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type UserCreateWithoutAdminInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutChangePasswordInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChangePasswordInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChangePasswordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChangePasswordInput, UserUncheckedCreateWithoutChangePasswordInput>
  }

  export type UserUpsertWithoutChangePasswordInput = {
    update: XOR<UserUpdateWithoutChangePasswordInput, UserUncheckedUpdateWithoutChangePasswordInput>
    create: XOR<UserCreateWithoutChangePasswordInput, UserUncheckedCreateWithoutChangePasswordInput>
  }

  export type UserUpdateWithoutChangePasswordInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutChangePasswordInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutCommunityBoardsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityBoardsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityBoardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityBoardsInput, UserUncheckedCreateWithoutCommunityBoardsInput>
  }

  export type CommunityBoardPinCreateWithoutCommunityBoardInput = {
    user: UserCreateNestedOneWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput = {
    userId: number
  }

  export type CommunityBoardPinCreateOrConnectWithoutCommunityBoardInput = {
    where: CommunityBoardPinWhereUniqueInput
    create: XOR<CommunityBoardPinCreateWithoutCommunityBoardInput, CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput>
  }

  export type CommunityBoardPinCreateManyCommunityBoardInputEnvelope = {
    data: Enumerable<CommunityBoardPinCreateManyCommunityBoardInput>
    skipDuplicates?: boolean
  }

  export type CommunityPostCreateWithoutCommunityBoardInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommunityBoardInput = {
    id?: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutCommunityBoardInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutCommunityBoardInput, CommunityPostUncheckedCreateWithoutCommunityBoardInput>
  }

  export type CommunityPostCreateManyCommunityBoardInputEnvelope = {
    data: Enumerable<CommunityPostCreateManyCommunityBoardInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommunityBoardsInput = {
    update: XOR<UserUpdateWithoutCommunityBoardsInput, UserUncheckedUpdateWithoutCommunityBoardsInput>
    create: XOR<UserCreateWithoutCommunityBoardsInput, UserUncheckedCreateWithoutCommunityBoardsInput>
  }

  export type UserUpdateWithoutCommunityBoardsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityBoardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityBoardPinUpsertWithWhereUniqueWithoutCommunityBoardInput = {
    where: CommunityBoardPinWhereUniqueInput
    update: XOR<CommunityBoardPinUpdateWithoutCommunityBoardInput, CommunityBoardPinUncheckedUpdateWithoutCommunityBoardInput>
    create: XOR<CommunityBoardPinCreateWithoutCommunityBoardInput, CommunityBoardPinUncheckedCreateWithoutCommunityBoardInput>
  }

  export type CommunityBoardPinUpdateWithWhereUniqueWithoutCommunityBoardInput = {
    where: CommunityBoardPinWhereUniqueInput
    data: XOR<CommunityBoardPinUpdateWithoutCommunityBoardInput, CommunityBoardPinUncheckedUpdateWithoutCommunityBoardInput>
  }

  export type CommunityBoardPinUpdateManyWithWhereWithoutCommunityBoardInput = {
    where: CommunityBoardPinScalarWhereInput
    data: XOR<CommunityBoardPinUpdateManyMutationInput, CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardPinsInput>
  }

  export type CommunityBoardPinScalarWhereInput = {
    AND?: Enumerable<CommunityBoardPinScalarWhereInput>
    OR?: Enumerable<CommunityBoardPinScalarWhereInput>
    NOT?: Enumerable<CommunityBoardPinScalarWhereInput>
    userId?: IntFilter | number
    boardId?: IntFilter | number
  }

  export type CommunityPostUpsertWithWhereUniqueWithoutCommunityBoardInput = {
    where: CommunityPostWhereUniqueInput
    update: XOR<CommunityPostUpdateWithoutCommunityBoardInput, CommunityPostUncheckedUpdateWithoutCommunityBoardInput>
    create: XOR<CommunityPostCreateWithoutCommunityBoardInput, CommunityPostUncheckedCreateWithoutCommunityBoardInput>
  }

  export type CommunityPostUpdateWithWhereUniqueWithoutCommunityBoardInput = {
    where: CommunityPostWhereUniqueInput
    data: XOR<CommunityPostUpdateWithoutCommunityBoardInput, CommunityPostUncheckedUpdateWithoutCommunityBoardInput>
  }

  export type CommunityPostUpdateManyWithWhereWithoutCommunityBoardInput = {
    where: CommunityPostScalarWhereInput
    data: XOR<CommunityPostUpdateManyMutationInput, CommunityPostUncheckedUpdateManyWithoutCommunityPostsInput>
  }

  export type CommunityPostScalarWhereInput = {
    AND?: Enumerable<CommunityPostScalarWhereInput>
    OR?: Enumerable<CommunityPostScalarWhereInput>
    NOT?: Enumerable<CommunityPostScalarWhereInput>
    id?: IntFilter | number
    boardId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringFilter | string
    randomNickname?: StringFilter | string
    likesCount?: IntFilter | number
    commentsCount?: IntFilter | number
    bookmarksCount?: IntFilter | number
    postedAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeNullableFilter | Date | string | null
    isDeleted?: BoolFilter | boolean
  }

  export type UserCreateWithoutCommunityBoardCandidatesInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityBoardCandidatesInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityBoardCandidatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityBoardCandidatesInput, UserUncheckedCreateWithoutCommunityBoardCandidatesInput>
  }

  export type CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput = {
    user: UserCreateNestedOneWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput = {
    userId: number
  }

  export type CommunityBoardCandidateVoteCreateOrConnectWithoutCommunityBoardCandidateInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    create: XOR<CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput, CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput>
  }

  export type CommunityBoardCandidateVoteCreateManyCommunityBoardCandidateInputEnvelope = {
    data: Enumerable<CommunityBoardCandidateVoteCreateManyCommunityBoardCandidateInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommunityBoardCandidatesInput = {
    update: XOR<UserUpdateWithoutCommunityBoardCandidatesInput, UserUncheckedUpdateWithoutCommunityBoardCandidatesInput>
    create: XOR<UserCreateWithoutCommunityBoardCandidatesInput, UserUncheckedCreateWithoutCommunityBoardCandidatesInput>
  }

  export type UserUpdateWithoutCommunityBoardCandidatesInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityBoardCandidatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutCommunityBoardCandidateInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    update: XOR<CommunityBoardCandidateVoteUpdateWithoutCommunityBoardCandidateInput, CommunityBoardCandidateVoteUncheckedUpdateWithoutCommunityBoardCandidateInput>
    create: XOR<CommunityBoardCandidateVoteCreateWithoutCommunityBoardCandidateInput, CommunityBoardCandidateVoteUncheckedCreateWithoutCommunityBoardCandidateInput>
  }

  export type CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutCommunityBoardCandidateInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    data: XOR<CommunityBoardCandidateVoteUpdateWithoutCommunityBoardCandidateInput, CommunityBoardCandidateVoteUncheckedUpdateWithoutCommunityBoardCandidateInput>
  }

  export type CommunityBoardCandidateVoteUpdateManyWithWhereWithoutCommunityBoardCandidateInput = {
    where: CommunityBoardCandidateVoteScalarWhereInput
    data: XOR<CommunityBoardCandidateVoteUpdateManyMutationInput, CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateVotesInput>
  }

  export type CommunityBoardCandidateVoteScalarWhereInput = {
    AND?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
    OR?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
    NOT?: Enumerable<CommunityBoardCandidateVoteScalarWhereInput>
    boardCandidateId?: IntFilter | number
    userId?: IntFilter | number
  }

  export type CommunityBoardCandidateCreateWithoutCommunityBoardCandidateVotesInput = {
    name?: string
    description?: string | null
    createdAt: Date | string
    user: UserCreateNestedOneWithoutCommunityBoardCandidatesInput
  }

  export type CommunityBoardCandidateUncheckedCreateWithoutCommunityBoardCandidateVotesInput = {
    id?: number
    name?: string
    description?: string | null
    createdBy: number
    createdAt: Date | string
  }

  export type CommunityBoardCandidateCreateOrConnectWithoutCommunityBoardCandidateVotesInput = {
    where: CommunityBoardCandidateWhereUniqueInput
    create: XOR<CommunityBoardCandidateCreateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateUncheckedCreateWithoutCommunityBoardCandidateVotesInput>
  }

  export type UserCreateWithoutCommunityBoardCandidateVotesInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityBoardCandidateVotesInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityBoardCandidateVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityBoardCandidateVotesInput, UserUncheckedCreateWithoutCommunityBoardCandidateVotesInput>
  }

  export type CommunityBoardCandidateUpsertWithoutCommunityBoardCandidateVotesInput = {
    update: XOR<CommunityBoardCandidateUpdateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateUncheckedUpdateWithoutCommunityBoardCandidateVotesInput>
    create: XOR<CommunityBoardCandidateCreateWithoutCommunityBoardCandidateVotesInput, CommunityBoardCandidateUncheckedCreateWithoutCommunityBoardCandidateVotesInput>
  }

  export type CommunityBoardCandidateUpdateWithoutCommunityBoardCandidateVotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommunityBoardCandidatesInput
  }

  export type CommunityBoardCandidateUncheckedUpdateWithoutCommunityBoardCandidateVotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCommunityBoardCandidateVotesInput = {
    update: XOR<UserUpdateWithoutCommunityBoardCandidateVotesInput, UserUncheckedUpdateWithoutCommunityBoardCandidateVotesInput>
    create: XOR<UserCreateWithoutCommunityBoardCandidateVotesInput, UserUncheckedCreateWithoutCommunityBoardCandidateVotesInput>
  }

  export type UserUpdateWithoutCommunityBoardCandidateVotesInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityBoardCandidateVotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityBoardCreateWithoutCommunityBoardPinsInput = {
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdAt: Date | string
    activeAt?: Date | string | null
    user: UserCreateNestedOneWithoutCommunityBoardsInput
    communityPosts?: CommunityPostCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedCreateWithoutCommunityBoardPinsInput = {
    id?: number
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdBy: number
    createdAt: Date | string
    activeAt?: Date | string | null
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardCreateOrConnectWithoutCommunityBoardPinsInput = {
    where: CommunityBoardWhereUniqueInput
    create: XOR<CommunityBoardCreateWithoutCommunityBoardPinsInput, CommunityBoardUncheckedCreateWithoutCommunityBoardPinsInput>
  }

  export type UserCreateWithoutCommunityBoardPinsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityBoardPinsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityBoardPinsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityBoardPinsInput, UserUncheckedCreateWithoutCommunityBoardPinsInput>
  }

  export type CommunityBoardUpsertWithoutCommunityBoardPinsInput = {
    update: XOR<CommunityBoardUpdateWithoutCommunityBoardPinsInput, CommunityBoardUncheckedUpdateWithoutCommunityBoardPinsInput>
    create: XOR<CommunityBoardCreateWithoutCommunityBoardPinsInput, CommunityBoardUncheckedCreateWithoutCommunityBoardPinsInput>
  }

  export type CommunityBoardUpdateWithoutCommunityBoardPinsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCommunityBoardsInput
    communityPosts?: CommunityPostUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedUpdateWithoutCommunityBoardPinsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutCommunityBoardInput
  }

  export type UserUpsertWithoutCommunityBoardPinsInput = {
    update: XOR<UserUpdateWithoutCommunityBoardPinsInput, UserUncheckedUpdateWithoutCommunityBoardPinsInput>
    create: XOR<UserCreateWithoutCommunityBoardPinsInput, UserUncheckedCreateWithoutCommunityBoardPinsInput>
  }

  export type UserUpdateWithoutCommunityBoardPinsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityBoardPinsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityPostCreateWithoutCommunityCommentsInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommunityCommentsInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutCommunityCommentsInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutCommunityCommentsInput, CommunityPostUncheckedCreateWithoutCommunityCommentsInput>
  }

  export type UserCreateWithoutCommunityCommentsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityCommentsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityCommentsInput, UserUncheckedCreateWithoutCommunityCommentsInput>
  }

  export type CommunitySubcommentCreateWithoutCommunityCommentInput = {
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    communityPost: CommunityPostCreateNestedOneWithoutCommunitySubcommentsInput
    user: UserCreateNestedOneWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput = {
    id?: number
    userId: number
    postId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentCreateOrConnectWithoutCommunityCommentInput = {
    where: CommunitySubcommentWhereUniqueInput
    create: XOR<CommunitySubcommentCreateWithoutCommunityCommentInput, CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput>
  }

  export type CommunitySubcommentCreateManyCommunityCommentInputEnvelope = {
    data: Enumerable<CommunitySubcommentCreateManyCommunityCommentInput>
    skipDuplicates?: boolean
  }

  export type ReportCommentCreateWithoutCommunityCommentInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    user: UserCreateNestedOneWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedCreateWithoutCommunityCommentInput = {
    id?: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportCommentCreateOrConnectWithoutCommunityCommentInput = {
    where: ReportCommentWhereUniqueInput
    create: XOR<ReportCommentCreateWithoutCommunityCommentInput, ReportCommentUncheckedCreateWithoutCommunityCommentInput>
  }

  export type ReportCommentCreateManyCommunityCommentInputEnvelope = {
    data: Enumerable<ReportCommentCreateManyCommunityCommentInput>
    skipDuplicates?: boolean
  }

  export type CommunityPostUpsertWithoutCommunityCommentsInput = {
    update: XOR<CommunityPostUpdateWithoutCommunityCommentsInput, CommunityPostUncheckedUpdateWithoutCommunityCommentsInput>
    create: XOR<CommunityPostCreateWithoutCommunityCommentsInput, CommunityPostUncheckedCreateWithoutCommunityCommentsInput>
  }

  export type CommunityPostUpdateWithoutCommunityCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommunityCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type UserUpsertWithoutCommunityCommentsInput = {
    update: XOR<UserUpdateWithoutCommunityCommentsInput, UserUncheckedUpdateWithoutCommunityCommentsInput>
    create: XOR<UserCreateWithoutCommunityCommentsInput, UserUncheckedCreateWithoutCommunityCommentsInput>
  }

  export type UserUpdateWithoutCommunityCommentsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityCommentInput = {
    where: CommunitySubcommentWhereUniqueInput
    update: XOR<CommunitySubcommentUpdateWithoutCommunityCommentInput, CommunitySubcommentUncheckedUpdateWithoutCommunityCommentInput>
    create: XOR<CommunitySubcommentCreateWithoutCommunityCommentInput, CommunitySubcommentUncheckedCreateWithoutCommunityCommentInput>
  }

  export type CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityCommentInput = {
    where: CommunitySubcommentWhereUniqueInput
    data: XOR<CommunitySubcommentUpdateWithoutCommunityCommentInput, CommunitySubcommentUncheckedUpdateWithoutCommunityCommentInput>
  }

  export type CommunitySubcommentUpdateManyWithWhereWithoutCommunityCommentInput = {
    where: CommunitySubcommentScalarWhereInput
    data: XOR<CommunitySubcommentUpdateManyMutationInput, CommunitySubcommentUncheckedUpdateManyWithoutCommunitySubcommentsInput>
  }

  export type CommunitySubcommentScalarWhereInput = {
    AND?: Enumerable<CommunitySubcommentScalarWhereInput>
    OR?: Enumerable<CommunitySubcommentScalarWhereInput>
    NOT?: Enumerable<CommunitySubcommentScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    postId?: IntFilter | number
    commentId?: IntFilter | number
    randomNickname?: StringFilter | string
    body?: StringFilter | string
    subcommentedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
  }

  export type ReportCommentUpsertWithWhereUniqueWithoutCommunityCommentInput = {
    where: ReportCommentWhereUniqueInput
    update: XOR<ReportCommentUpdateWithoutCommunityCommentInput, ReportCommentUncheckedUpdateWithoutCommunityCommentInput>
    create: XOR<ReportCommentCreateWithoutCommunityCommentInput, ReportCommentUncheckedCreateWithoutCommunityCommentInput>
  }

  export type ReportCommentUpdateWithWhereUniqueWithoutCommunityCommentInput = {
    where: ReportCommentWhereUniqueInput
    data: XOR<ReportCommentUpdateWithoutCommunityCommentInput, ReportCommentUncheckedUpdateWithoutCommunityCommentInput>
  }

  export type ReportCommentUpdateManyWithWhereWithoutCommunityCommentInput = {
    where: ReportCommentScalarWhereInput
    data: XOR<ReportCommentUpdateManyMutationInput, ReportCommentUncheckedUpdateManyWithoutReportCommentsInput>
  }

  export type ReportCommentScalarWhereInput = {
    AND?: Enumerable<ReportCommentScalarWhereInput>
    OR?: Enumerable<ReportCommentScalarWhereInput>
    NOT?: Enumerable<ReportCommentScalarWhereInput>
    id?: IntFilter | number
    commentId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
  }

  export type CommunityBoardCreateWithoutCommunityPostsInput = {
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdAt: Date | string
    activeAt?: Date | string | null
    user: UserCreateNestedOneWithoutCommunityBoardsInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedCreateWithoutCommunityPostsInput = {
    id?: number
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdBy: number
    createdAt: Date | string
    activeAt?: Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardCreateOrConnectWithoutCommunityPostsInput = {
    where: CommunityBoardWhereUniqueInput
    create: XOR<CommunityBoardCreateWithoutCommunityPostsInput, CommunityBoardUncheckedCreateWithoutCommunityPostsInput>
  }

  export type UserCreateWithoutCommunityPostsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityPostsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityPostsInput, UserUncheckedCreateWithoutCommunityPostsInput>
  }

  export type CommunityCommentCreateWithoutCommunityPostInput = {
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    user: UserCreateNestedOneWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedCreateWithoutCommunityPostInput = {
    id?: number
    userId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentCreateOrConnectWithoutCommunityPostInput = {
    where: CommunityCommentWhereUniqueInput
    create: XOR<CommunityCommentCreateWithoutCommunityPostInput, CommunityCommentUncheckedCreateWithoutCommunityPostInput>
  }

  export type CommunityCommentCreateManyCommunityPostInputEnvelope = {
    data: Enumerable<CommunityCommentCreateManyCommunityPostInput>
    skipDuplicates?: boolean
  }

  export type CommunityPostBookmarkCreateWithoutCommunityPostInput = {
    user: UserCreateNestedOneWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput = {
    userId: number
  }

  export type CommunityPostBookmarkCreateOrConnectWithoutCommunityPostInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    create: XOR<CommunityPostBookmarkCreateWithoutCommunityPostInput, CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput>
  }

  export type CommunityPostBookmarkCreateManyCommunityPostInputEnvelope = {
    data: Enumerable<CommunityPostBookmarkCreateManyCommunityPostInput>
    skipDuplicates?: boolean
  }

  export type CommunityPostLikeCreateWithoutCommunityPostInput = {
    user: UserCreateNestedOneWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedCreateWithoutCommunityPostInput = {
    userId: number
  }

  export type CommunityPostLikeCreateOrConnectWithoutCommunityPostInput = {
    where: CommunityPostLikeWhereUniqueInput
    create: XOR<CommunityPostLikeCreateWithoutCommunityPostInput, CommunityPostLikeUncheckedCreateWithoutCommunityPostInput>
  }

  export type CommunityPostLikeCreateManyCommunityPostInputEnvelope = {
    data: Enumerable<CommunityPostLikeCreateManyCommunityPostInput>
    skipDuplicates?: boolean
  }

  export type CommunitySubcommentCreateWithoutCommunityPostInput = {
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    communityComment: CommunityCommentCreateNestedOneWithoutCommunitySubcommentsInput
    user: UserCreateNestedOneWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedCreateWithoutCommunityPostInput = {
    id?: number
    userId: number
    commentId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentCreateOrConnectWithoutCommunityPostInput = {
    where: CommunitySubcommentWhereUniqueInput
    create: XOR<CommunitySubcommentCreateWithoutCommunityPostInput, CommunitySubcommentUncheckedCreateWithoutCommunityPostInput>
  }

  export type CommunitySubcommentCreateManyCommunityPostInputEnvelope = {
    data: Enumerable<CommunitySubcommentCreateManyCommunityPostInput>
    skipDuplicates?: boolean
  }

  export type ReportPostCreateWithoutCommunityPostInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    user: UserCreateNestedOneWithoutReportPostsInput
  }

  export type ReportPostUncheckedCreateWithoutCommunityPostInput = {
    id?: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportPostCreateOrConnectWithoutCommunityPostInput = {
    where: ReportPostWhereUniqueInput
    create: XOR<ReportPostCreateWithoutCommunityPostInput, ReportPostUncheckedCreateWithoutCommunityPostInput>
  }

  export type ReportPostCreateManyCommunityPostInputEnvelope = {
    data: Enumerable<ReportPostCreateManyCommunityPostInput>
    skipDuplicates?: boolean
  }

  export type CommunityBoardUpsertWithoutCommunityPostsInput = {
    update: XOR<CommunityBoardUpdateWithoutCommunityPostsInput, CommunityBoardUncheckedUpdateWithoutCommunityPostsInput>
    create: XOR<CommunityBoardCreateWithoutCommunityPostsInput, CommunityBoardUncheckedCreateWithoutCommunityPostsInput>
  }

  export type CommunityBoardUpdateWithoutCommunityPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCommunityBoardsInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedUpdateWithoutCommunityPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardInput
  }

  export type UserUpsertWithoutCommunityPostsInput = {
    update: XOR<UserUpdateWithoutCommunityPostsInput, UserUncheckedUpdateWithoutCommunityPostsInput>
    create: XOR<UserCreateWithoutCommunityPostsInput, UserUncheckedCreateWithoutCommunityPostsInput>
  }

  export type UserUpdateWithoutCommunityPostsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityCommentUpsertWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityCommentWhereUniqueInput
    update: XOR<CommunityCommentUpdateWithoutCommunityPostInput, CommunityCommentUncheckedUpdateWithoutCommunityPostInput>
    create: XOR<CommunityCommentCreateWithoutCommunityPostInput, CommunityCommentUncheckedCreateWithoutCommunityPostInput>
  }

  export type CommunityCommentUpdateWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityCommentWhereUniqueInput
    data: XOR<CommunityCommentUpdateWithoutCommunityPostInput, CommunityCommentUncheckedUpdateWithoutCommunityPostInput>
  }

  export type CommunityCommentUpdateManyWithWhereWithoutCommunityPostInput = {
    where: CommunityCommentScalarWhereInput
    data: XOR<CommunityCommentUpdateManyMutationInput, CommunityCommentUncheckedUpdateManyWithoutCommunityCommentsInput>
  }

  export type CommunityCommentScalarWhereInput = {
    AND?: Enumerable<CommunityCommentScalarWhereInput>
    OR?: Enumerable<CommunityCommentScalarWhereInput>
    NOT?: Enumerable<CommunityCommentScalarWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    userId?: IntFilter | number
    randomNickname?: StringFilter | string
    body?: StringFilter | string
    commentedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
  }

  export type CommunityPostBookmarkUpsertWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    update: XOR<CommunityPostBookmarkUpdateWithoutCommunityPostInput, CommunityPostBookmarkUncheckedUpdateWithoutCommunityPostInput>
    create: XOR<CommunityPostBookmarkCreateWithoutCommunityPostInput, CommunityPostBookmarkUncheckedCreateWithoutCommunityPostInput>
  }

  export type CommunityPostBookmarkUpdateWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    data: XOR<CommunityPostBookmarkUpdateWithoutCommunityPostInput, CommunityPostBookmarkUncheckedUpdateWithoutCommunityPostInput>
  }

  export type CommunityPostBookmarkUpdateManyWithWhereWithoutCommunityPostInput = {
    where: CommunityPostBookmarkScalarWhereInput
    data: XOR<CommunityPostBookmarkUpdateManyMutationInput, CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostBookmarksInput>
  }

  export type CommunityPostBookmarkScalarWhereInput = {
    AND?: Enumerable<CommunityPostBookmarkScalarWhereInput>
    OR?: Enumerable<CommunityPostBookmarkScalarWhereInput>
    NOT?: Enumerable<CommunityPostBookmarkScalarWhereInput>
    userId?: IntFilter | number
    postId?: IntFilter | number
  }

  export type CommunityPostLikeUpsertWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityPostLikeWhereUniqueInput
    update: XOR<CommunityPostLikeUpdateWithoutCommunityPostInput, CommunityPostLikeUncheckedUpdateWithoutCommunityPostInput>
    create: XOR<CommunityPostLikeCreateWithoutCommunityPostInput, CommunityPostLikeUncheckedCreateWithoutCommunityPostInput>
  }

  export type CommunityPostLikeUpdateWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunityPostLikeWhereUniqueInput
    data: XOR<CommunityPostLikeUpdateWithoutCommunityPostInput, CommunityPostLikeUncheckedUpdateWithoutCommunityPostInput>
  }

  export type CommunityPostLikeUpdateManyWithWhereWithoutCommunityPostInput = {
    where: CommunityPostLikeScalarWhereInput
    data: XOR<CommunityPostLikeUpdateManyMutationInput, CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostLikesInput>
  }

  export type CommunityPostLikeScalarWhereInput = {
    AND?: Enumerable<CommunityPostLikeScalarWhereInput>
    OR?: Enumerable<CommunityPostLikeScalarWhereInput>
    NOT?: Enumerable<CommunityPostLikeScalarWhereInput>
    userId?: IntFilter | number
    postId?: IntFilter | number
  }

  export type CommunitySubcommentUpsertWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunitySubcommentWhereUniqueInput
    update: XOR<CommunitySubcommentUpdateWithoutCommunityPostInput, CommunitySubcommentUncheckedUpdateWithoutCommunityPostInput>
    create: XOR<CommunitySubcommentCreateWithoutCommunityPostInput, CommunitySubcommentUncheckedCreateWithoutCommunityPostInput>
  }

  export type CommunitySubcommentUpdateWithWhereUniqueWithoutCommunityPostInput = {
    where: CommunitySubcommentWhereUniqueInput
    data: XOR<CommunitySubcommentUpdateWithoutCommunityPostInput, CommunitySubcommentUncheckedUpdateWithoutCommunityPostInput>
  }

  export type CommunitySubcommentUpdateManyWithWhereWithoutCommunityPostInput = {
    where: CommunitySubcommentScalarWhereInput
    data: XOR<CommunitySubcommentUpdateManyMutationInput, CommunitySubcommentUncheckedUpdateManyWithoutCommunitySubcommentsInput>
  }

  export type ReportPostUpsertWithWhereUniqueWithoutCommunityPostInput = {
    where: ReportPostWhereUniqueInput
    update: XOR<ReportPostUpdateWithoutCommunityPostInput, ReportPostUncheckedUpdateWithoutCommunityPostInput>
    create: XOR<ReportPostCreateWithoutCommunityPostInput, ReportPostUncheckedCreateWithoutCommunityPostInput>
  }

  export type ReportPostUpdateWithWhereUniqueWithoutCommunityPostInput = {
    where: ReportPostWhereUniqueInput
    data: XOR<ReportPostUpdateWithoutCommunityPostInput, ReportPostUncheckedUpdateWithoutCommunityPostInput>
  }

  export type ReportPostUpdateManyWithWhereWithoutCommunityPostInput = {
    where: ReportPostScalarWhereInput
    data: XOR<ReportPostUpdateManyMutationInput, ReportPostUncheckedUpdateManyWithoutReportPostsInput>
  }

  export type ReportPostScalarWhereInput = {
    AND?: Enumerable<ReportPostScalarWhereInput>
    OR?: Enumerable<ReportPostScalarWhereInput>
    NOT?: Enumerable<ReportPostScalarWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
  }

  export type CommunityPostCreateWithoutCommunityPostBookmarksInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommunityPostBookmarksInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutCommunityPostBookmarksInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutCommunityPostBookmarksInput, CommunityPostUncheckedCreateWithoutCommunityPostBookmarksInput>
  }

  export type UserCreateWithoutCommunityPostBookmarksInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityPostBookmarksInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityPostBookmarksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityPostBookmarksInput, UserUncheckedCreateWithoutCommunityPostBookmarksInput>
  }

  export type CommunityPostUpsertWithoutCommunityPostBookmarksInput = {
    update: XOR<CommunityPostUpdateWithoutCommunityPostBookmarksInput, CommunityPostUncheckedUpdateWithoutCommunityPostBookmarksInput>
    create: XOR<CommunityPostCreateWithoutCommunityPostBookmarksInput, CommunityPostUncheckedCreateWithoutCommunityPostBookmarksInput>
  }

  export type CommunityPostUpdateWithoutCommunityPostBookmarksInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommunityPostBookmarksInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type UserUpsertWithoutCommunityPostBookmarksInput = {
    update: XOR<UserUpdateWithoutCommunityPostBookmarksInput, UserUncheckedUpdateWithoutCommunityPostBookmarksInput>
    create: XOR<UserCreateWithoutCommunityPostBookmarksInput, UserUncheckedCreateWithoutCommunityPostBookmarksInput>
  }

  export type UserUpdateWithoutCommunityPostBookmarksInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityPostBookmarksInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityPostCreateWithoutCommunityPostLikesInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommunityPostLikesInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutCommunityPostLikesInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutCommunityPostLikesInput, CommunityPostUncheckedCreateWithoutCommunityPostLikesInput>
  }

  export type UserCreateWithoutCommunityPostLikesInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityPostLikesInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityPostLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityPostLikesInput, UserUncheckedCreateWithoutCommunityPostLikesInput>
  }

  export type CommunityPostUpsertWithoutCommunityPostLikesInput = {
    update: XOR<CommunityPostUpdateWithoutCommunityPostLikesInput, CommunityPostUncheckedUpdateWithoutCommunityPostLikesInput>
    create: XOR<CommunityPostCreateWithoutCommunityPostLikesInput, CommunityPostUncheckedCreateWithoutCommunityPostLikesInput>
  }

  export type CommunityPostUpdateWithoutCommunityPostLikesInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommunityPostLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type UserUpsertWithoutCommunityPostLikesInput = {
    update: XOR<UserUpdateWithoutCommunityPostLikesInput, UserUncheckedUpdateWithoutCommunityPostLikesInput>
    create: XOR<UserCreateWithoutCommunityPostLikesInput, UserUncheckedCreateWithoutCommunityPostLikesInput>
  }

  export type UserUpdateWithoutCommunityPostLikesInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunityPostLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityCommentCreateWithoutCommunitySubcommentsInput = {
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communityPost: CommunityPostCreateNestedOneWithoutCommunityCommentsInput
    user: UserCreateNestedOneWithoutCommunityCommentsInput
    reportComments?: ReportCommentCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedCreateWithoutCommunitySubcommentsInput = {
    id?: number
    postId: number
    userId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentCreateOrConnectWithoutCommunitySubcommentsInput = {
    where: CommunityCommentWhereUniqueInput
    create: XOR<CommunityCommentCreateWithoutCommunitySubcommentsInput, CommunityCommentUncheckedCreateWithoutCommunitySubcommentsInput>
  }

  export type CommunityPostCreateWithoutCommunitySubcommentsInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommunitySubcommentsInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutCommunitySubcommentsInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutCommunitySubcommentsInput, CommunityPostUncheckedCreateWithoutCommunitySubcommentsInput>
  }

  export type UserCreateWithoutCommunitySubcommentsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunitySubcommentsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunitySubcommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunitySubcommentsInput, UserUncheckedCreateWithoutCommunitySubcommentsInput>
  }

  export type ReportSubcommentCreateWithoutCommunitySubcommentInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    user: UserCreateNestedOneWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput = {
    id?: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportSubcommentCreateOrConnectWithoutCommunitySubcommentInput = {
    where: ReportSubcommentWhereUniqueInput
    create: XOR<ReportSubcommentCreateWithoutCommunitySubcommentInput, ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput>
  }

  export type ReportSubcommentCreateManyCommunitySubcommentInputEnvelope = {
    data: Enumerable<ReportSubcommentCreateManyCommunitySubcommentInput>
    skipDuplicates?: boolean
  }

  export type CommunityCommentUpsertWithoutCommunitySubcommentsInput = {
    update: XOR<CommunityCommentUpdateWithoutCommunitySubcommentsInput, CommunityCommentUncheckedUpdateWithoutCommunitySubcommentsInput>
    create: XOR<CommunityCommentCreateWithoutCommunitySubcommentsInput, CommunityCommentUncheckedCreateWithoutCommunitySubcommentsInput>
  }

  export type CommunityCommentUpdateWithoutCommunitySubcommentsInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityCommentsInput
    user?: UserUpdateOneRequiredWithoutCommunityCommentsInput
    reportComments?: ReportCommentUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateWithoutCommunitySubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reportComments?: ReportCommentUncheckedUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityPostUpsertWithoutCommunitySubcommentsInput = {
    update: XOR<CommunityPostUpdateWithoutCommunitySubcommentsInput, CommunityPostUncheckedUpdateWithoutCommunitySubcommentsInput>
    create: XOR<CommunityPostCreateWithoutCommunitySubcommentsInput, CommunityPostUncheckedCreateWithoutCommunitySubcommentsInput>
  }

  export type CommunityPostUpdateWithoutCommunitySubcommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommunitySubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type UserUpsertWithoutCommunitySubcommentsInput = {
    update: XOR<UserUpdateWithoutCommunitySubcommentsInput, UserUncheckedUpdateWithoutCommunitySubcommentsInput>
    create: XOR<UserCreateWithoutCommunitySubcommentsInput, UserUncheckedCreateWithoutCommunitySubcommentsInput>
  }

  export type UserUpdateWithoutCommunitySubcommentsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommunitySubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type ReportSubcommentUpsertWithWhereUniqueWithoutCommunitySubcommentInput = {
    where: ReportSubcommentWhereUniqueInput
    update: XOR<ReportSubcommentUpdateWithoutCommunitySubcommentInput, ReportSubcommentUncheckedUpdateWithoutCommunitySubcommentInput>
    create: XOR<ReportSubcommentCreateWithoutCommunitySubcommentInput, ReportSubcommentUncheckedCreateWithoutCommunitySubcommentInput>
  }

  export type ReportSubcommentUpdateWithWhereUniqueWithoutCommunitySubcommentInput = {
    where: ReportSubcommentWhereUniqueInput
    data: XOR<ReportSubcommentUpdateWithoutCommunitySubcommentInput, ReportSubcommentUncheckedUpdateWithoutCommunitySubcommentInput>
  }

  export type ReportSubcommentUpdateManyWithWhereWithoutCommunitySubcommentInput = {
    where: ReportSubcommentScalarWhereInput
    data: XOR<ReportSubcommentUpdateManyMutationInput, ReportSubcommentUncheckedUpdateManyWithoutReportSubcommentsInput>
  }

  export type ReportSubcommentScalarWhereInput = {
    AND?: Enumerable<ReportSubcommentScalarWhereInput>
    OR?: Enumerable<ReportSubcommentScalarWhereInput>
    NOT?: Enumerable<ReportSubcommentScalarWhereInput>
    id?: IntFilter | number
    subcommentId?: IntFilter | number
    userId?: IntFilter | number
    title?: StringFilter | string
    body?: StringNullableFilter | string | null
    reportedAt?: DateTimeFilter | Date | string
  }

  export type CoverageMajorLectureCreateWithoutCoverageMajorInput = {
    lecture: LectureCreateNestedOneWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput = {
    lectureId: string
  }

  export type CoverageMajorLectureCreateOrConnectWithoutCoverageMajorInput = {
    where: CoverageMajorLectureWhereUniqueInput
    create: XOR<CoverageMajorLectureCreateWithoutCoverageMajorInput, CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput>
  }

  export type CoverageMajorLectureCreateManyCoverageMajorInputEnvelope = {
    data: Enumerable<CoverageMajorLectureCreateManyCoverageMajorInput>
    skipDuplicates?: boolean
  }

  export type CoverageMajorLectureUpsertWithWhereUniqueWithoutCoverageMajorInput = {
    where: CoverageMajorLectureWhereUniqueInput
    update: XOR<CoverageMajorLectureUpdateWithoutCoverageMajorInput, CoverageMajorLectureUncheckedUpdateWithoutCoverageMajorInput>
    create: XOR<CoverageMajorLectureCreateWithoutCoverageMajorInput, CoverageMajorLectureUncheckedCreateWithoutCoverageMajorInput>
  }

  export type CoverageMajorLectureUpdateWithWhereUniqueWithoutCoverageMajorInput = {
    where: CoverageMajorLectureWhereUniqueInput
    data: XOR<CoverageMajorLectureUpdateWithoutCoverageMajorInput, CoverageMajorLectureUncheckedUpdateWithoutCoverageMajorInput>
  }

  export type CoverageMajorLectureUpdateManyWithWhereWithoutCoverageMajorInput = {
    where: CoverageMajorLectureScalarWhereInput
    data: XOR<CoverageMajorLectureUpdateManyMutationInput, CoverageMajorLectureUncheckedUpdateManyWithoutCoverageMajorLecturesInput>
  }

  export type CoverageMajorLectureScalarWhereInput = {
    AND?: Enumerable<CoverageMajorLectureScalarWhereInput>
    OR?: Enumerable<CoverageMajorLectureScalarWhereInput>
    NOT?: Enumerable<CoverageMajorLectureScalarWhereInput>
    lectureId?: StringFilter | string
    majorCode?: StringFilter | string
  }

  export type LectureCreateWithoutCoverageMajorLecturesInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    periods?: PeriodCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutCoverageMajorLecturesInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    periods?: PeriodUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutCoverageMajorLecturesInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutCoverageMajorLecturesInput, LectureUncheckedCreateWithoutCoverageMajorLecturesInput>
  }

  export type CoverageMajorCreateWithoutCoverageMajorLecturesInput = {
    coverageCollege?: string | null
    name: string
    code: string
  }

  export type CoverageMajorUncheckedCreateWithoutCoverageMajorLecturesInput = {
    coverageCollege?: string | null
    name: string
    code: string
  }

  export type CoverageMajorCreateOrConnectWithoutCoverageMajorLecturesInput = {
    where: CoverageMajorWhereUniqueInput
    create: XOR<CoverageMajorCreateWithoutCoverageMajorLecturesInput, CoverageMajorUncheckedCreateWithoutCoverageMajorLecturesInput>
  }

  export type LectureUpsertWithoutCoverageMajorLecturesInput = {
    update: XOR<LectureUpdateWithoutCoverageMajorLecturesInput, LectureUncheckedUpdateWithoutCoverageMajorLecturesInput>
    create: XOR<LectureCreateWithoutCoverageMajorLecturesInput, LectureUncheckedCreateWithoutCoverageMajorLecturesInput>
  }

  export type LectureUpdateWithoutCoverageMajorLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    periods?: PeriodUpdateManyWithoutLectureInput
  }

  export type LectureUncheckedUpdateWithoutCoverageMajorLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    periods?: PeriodUncheckedUpdateManyWithoutLectureInput
  }

  export type CoverageMajorUpsertWithoutCoverageMajorLecturesInput = {
    update: XOR<CoverageMajorUpdateWithoutCoverageMajorLecturesInput, CoverageMajorUncheckedUpdateWithoutCoverageMajorLecturesInput>
    create: XOR<CoverageMajorCreateWithoutCoverageMajorLecturesInput, CoverageMajorUncheckedCreateWithoutCoverageMajorLecturesInput>
  }

  export type CoverageMajorUpdateWithoutCoverageMajorLecturesInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorUncheckedUpdateWithoutCoverageMajorLecturesInput = {
    coverageCollege?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorLectureCreateWithoutLectureInput = {
    coverageMajor: CoverageMajorCreateNestedOneWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedCreateWithoutLectureInput = {
    majorCode: string
  }

  export type CoverageMajorLectureCreateOrConnectWithoutLectureInput = {
    where: CoverageMajorLectureWhereUniqueInput
    create: XOR<CoverageMajorLectureCreateWithoutLectureInput, CoverageMajorLectureUncheckedCreateWithoutLectureInput>
  }

  export type CoverageMajorLectureCreateManyLectureInputEnvelope = {
    data: Enumerable<CoverageMajorLectureCreateManyLectureInput>
    skipDuplicates?: boolean
  }

  export type PeriodCreateWithoutLectureInput = {
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodUncheckedCreateWithoutLectureInput = {
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type PeriodCreateOrConnectWithoutLectureInput = {
    where: PeriodWhereUniqueInput
    create: XOR<PeriodCreateWithoutLectureInput, PeriodUncheckedCreateWithoutLectureInput>
  }

  export type PeriodCreateManyLectureInputEnvelope = {
    data: Enumerable<PeriodCreateManyLectureInput>
    skipDuplicates?: boolean
  }

  export type CoverageMajorLectureUpsertWithWhereUniqueWithoutLectureInput = {
    where: CoverageMajorLectureWhereUniqueInput
    update: XOR<CoverageMajorLectureUpdateWithoutLectureInput, CoverageMajorLectureUncheckedUpdateWithoutLectureInput>
    create: XOR<CoverageMajorLectureCreateWithoutLectureInput, CoverageMajorLectureUncheckedCreateWithoutLectureInput>
  }

  export type CoverageMajorLectureUpdateWithWhereUniqueWithoutLectureInput = {
    where: CoverageMajorLectureWhereUniqueInput
    data: XOR<CoverageMajorLectureUpdateWithoutLectureInput, CoverageMajorLectureUncheckedUpdateWithoutLectureInput>
  }

  export type CoverageMajorLectureUpdateManyWithWhereWithoutLectureInput = {
    where: CoverageMajorLectureScalarWhereInput
    data: XOR<CoverageMajorLectureUpdateManyMutationInput, CoverageMajorLectureUncheckedUpdateManyWithoutCoverageMajorLecturesInput>
  }

  export type PeriodUpsertWithWhereUniqueWithoutLectureInput = {
    where: PeriodWhereUniqueInput
    update: XOR<PeriodUpdateWithoutLectureInput, PeriodUncheckedUpdateWithoutLectureInput>
    create: XOR<PeriodCreateWithoutLectureInput, PeriodUncheckedCreateWithoutLectureInput>
  }

  export type PeriodUpdateWithWhereUniqueWithoutLectureInput = {
    where: PeriodWhereUniqueInput
    data: XOR<PeriodUpdateWithoutLectureInput, PeriodUncheckedUpdateWithoutLectureInput>
  }

  export type PeriodUpdateManyWithWhereWithoutLectureInput = {
    where: PeriodScalarWhereInput
    data: XOR<PeriodUpdateManyMutationInput, PeriodUncheckedUpdateManyWithoutPeriodsInput>
  }

  export type PeriodScalarWhereInput = {
    AND?: Enumerable<PeriodScalarWhereInput>
    OR?: Enumerable<PeriodScalarWhereInput>
    NOT?: Enumerable<PeriodScalarWhereInput>
    lectureId?: StringFilter | string
    day?: StringFilter | string
    startH?: IntFilter | number
    startM?: IntFilter | number
    endH?: IntFilter | number
    endM?: IntFilter | number
  }

  export type UserCreateWithoutLiveChatsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLiveChatsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLiveChatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLiveChatsInput, UserUncheckedCreateWithoutLiveChatsInput>
  }

  export type UserUpsertWithoutLiveChatsInput = {
    update: XOR<UserUpdateWithoutLiveChatsInput, UserUncheckedUpdateWithoutLiveChatsInput>
    create: XOR<UserCreateWithoutLiveChatsInput, UserUncheckedCreateWithoutLiveChatsInput>
  }

  export type UserUpdateWithoutLiveChatsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutLiveChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutNoticeNotificationsSubscriptionsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNoticeNotificationsSubscriptionsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNoticeNotificationsSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNoticeNotificationsSubscriptionsInput, UserUncheckedCreateWithoutNoticeNotificationsSubscriptionsInput>
  }

  export type UserUpsertWithoutNoticeNotificationsSubscriptionsInput = {
    update: XOR<UserUpdateWithoutNoticeNotificationsSubscriptionsInput, UserUncheckedUpdateWithoutNoticeNotificationsSubscriptionsInput>
    create: XOR<UserCreateWithoutNoticeNotificationsSubscriptionsInput, UserUncheckedCreateWithoutNoticeNotificationsSubscriptionsInput>
  }

  export type UserUpdateWithoutNoticeNotificationsSubscriptionsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutNoticeNotificationsSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type LectureCreateWithoutPeriodsInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    coverageMajorLectures?: CoverageMajorLectureCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutPeriodsInput = {
    id: string
    year?: number | null
    semester?: string | null
    campus?: string | null
    college?: string | null
    major?: string | null
    grade?: number | null
    credit?: number | null
    course?: string | null
    section?: string | null
    code?: string | null
    name?: string | null
    professor?: string | null
    schedule?: string | null
    building?: number | null
    room?: string | null
    note?: string | null
    coverageMajorLectures?: CoverageMajorLectureUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutPeriodsInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutPeriodsInput, LectureUncheckedCreateWithoutPeriodsInput>
  }

  export type LectureUpsertWithoutPeriodsInput = {
    update: XOR<LectureUpdateWithoutPeriodsInput, LectureUncheckedUpdateWithoutPeriodsInput>
    create: XOR<LectureCreateWithoutPeriodsInput, LectureUncheckedCreateWithoutPeriodsInput>
  }

  export type LectureUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    coverageMajorLectures?: CoverageMajorLectureUpdateManyWithoutLectureInput
  }

  export type LectureUncheckedUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableIntFieldUpdateOperationsInput | number | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    professor?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableIntFieldUpdateOperationsInput | number | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    coverageMajorLectures?: CoverageMajorLectureUncheckedUpdateManyWithoutLectureInput
  }

  export type AdminCreateWithoutUserInput = {

  }

  export type AdminUncheckedCreateWithoutUserInput = {

  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type ChangePasswordCreateWithoutUserInput = {
    token: string
    requestedAt: Date | string
  }

  export type ChangePasswordUncheckedCreateWithoutUserInput = {
    token: string
    requestedAt: Date | string
  }

  export type ChangePasswordCreateOrConnectWithoutUserInput = {
    where: ChangePasswordWhereUniqueInput
    create: XOR<ChangePasswordCreateWithoutUserInput, ChangePasswordUncheckedCreateWithoutUserInput>
  }

  export type CommunityBoardCreateWithoutUserInput = {
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdAt: Date | string
    activeAt?: Date | string | null
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdAt: Date | string
    activeAt?: Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutCommunityBoardInput
  }

  export type CommunityBoardCreateOrConnectWithoutUserInput = {
    where: CommunityBoardWhereUniqueInput
    create: XOR<CommunityBoardCreateWithoutUserInput, CommunityBoardUncheckedCreateWithoutUserInput>
  }

  export type CommunityBoardCreateManyUserInputEnvelope = {
    data: Enumerable<CommunityBoardCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CommunityBoardCandidateCreateWithoutUserInput = {
    name?: string
    description?: string | null
    createdAt: Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string
    description?: string | null
    createdAt: Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateCreateOrConnectWithoutUserInput = {
    where: CommunityBoardCandidateWhereUniqueInput
    create: XOR<CommunityBoardCandidateCreateWithoutUserInput, CommunityBoardCandidateUncheckedCreateWithoutUserInput>
  }

  export type CommunityBoardCandidateCreateManyUserInputEnvelope = {
    data: Enumerable<CommunityBoardCandidateCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CommunityBoardCandidateVoteCreateWithoutUserInput = {
    communityBoardCandidate: CommunityBoardCandidateCreateNestedOneWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput = {
    boardCandidateId: number
  }

  export type CommunityBoardCandidateVoteCreateOrConnectWithoutUserInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    create: XOR<CommunityBoardCandidateVoteCreateWithoutUserInput, CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput>
  }

  export type CommunityBoardCandidateVoteCreateManyUserInputEnvelope = {
    data: Enumerable<CommunityBoardCandidateVoteCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CommunityBoardPinCreateWithoutUserInput = {
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedCreateWithoutUserInput = {
    boardId: number
  }

  export type CommunityBoardPinCreateOrConnectWithoutUserInput = {
    where: CommunityBoardPinWhereUniqueInput
    create: XOR<CommunityBoardPinCreateWithoutUserInput, CommunityBoardPinUncheckedCreateWithoutUserInput>
  }

  export type CommunityBoardPinCreateManyUserInputEnvelope = {
    data: Enumerable<CommunityBoardPinCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CommunityCommentCreateWithoutUserInput = {
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communityPost: CommunityPostCreateNestedOneWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentCreateOrConnectWithoutUserInput = {
    where: CommunityCommentWhereUniqueInput
    create: XOR<CommunityCommentCreateWithoutUserInput, CommunityCommentUncheckedCreateWithoutUserInput>
  }

  export type CommunityCommentCreateManyUserInputEnvelope = {
    data: Enumerable<CommunityCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CommunityPostCreateWithoutUserInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutUserInput = {
    id?: number
    boardId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutUserInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutUserInput, CommunityPostUncheckedCreateWithoutUserInput>
  }

  export type CommunityPostCreateManyUserInputEnvelope = {
    data: Enumerable<CommunityPostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CommunityPostBookmarkCreateWithoutUserInput = {
    communityPost: CommunityPostCreateNestedOneWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedCreateWithoutUserInput = {
    postId: number
  }

  export type CommunityPostBookmarkCreateOrConnectWithoutUserInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    create: XOR<CommunityPostBookmarkCreateWithoutUserInput, CommunityPostBookmarkUncheckedCreateWithoutUserInput>
  }

  export type CommunityPostBookmarkCreateManyUserInputEnvelope = {
    data: Enumerable<CommunityPostBookmarkCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CommunityPostLikeCreateWithoutUserInput = {
    communityPost: CommunityPostCreateNestedOneWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedCreateWithoutUserInput = {
    postId: number
  }

  export type CommunityPostLikeCreateOrConnectWithoutUserInput = {
    where: CommunityPostLikeWhereUniqueInput
    create: XOR<CommunityPostLikeCreateWithoutUserInput, CommunityPostLikeUncheckedCreateWithoutUserInput>
  }

  export type CommunityPostLikeCreateManyUserInputEnvelope = {
    data: Enumerable<CommunityPostLikeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CommunitySubcommentCreateWithoutUserInput = {
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    communityComment: CommunityCommentCreateNestedOneWithoutCommunitySubcommentsInput
    communityPost: CommunityPostCreateNestedOneWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    commentId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentCreateOrConnectWithoutUserInput = {
    where: CommunitySubcommentWhereUniqueInput
    create: XOR<CommunitySubcommentCreateWithoutUserInput, CommunitySubcommentUncheckedCreateWithoutUserInput>
  }

  export type CommunitySubcommentCreateManyUserInputEnvelope = {
    data: Enumerable<CommunitySubcommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LiveChatCreateWithoutUserInput = {
    id?: number
    message: string
    createdAt: Date | string
    randomNickname: string
  }

  export type LiveChatUncheckedCreateWithoutUserInput = {
    id?: number
    message: string
    createdAt: Date | string
    randomNickname: string
  }

  export type LiveChatCreateOrConnectWithoutUserInput = {
    where: LiveChatWhereUniqueInput
    create: XOR<LiveChatCreateWithoutUserInput, LiveChatUncheckedCreateWithoutUserInput>
  }

  export type LiveChatCreateManyUserInputEnvelope = {
    data: Enumerable<LiveChatCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type NoticeNotificationsSubscriptionCreateWithoutUserInput = {
    noticeKey: string
    subscribedAt: Date | string
  }

  export type NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput = {
    id?: number
    noticeKey: string
    subscribedAt: Date | string
  }

  export type NoticeNotificationsSubscriptionCreateOrConnectWithoutUserInput = {
    where: NoticeNotificationsSubscriptionWhereUniqueInput
    create: XOR<NoticeNotificationsSubscriptionCreateWithoutUserInput, NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type NoticeNotificationsSubscriptionCreateManyUserInputEnvelope = {
    data: Enumerable<NoticeNotificationsSubscriptionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ReportCommentCreateWithoutUserInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communityComment: CommunityCommentCreateNestedOneWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedCreateWithoutUserInput = {
    id?: number
    commentId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportCommentCreateOrConnectWithoutUserInput = {
    where: ReportCommentWhereUniqueInput
    create: XOR<ReportCommentCreateWithoutUserInput, ReportCommentUncheckedCreateWithoutUserInput>
  }

  export type ReportCommentCreateManyUserInputEnvelope = {
    data: Enumerable<ReportCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ReportPostCreateWithoutUserInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communityPost: CommunityPostCreateNestedOneWithoutReportPostsInput
  }

  export type ReportPostUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportPostCreateOrConnectWithoutUserInput = {
    where: ReportPostWhereUniqueInput
    create: XOR<ReportPostCreateWithoutUserInput, ReportPostUncheckedCreateWithoutUserInput>
  }

  export type ReportPostCreateManyUserInputEnvelope = {
    data: Enumerable<ReportPostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ReportSubcommentCreateWithoutUserInput = {
    title?: string
    body?: string | null
    reportedAt: Date | string
    communitySubcomment: CommunitySubcommentCreateNestedOneWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedCreateWithoutUserInput = {
    id?: number
    subcommentId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportSubcommentCreateOrConnectWithoutUserInput = {
    where: ReportSubcommentWhereUniqueInput
    create: XOR<ReportSubcommentCreateWithoutUserInput, ReportSubcommentUncheckedCreateWithoutUserInput>
  }

  export type ReportSubcommentCreateManyUserInputEnvelope = {
    data: Enumerable<ReportSubcommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TelegramCreateWithoutUserInput = {
    chatId: number
  }

  export type TelegramUncheckedCreateWithoutUserInput = {
    chatId: number
  }

  export type TelegramCreateOrConnectWithoutUserInput = {
    where: TelegramWhereUniqueInput
    create: XOR<TelegramCreateWithoutUserInput, TelegramUncheckedCreateWithoutUserInput>
  }

  export type TelegramCreateManyUserInputEnvelope = {
    data: Enumerable<TelegramCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AdminUpdateWithoutUserInput = {

  }

  export type AdminUncheckedUpdateWithoutUserInput = {

  }

  export type ChangePasswordUpsertWithoutUserInput = {
    update: XOR<ChangePasswordUpdateWithoutUserInput, ChangePasswordUncheckedUpdateWithoutUserInput>
    create: XOR<ChangePasswordCreateWithoutUserInput, ChangePasswordUncheckedCreateWithoutUserInput>
  }

  export type ChangePasswordUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangePasswordUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBoardUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardWhereUniqueInput
    update: XOR<CommunityBoardUpdateWithoutUserInput, CommunityBoardUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityBoardCreateWithoutUserInput, CommunityBoardUncheckedCreateWithoutUserInput>
  }

  export type CommunityBoardUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardWhereUniqueInput
    data: XOR<CommunityBoardUpdateWithoutUserInput, CommunityBoardUncheckedUpdateWithoutUserInput>
  }

  export type CommunityBoardUpdateManyWithWhereWithoutUserInput = {
    where: CommunityBoardScalarWhereInput
    data: XOR<CommunityBoardUpdateManyMutationInput, CommunityBoardUncheckedUpdateManyWithoutCommunityBoardsInput>
  }

  export type CommunityBoardScalarWhereInput = {
    AND?: Enumerable<CommunityBoardScalarWhereInput>
    OR?: Enumerable<CommunityBoardScalarWhereInput>
    NOT?: Enumerable<CommunityBoardScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    priority?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    createdBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    activeAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CommunityBoardCandidateUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardCandidateWhereUniqueInput
    update: XOR<CommunityBoardCandidateUpdateWithoutUserInput, CommunityBoardCandidateUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityBoardCandidateCreateWithoutUserInput, CommunityBoardCandidateUncheckedCreateWithoutUserInput>
  }

  export type CommunityBoardCandidateUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardCandidateWhereUniqueInput
    data: XOR<CommunityBoardCandidateUpdateWithoutUserInput, CommunityBoardCandidateUncheckedUpdateWithoutUserInput>
  }

  export type CommunityBoardCandidateUpdateManyWithWhereWithoutUserInput = {
    where: CommunityBoardCandidateScalarWhereInput
    data: XOR<CommunityBoardCandidateUpdateManyMutationInput, CommunityBoardCandidateUncheckedUpdateManyWithoutCommunityBoardCandidatesInput>
  }

  export type CommunityBoardCandidateScalarWhereInput = {
    AND?: Enumerable<CommunityBoardCandidateScalarWhereInput>
    OR?: Enumerable<CommunityBoardCandidateScalarWhereInput>
    NOT?: Enumerable<CommunityBoardCandidateScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type CommunityBoardCandidateVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    update: XOR<CommunityBoardCandidateVoteUpdateWithoutUserInput, CommunityBoardCandidateVoteUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityBoardCandidateVoteCreateWithoutUserInput, CommunityBoardCandidateVoteUncheckedCreateWithoutUserInput>
  }

  export type CommunityBoardCandidateVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardCandidateVoteWhereUniqueInput
    data: XOR<CommunityBoardCandidateVoteUpdateWithoutUserInput, CommunityBoardCandidateVoteUncheckedUpdateWithoutUserInput>
  }

  export type CommunityBoardCandidateVoteUpdateManyWithWhereWithoutUserInput = {
    where: CommunityBoardCandidateVoteScalarWhereInput
    data: XOR<CommunityBoardCandidateVoteUpdateManyMutationInput, CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateVotesInput>
  }

  export type CommunityBoardPinUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardPinWhereUniqueInput
    update: XOR<CommunityBoardPinUpdateWithoutUserInput, CommunityBoardPinUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityBoardPinCreateWithoutUserInput, CommunityBoardPinUncheckedCreateWithoutUserInput>
  }

  export type CommunityBoardPinUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityBoardPinWhereUniqueInput
    data: XOR<CommunityBoardPinUpdateWithoutUserInput, CommunityBoardPinUncheckedUpdateWithoutUserInput>
  }

  export type CommunityBoardPinUpdateManyWithWhereWithoutUserInput = {
    where: CommunityBoardPinScalarWhereInput
    data: XOR<CommunityBoardPinUpdateManyMutationInput, CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardPinsInput>
  }

  export type CommunityCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityCommentWhereUniqueInput
    update: XOR<CommunityCommentUpdateWithoutUserInput, CommunityCommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityCommentCreateWithoutUserInput, CommunityCommentUncheckedCreateWithoutUserInput>
  }

  export type CommunityCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityCommentWhereUniqueInput
    data: XOR<CommunityCommentUpdateWithoutUserInput, CommunityCommentUncheckedUpdateWithoutUserInput>
  }

  export type CommunityCommentUpdateManyWithWhereWithoutUserInput = {
    where: CommunityCommentScalarWhereInput
    data: XOR<CommunityCommentUpdateManyMutationInput, CommunityCommentUncheckedUpdateManyWithoutCommunityCommentsInput>
  }

  export type CommunityPostUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityPostWhereUniqueInput
    update: XOR<CommunityPostUpdateWithoutUserInput, CommunityPostUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityPostCreateWithoutUserInput, CommunityPostUncheckedCreateWithoutUserInput>
  }

  export type CommunityPostUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityPostWhereUniqueInput
    data: XOR<CommunityPostUpdateWithoutUserInput, CommunityPostUncheckedUpdateWithoutUserInput>
  }

  export type CommunityPostUpdateManyWithWhereWithoutUserInput = {
    where: CommunityPostScalarWhereInput
    data: XOR<CommunityPostUpdateManyMutationInput, CommunityPostUncheckedUpdateManyWithoutCommunityPostsInput>
  }

  export type CommunityPostBookmarkUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    update: XOR<CommunityPostBookmarkUpdateWithoutUserInput, CommunityPostBookmarkUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityPostBookmarkCreateWithoutUserInput, CommunityPostBookmarkUncheckedCreateWithoutUserInput>
  }

  export type CommunityPostBookmarkUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityPostBookmarkWhereUniqueInput
    data: XOR<CommunityPostBookmarkUpdateWithoutUserInput, CommunityPostBookmarkUncheckedUpdateWithoutUserInput>
  }

  export type CommunityPostBookmarkUpdateManyWithWhereWithoutUserInput = {
    where: CommunityPostBookmarkScalarWhereInput
    data: XOR<CommunityPostBookmarkUpdateManyMutationInput, CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostBookmarksInput>
  }

  export type CommunityPostLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityPostLikeWhereUniqueInput
    update: XOR<CommunityPostLikeUpdateWithoutUserInput, CommunityPostLikeUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityPostLikeCreateWithoutUserInput, CommunityPostLikeUncheckedCreateWithoutUserInput>
  }

  export type CommunityPostLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityPostLikeWhereUniqueInput
    data: XOR<CommunityPostLikeUpdateWithoutUserInput, CommunityPostLikeUncheckedUpdateWithoutUserInput>
  }

  export type CommunityPostLikeUpdateManyWithWhereWithoutUserInput = {
    where: CommunityPostLikeScalarWhereInput
    data: XOR<CommunityPostLikeUpdateManyMutationInput, CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostLikesInput>
  }

  export type CommunitySubcommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunitySubcommentWhereUniqueInput
    update: XOR<CommunitySubcommentUpdateWithoutUserInput, CommunitySubcommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommunitySubcommentCreateWithoutUserInput, CommunitySubcommentUncheckedCreateWithoutUserInput>
  }

  export type CommunitySubcommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunitySubcommentWhereUniqueInput
    data: XOR<CommunitySubcommentUpdateWithoutUserInput, CommunitySubcommentUncheckedUpdateWithoutUserInput>
  }

  export type CommunitySubcommentUpdateManyWithWhereWithoutUserInput = {
    where: CommunitySubcommentScalarWhereInput
    data: XOR<CommunitySubcommentUpdateManyMutationInput, CommunitySubcommentUncheckedUpdateManyWithoutCommunitySubcommentsInput>
  }

  export type LiveChatUpsertWithWhereUniqueWithoutUserInput = {
    where: LiveChatWhereUniqueInput
    update: XOR<LiveChatUpdateWithoutUserInput, LiveChatUncheckedUpdateWithoutUserInput>
    create: XOR<LiveChatCreateWithoutUserInput, LiveChatUncheckedCreateWithoutUserInput>
  }

  export type LiveChatUpdateWithWhereUniqueWithoutUserInput = {
    where: LiveChatWhereUniqueInput
    data: XOR<LiveChatUpdateWithoutUserInput, LiveChatUncheckedUpdateWithoutUserInput>
  }

  export type LiveChatUpdateManyWithWhereWithoutUserInput = {
    where: LiveChatScalarWhereInput
    data: XOR<LiveChatUpdateManyMutationInput, LiveChatUncheckedUpdateManyWithoutLiveChatsInput>
  }

  export type LiveChatScalarWhereInput = {
    AND?: Enumerable<LiveChatScalarWhereInput>
    OR?: Enumerable<LiveChatScalarWhereInput>
    NOT?: Enumerable<LiveChatScalarWhereInput>
    id?: IntFilter | number
    message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    randomNickname?: StringFilter | string
  }

  export type NoticeNotificationsSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: NoticeNotificationsSubscriptionWhereUniqueInput
    update: XOR<NoticeNotificationsSubscriptionUpdateWithoutUserInput, NoticeNotificationsSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<NoticeNotificationsSubscriptionCreateWithoutUserInput, NoticeNotificationsSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type NoticeNotificationsSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: NoticeNotificationsSubscriptionWhereUniqueInput
    data: XOR<NoticeNotificationsSubscriptionUpdateWithoutUserInput, NoticeNotificationsSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type NoticeNotificationsSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: NoticeNotificationsSubscriptionScalarWhereInput
    data: XOR<NoticeNotificationsSubscriptionUpdateManyMutationInput, NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutNoticeNotificationsSubscriptionsInput>
  }

  export type NoticeNotificationsSubscriptionScalarWhereInput = {
    AND?: Enumerable<NoticeNotificationsSubscriptionScalarWhereInput>
    OR?: Enumerable<NoticeNotificationsSubscriptionScalarWhereInput>
    NOT?: Enumerable<NoticeNotificationsSubscriptionScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    noticeKey?: StringFilter | string
    subscribedAt?: DateTimeFilter | Date | string
  }

  export type ReportCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportCommentWhereUniqueInput
    update: XOR<ReportCommentUpdateWithoutUserInput, ReportCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ReportCommentCreateWithoutUserInput, ReportCommentUncheckedCreateWithoutUserInput>
  }

  export type ReportCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportCommentWhereUniqueInput
    data: XOR<ReportCommentUpdateWithoutUserInput, ReportCommentUncheckedUpdateWithoutUserInput>
  }

  export type ReportCommentUpdateManyWithWhereWithoutUserInput = {
    where: ReportCommentScalarWhereInput
    data: XOR<ReportCommentUpdateManyMutationInput, ReportCommentUncheckedUpdateManyWithoutReportCommentsInput>
  }

  export type ReportPostUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportPostWhereUniqueInput
    update: XOR<ReportPostUpdateWithoutUserInput, ReportPostUncheckedUpdateWithoutUserInput>
    create: XOR<ReportPostCreateWithoutUserInput, ReportPostUncheckedCreateWithoutUserInput>
  }

  export type ReportPostUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportPostWhereUniqueInput
    data: XOR<ReportPostUpdateWithoutUserInput, ReportPostUncheckedUpdateWithoutUserInput>
  }

  export type ReportPostUpdateManyWithWhereWithoutUserInput = {
    where: ReportPostScalarWhereInput
    data: XOR<ReportPostUpdateManyMutationInput, ReportPostUncheckedUpdateManyWithoutReportPostsInput>
  }

  export type ReportSubcommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportSubcommentWhereUniqueInput
    update: XOR<ReportSubcommentUpdateWithoutUserInput, ReportSubcommentUncheckedUpdateWithoutUserInput>
    create: XOR<ReportSubcommentCreateWithoutUserInput, ReportSubcommentUncheckedCreateWithoutUserInput>
  }

  export type ReportSubcommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportSubcommentWhereUniqueInput
    data: XOR<ReportSubcommentUpdateWithoutUserInput, ReportSubcommentUncheckedUpdateWithoutUserInput>
  }

  export type ReportSubcommentUpdateManyWithWhereWithoutUserInput = {
    where: ReportSubcommentScalarWhereInput
    data: XOR<ReportSubcommentUpdateManyMutationInput, ReportSubcommentUncheckedUpdateManyWithoutReportSubcommentsInput>
  }

  export type TelegramUpsertWithWhereUniqueWithoutUserInput = {
    where: TelegramWhereUniqueInput
    update: XOR<TelegramUpdateWithoutUserInput, TelegramUncheckedUpdateWithoutUserInput>
    create: XOR<TelegramCreateWithoutUserInput, TelegramUncheckedCreateWithoutUserInput>
  }

  export type TelegramUpdateWithWhereUniqueWithoutUserInput = {
    where: TelegramWhereUniqueInput
    data: XOR<TelegramUpdateWithoutUserInput, TelegramUncheckedUpdateWithoutUserInput>
  }

  export type TelegramUpdateManyWithWhereWithoutUserInput = {
    where: TelegramScalarWhereInput
    data: XOR<TelegramUpdateManyMutationInput, TelegramUncheckedUpdateManyWithoutTelegramsInput>
  }

  export type TelegramScalarWhereInput = {
    AND?: Enumerable<TelegramScalarWhereInput>
    OR?: Enumerable<TelegramScalarWhereInput>
    NOT?: Enumerable<TelegramScalarWhereInput>
    userId?: IntFilter | number
    chatId?: IntFilter | number
  }

  export type CommunityCommentCreateWithoutReportCommentsInput = {
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communityPost: CommunityPostCreateNestedOneWithoutCommunityCommentsInput
    user: UserCreateNestedOneWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedCreateWithoutReportCommentsInput = {
    id?: number
    postId: number
    userId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityCommentInput
  }

  export type CommunityCommentCreateOrConnectWithoutReportCommentsInput = {
    where: CommunityCommentWhereUniqueInput
    create: XOR<CommunityCommentCreateWithoutReportCommentsInput, CommunityCommentUncheckedCreateWithoutReportCommentsInput>
  }

  export type UserCreateWithoutReportCommentsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportCommentsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportCommentsInput, UserUncheckedCreateWithoutReportCommentsInput>
  }

  export type CommunityCommentUpsertWithoutReportCommentsInput = {
    update: XOR<CommunityCommentUpdateWithoutReportCommentsInput, CommunityCommentUncheckedUpdateWithoutReportCommentsInput>
    create: XOR<CommunityCommentCreateWithoutReportCommentsInput, CommunityCommentUncheckedCreateWithoutReportCommentsInput>
  }

  export type CommunityCommentUpdateWithoutReportCommentsInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityCommentsInput
    user?: UserUpdateOneRequiredWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateWithoutReportCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityCommentInput
  }

  export type UserUpsertWithoutReportCommentsInput = {
    update: XOR<UserUpdateWithoutReportCommentsInput, UserUncheckedUpdateWithoutReportCommentsInput>
    create: XOR<UserCreateWithoutReportCommentsInput, UserUncheckedCreateWithoutReportCommentsInput>
  }

  export type UserUpdateWithoutReportCommentsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutReportCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityPostCreateWithoutReportPostsInput = {
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityBoard: CommunityBoardCreateNestedOneWithoutCommunityPostsInput
    user: UserCreateNestedOneWithoutCommunityPostsInput
    communityComments?: CommunityCommentCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedCreateWithoutReportPostsInput = {
    id?: number
    boardId: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutCommunityPostInput
  }

  export type CommunityPostCreateOrConnectWithoutReportPostsInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutReportPostsInput, CommunityPostUncheckedCreateWithoutReportPostsInput>
  }

  export type UserCreateWithoutReportPostsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportPostsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportPostsInput, UserUncheckedCreateWithoutReportPostsInput>
  }

  export type CommunityPostUpsertWithoutReportPostsInput = {
    update: XOR<CommunityPostUpdateWithoutReportPostsInput, CommunityPostUncheckedUpdateWithoutReportPostsInput>
    create: XOR<CommunityPostCreateWithoutReportPostsInput, CommunityPostUncheckedCreateWithoutReportPostsInput>
  }

  export type CommunityPostUpdateWithoutReportPostsInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutReportPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type UserUpsertWithoutReportPostsInput = {
    update: XOR<UserUpdateWithoutReportPostsInput, UserUncheckedUpdateWithoutReportPostsInput>
    create: XOR<UserCreateWithoutReportPostsInput, UserUncheckedCreateWithoutReportPostsInput>
  }

  export type UserUpdateWithoutReportPostsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutReportPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type CommunitySubcommentCreateWithoutReportSubcommentsInput = {
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
    communityComment: CommunityCommentCreateNestedOneWithoutCommunitySubcommentsInput
    communityPost: CommunityPostCreateNestedOneWithoutCommunitySubcommentsInput
    user: UserCreateNestedOneWithoutCommunitySubcommentsInput
  }

  export type CommunitySubcommentUncheckedCreateWithoutReportSubcommentsInput = {
    id?: number
    userId: number
    postId: number
    commentId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
  }

  export type CommunitySubcommentCreateOrConnectWithoutReportSubcommentsInput = {
    where: CommunitySubcommentWhereUniqueInput
    create: XOR<CommunitySubcommentCreateWithoutReportSubcommentsInput, CommunitySubcommentUncheckedCreateWithoutReportSubcommentsInput>
  }

  export type UserCreateWithoutReportSubcommentsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    telegrams?: TelegramCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportSubcommentsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    telegrams?: TelegramUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportSubcommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportSubcommentsInput, UserUncheckedCreateWithoutReportSubcommentsInput>
  }

  export type CommunitySubcommentUpsertWithoutReportSubcommentsInput = {
    update: XOR<CommunitySubcommentUpdateWithoutReportSubcommentsInput, CommunitySubcommentUncheckedUpdateWithoutReportSubcommentsInput>
    create: XOR<CommunitySubcommentCreateWithoutReportSubcommentsInput, CommunitySubcommentUncheckedCreateWithoutReportSubcommentsInput>
  }

  export type CommunitySubcommentUpdateWithoutReportSubcommentsInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComment?: CommunityCommentUpdateOneRequiredWithoutCommunitySubcommentsInput
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunitySubcommentsInput
    user?: UserUpdateOneRequiredWithoutCommunitySubcommentsInput
  }

  export type CommunitySubcommentUncheckedUpdateWithoutReportSubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutReportSubcommentsInput = {
    update: XOR<UserUpdateWithoutReportSubcommentsInput, UserUncheckedUpdateWithoutReportSubcommentsInput>
    create: XOR<UserCreateWithoutReportSubcommentsInput, UserUncheckedCreateWithoutReportSubcommentsInput>
  }

  export type UserUpdateWithoutReportSubcommentsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    telegrams?: TelegramUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutReportSubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    telegrams?: TelegramUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutTelegramsInput = {
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentCreateNestedManyWithoutUserInput
    liveChats?: LiveChatCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTelegramsInput = {
    id?: number
    portalId: string
    password: string
    nickname: string
    randomNickname: string
    point?: number | null
    joinedAt: Date | string
    refreshToken?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedCreateNestedOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedCreateNestedManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedCreateNestedManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedCreateNestedManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedCreateNestedManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedCreateNestedManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedCreateNestedManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedCreateNestedManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedCreateNestedManyWithoutUserInput
    liveChats?: LiveChatUncheckedCreateNestedManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedCreateNestedManyWithoutUserInput
    reportComments?: ReportCommentUncheckedCreateNestedManyWithoutUserInput
    reportPosts?: ReportPostUncheckedCreateNestedManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTelegramsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTelegramsInput, UserUncheckedCreateWithoutTelegramsInput>
  }

  export type UserUpsertWithoutTelegramsInput = {
    update: XOR<UserUpdateWithoutTelegramsInput, UserUncheckedUpdateWithoutTelegramsInput>
    create: XOR<UserCreateWithoutTelegramsInput, UserUncheckedCreateWithoutTelegramsInput>
  }

  export type UserUpdateWithoutTelegramsInput = {
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutUserInput
    liveChats?: LiveChatUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUpdateManyWithoutUserInput
    reportComments?: ReportCommentUpdateManyWithoutUserInput
    reportPosts?: ReportPostUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutTelegramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    portalId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserInput
    changePassword?: ChangePasswordUncheckedUpdateOneWithoutUserInput
    communityBoards?: CommunityBoardUncheckedUpdateManyWithoutUserInput
    communityBoardCandidates?: CommunityBoardCandidateUncheckedUpdateManyWithoutUserInput
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutUserInput
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutUserInput
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutUserInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutUserInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutUserInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutUserInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutUserInput
    liveChats?: LiveChatUncheckedUpdateManyWithoutUserInput
    noticeNotificationsSubscriptions?: NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutUserInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutUserInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutUserInput
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutUserInput
  }

  export type CommunityBoardPinCreateManyCommunityBoardInput = {
    userId: number
  }

  export type CommunityPostCreateManyCommunityBoardInput = {
    id?: number
    userId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type CommunityBoardPinUpdateWithoutCommunityBoardInput = {
    user?: UserUpdateOneRequiredWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedUpdateWithoutCommunityBoardInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardPinsInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostUpdateWithoutCommunityBoardInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommunityBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateManyWithoutCommunityPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityBoardCandidateVoteCreateManyCommunityBoardCandidateInput = {
    userId: number
  }

  export type CommunityBoardCandidateVoteUpdateWithoutCommunityBoardCandidateInput = {
    user?: UserUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateWithoutCommunityBoardCandidateInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateVotesInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunitySubcommentCreateManyCommunityCommentInput = {
    id?: number
    userId: number
    postId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
  }

  export type ReportCommentCreateManyCommunityCommentInput = {
    id?: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type CommunitySubcommentUpdateWithoutCommunityCommentInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunitySubcommentsInput
    user?: UserUpdateOneRequiredWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedUpdateWithoutCommunityCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedUpdateManyWithoutCommunitySubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReportCommentUpdateWithoutCommunityCommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedUpdateWithoutCommunityCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCommentUncheckedUpdateManyWithoutReportCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCommentCreateManyCommunityPostInput = {
    id?: number
    userId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
  }

  export type CommunityPostBookmarkCreateManyCommunityPostInput = {
    userId: number
  }

  export type CommunityPostLikeCreateManyCommunityPostInput = {
    userId: number
  }

  export type CommunitySubcommentCreateManyCommunityPostInput = {
    id?: number
    userId: number
    commentId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
  }

  export type ReportPostCreateManyCommunityPostInput = {
    id?: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type CommunityCommentUpdateWithoutCommunityPostInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateWithoutCommunityPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateManyWithoutCommunityCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommunityPostBookmarkUpdateWithoutCommunityPostInput = {
    user?: UserUpdateOneRequiredWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedUpdateWithoutCommunityPostInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostBookmarksInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostLikeUpdateWithoutCommunityPostInput = {
    user?: UserUpdateOneRequiredWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedUpdateWithoutCommunityPostInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostLikesInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunitySubcommentUpdateWithoutCommunityPostInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComment?: CommunityCommentUpdateOneRequiredWithoutCommunitySubcommentsInput
    user?: UserUpdateOneRequiredWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedUpdateWithoutCommunityPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutCommunitySubcommentInput
  }

  export type ReportPostUpdateWithoutCommunityPostInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportPostsInput
  }

  export type ReportPostUncheckedUpdateWithoutCommunityPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPostUncheckedUpdateManyWithoutReportPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentCreateManyCommunitySubcommentInput = {
    id?: number
    userId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportSubcommentUpdateWithoutCommunitySubcommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedUpdateWithoutCommunitySubcommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentUncheckedUpdateManyWithoutReportSubcommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoverageMajorLectureCreateManyCoverageMajorInput = {
    lectureId: string
  }

  export type CoverageMajorLectureUpdateWithoutCoverageMajorInput = {
    lecture?: LectureUpdateOneRequiredWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedUpdateWithoutCoverageMajorInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorLectureUncheckedUpdateManyWithoutCoverageMajorLecturesInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
  }

  export type CoverageMajorLectureCreateManyLectureInput = {
    majorCode: string
  }

  export type PeriodCreateManyLectureInput = {
    day: string
    startH: number
    startM: number
    endH: number
    endM: number
  }

  export type CoverageMajorLectureUpdateWithoutLectureInput = {
    coverageMajor?: CoverageMajorUpdateOneRequiredWithoutCoverageMajorLecturesInput
  }

  export type CoverageMajorLectureUncheckedUpdateWithoutLectureInput = {
    majorCode?: StringFieldUpdateOperationsInput | string
  }

  export type PeriodUpdateWithoutLectureInput = {
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type PeriodUncheckedUpdateWithoutLectureInput = {
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type PeriodUncheckedUpdateManyWithoutPeriodsInput = {
    day?: StringFieldUpdateOperationsInput | string
    startH?: IntFieldUpdateOperationsInput | number
    startM?: IntFieldUpdateOperationsInput | number
    endH?: IntFieldUpdateOperationsInput | number
    endM?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardCreateManyUserInput = {
    id?: number
    name?: string
    description?: string | null
    priority?: number
    isDeleted?: boolean
    createdAt: Date | string
    activeAt?: Date | string | null
  }

  export type CommunityBoardCandidateCreateManyUserInput = {
    id?: number
    name?: string
    description?: string | null
    createdAt: Date | string
  }

  export type CommunityBoardCandidateVoteCreateManyUserInput = {
    boardCandidateId: number
  }

  export type CommunityBoardPinCreateManyUserInput = {
    boardId: number
  }

  export type CommunityCommentCreateManyUserInput = {
    id?: number
    postId: number
    randomNickname?: string
    body: string
    commentedAt: Date | string
    isDeleted?: boolean
  }

  export type CommunityPostCreateManyUserInput = {
    id?: number
    boardId: number
    title: string
    body: string
    randomNickname: string
    likesCount?: number
    commentsCount?: number
    bookmarksCount?: number
    postedAt: Date | string
    editedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type CommunityPostBookmarkCreateManyUserInput = {
    postId: number
  }

  export type CommunityPostLikeCreateManyUserInput = {
    postId: number
  }

  export type CommunitySubcommentCreateManyUserInput = {
    id?: number
    postId: number
    commentId: number
    randomNickname?: string
    body: string
    subcommentedAt: Date | string
    isDeleted?: boolean
  }

  export type LiveChatCreateManyUserInput = {
    id?: number
    message: string
    createdAt: Date | string
    randomNickname: string
  }

  export type NoticeNotificationsSubscriptionCreateManyUserInput = {
    id?: number
    noticeKey: string
    subscribedAt: Date | string
  }

  export type ReportCommentCreateManyUserInput = {
    id?: number
    commentId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportPostCreateManyUserInput = {
    id?: number
    postId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type ReportSubcommentCreateManyUserInput = {
    id?: number
    subcommentId: number
    title?: string
    body?: string | null
    reportedAt: Date | string
  }

  export type TelegramCreateManyUserInput = {
    chatId: number
  }

  export type CommunityBoardUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityBoardPins?: CommunityBoardPinUpdateManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityBoardPins?: CommunityBoardPinUncheckedUpdateManyWithoutCommunityBoardInput
    communityPosts?: CommunityPostUncheckedUpdateManyWithoutCommunityBoardInput
  }

  export type CommunityBoardUncheckedUpdateManyWithoutCommunityBoardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityBoardCandidateUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUpdateManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityBoardCandidateVotes?: CommunityBoardCandidateVoteUncheckedUpdateManyWithoutCommunityBoardCandidateInput
  }

  export type CommunityBoardCandidateUncheckedUpdateManyWithoutCommunityBoardCandidatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBoardCandidateVoteUpdateWithoutUserInput = {
    communityBoardCandidate?: CommunityBoardCandidateUpdateOneRequiredWithoutCommunityBoardCandidateVotesInput
  }

  export type CommunityBoardCandidateVoteUncheckedUpdateWithoutUserInput = {
    boardCandidateId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityBoardPinUpdateWithoutUserInput = {
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityBoardPinsInput
  }

  export type CommunityBoardPinUncheckedUpdateWithoutUserInput = {
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityCommentUpdateWithoutUserInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityCommentsInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    commentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityCommentInput
    reportComments?: ReportCommentUncheckedUpdateManyWithoutCommunityCommentInput
  }

  export type CommunityPostUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityBoard?: CommunityBoardUpdateOneRequiredWithoutCommunityPostsInput
    communityComments?: CommunityCommentUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    randomNickname?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    bookmarksCount?: IntFieldUpdateOperationsInput | number
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComments?: CommunityCommentUncheckedUpdateManyWithoutCommunityPostInput
    communityPostBookmarks?: CommunityPostBookmarkUncheckedUpdateManyWithoutCommunityPostInput
    communityPostLikes?: CommunityPostLikeUncheckedUpdateManyWithoutCommunityPostInput
    communitySubcomments?: CommunitySubcommentUncheckedUpdateManyWithoutCommunityPostInput
    reportPosts?: ReportPostUncheckedUpdateManyWithoutCommunityPostInput
  }

  export type CommunityPostBookmarkUpdateWithoutUserInput = {
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityPostBookmarksInput
  }

  export type CommunityPostBookmarkUncheckedUpdateWithoutUserInput = {
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityPostLikeUpdateWithoutUserInput = {
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunityPostLikesInput
  }

  export type CommunityPostLikeUncheckedUpdateWithoutUserInput = {
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunitySubcommentUpdateWithoutUserInput = {
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    communityComment?: CommunityCommentUpdateOneRequiredWithoutCommunitySubcommentsInput
    communityPost?: CommunityPostUpdateOneRequiredWithoutCommunitySubcommentsInput
    reportSubcomments?: ReportSubcommentUpdateManyWithoutCommunitySubcommentInput
  }

  export type CommunitySubcommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    randomNickname?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    subcommentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reportSubcomments?: ReportSubcommentUncheckedUpdateManyWithoutCommunitySubcommentInput
  }

  export type LiveChatUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type LiveChatUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type LiveChatUncheckedUpdateManyWithoutLiveChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    randomNickname?: StringFieldUpdateOperationsInput | string
  }

  export type NoticeNotificationsSubscriptionUpdateWithoutUserInput = {
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeNotificationsSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeNotificationsSubscriptionUncheckedUpdateManyWithoutNoticeNotificationsSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    noticeKey?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCommentUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityComment?: CommunityCommentUpdateOneRequiredWithoutReportCommentsInput
  }

  export type ReportCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPostUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityPost?: CommunityPostUpdateOneRequiredWithoutReportPostsInput
  }

  export type ReportPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportSubcommentUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communitySubcomment?: CommunitySubcommentUpdateOneRequiredWithoutReportSubcommentsInput
  }

  export type ReportSubcommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    subcommentId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUpdateWithoutUserInput = {
    chatId?: IntFieldUpdateOperationsInput | number
  }

  export type TelegramUncheckedUpdateWithoutUserInput = {
    chatId?: IntFieldUpdateOperationsInput | number
  }

  export type TelegramUncheckedUpdateManyWithoutTelegramsInput = {
    chatId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}